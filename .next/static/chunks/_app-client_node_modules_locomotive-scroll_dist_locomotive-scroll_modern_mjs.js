"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-client_node_modules_locomotive-scroll_dist_locomotive-scroll_modern_mjs"],{

/***/ "(app-client)/./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ l; }\n/* harmony export */ });\nfunction t(){return t=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(t[s]=i[s])}return t},t.apply(this,arguments)}function e(t,e,i){return Math.max(t,Math.min(e,i))}class i{advance(t){var i;if(!this.isRunning)return;let s=!1;if(this.lerp)this.value=(1-(o=this.lerp))*this.value+o*this.to,Math.round(this.value)===this.to&&(this.value=this.to,s=!0);else{this.currentTime+=t;const i=e(0,this.currentTime/this.duration,1);s=i>=1;const o=s?1:this.easing(i);this.value=this.from+(this.to-this.from)*o}var o;null==(i=this.onUpdate)||i.call(this,this.value,{completed:s}),s&&this.stop()}stop(){this.isRunning=!1}fromTo(t,e,{lerp:i=.1,duration:s=1,easing:o=(t=>t),onUpdate:n}){this.from=this.value=t,this.to=e,this.lerp=i,this.duration=s,this.easing=o,this.currentTime=0,this.isRunning=!0,this.onUpdate=n}}function s(t,e){let i;return function(){let s=arguments,o=this;clearTimeout(i),i=setTimeout(function(){t.apply(o,s)},e)}}class o{constructor(t,e){this.onWindowResize=()=>{this.width=window.innerWidth,this.height=window.innerHeight},this.onWrapperResize=()=>{this.width=this.wrapper.clientWidth,this.height=this.wrapper.clientHeight},this.onContentResize=()=>{const t=this.wrapper===window?document.documentElement:this.wrapper;this.scrollHeight=t.scrollHeight,this.scrollWidth=t.scrollWidth},this.wrapper=t,this.content=e,this.wrapper===window?(window.addEventListener(\"resize\",this.onWindowResize,!1),this.onWindowResize()):(this.wrapperResizeObserver=new ResizeObserver(s(this.onWrapperResize,100)),this.wrapperResizeObserver.observe(this.wrapper),this.onWrapperResize()),this.contentResizeObserver=new ResizeObserver(s(this.onContentResize,100)),this.contentResizeObserver.observe(this.content),this.onContentResize()}destroy(){var t,e;window.removeEventListener(\"resize\",this.onWindowResize,!1),null==(t=this.wrapperResizeObserver)||t.disconnect(),null==(e=this.contentResizeObserver)||e.disconnect()}get limit(){return{x:this.scrollWidth-this.width,y:this.scrollHeight-this.height}}}let n=()=>({events:{},emit(t,...e){let i=this.events[t]||[];for(let t=0,s=i.length;t<s;t++)i[t](...e)},on(t,e){var i;return(null==(i=this.events[t])?void 0:i.push(e))||(this.events[t]=[e]),()=>{var i;this.events[t]=null==(i=this.events[t])?void 0:i.filter(t=>e!==t)}}});class r{constructor(t,{wheelMultiplier:i=1,touchMultiplier:s=2,normalizeWheel:o=!1}){this.onTouchStart=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:0,y:0}},this.onTouchMove=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t,s=-(e-this.touchStart.x)*this.touchMultiplier,o=-(i-this.touchStart.y)*this.touchMultiplier;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:s,y:o},this.emitter.emit(\"scroll\",{type:\"touch\",deltaX:s,deltaY:o,event:t})},this.onTouchEnd=t=>{this.emitter.emit(\"scroll\",{type:\"touch\",inertia:!0,deltaX:this.lastDelta.x,deltaY:this.lastDelta.y,event:t})},this.onWheel=t=>{let{deltaX:i,deltaY:s}=t;this.normalizeWheel&&(i=e(-100,i,100),s=e(-100,s,100)),i*=this.wheelMultiplier,s*=this.wheelMultiplier,this.emitter.emit(\"scroll\",{type:\"wheel\",deltaX:i,deltaY:s,event:t})},this.element=t,this.wheelMultiplier=i,this.touchMultiplier=s,this.normalizeWheel=o,this.touchStart={x:null,y:null},this.emitter=n(),this.element.addEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.addEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.addEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.addEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}on(t,e){return this.emitter.on(t,e)}destroy(){this.emitter.events={},this.element.removeEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.removeEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.removeEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.removeEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}}class l{constructor({direction:e,gestureDirection:s,mouseMultiplier:l,smooth:h,wrapper:a=window,content:c=document.documentElement,wheelEventsTarget:u=a,smoothWheel:p=null==h||h,smoothTouch:d=!1,syncTouch:m=!1,syncTouchLerp:v=.1,touchInertiaMultiplier:g=35,duration:S,easing:w=(t=>Math.min(1,1.001-Math.pow(2,-10*t))),lerp:f=(S?null:.1),infinite:y=!1,orientation:T=(null!=e?e:\"vertical\"),gestureOrientation:z=(null!=s?s:\"vertical\"),touchMultiplier:M=1,wheelMultiplier:E=(null!=l?l:1),normalizeWheel:L=!1}={}){this.onVirtualScroll=({type:e,inertia:i,deltaX:s,deltaY:o,event:n})=>{if(n.ctrlKey)return;const r=\"touch\"===e,l=\"wheel\"===e;if(\"vertical\"===this.options.gestureOrientation&&0===o||\"horizontal\"===this.options.gestureOrientation&&0===s||r&&\"vertical\"===this.options.gestureOrientation&&0===this.scroll&&!this.options.infinite&&o<=0)return;if(n.composedPath().find(t=>null==t||null==t.hasAttribute?void 0:t.hasAttribute(\"data-lenis-prevent\")))return;if(this.isStopped||this.isLocked)return void n.preventDefault();if(this.isSmooth=(this.options.smoothTouch||this.options.syncTouch)&&r||this.options.smoothWheel&&l,!this.isSmooth)return this.isScrolling=!1,void this.animate.stop();n.preventDefault();let h=o;\"both\"===this.options.gestureOrientation?h=Math.abs(o)>Math.abs(s)?o:s:\"horizontal\"===this.options.gestureOrientation&&(h=s);const a=r&&this.options.syncTouch,c=r&&i&&Math.abs(h)>1;c&&(h=this.velocity*this.options.touchInertiaMultiplier),this.scrollTo(this.targetScroll+h,t({programmatic:!1},a&&{lerp:c?this.syncTouchLerp:.4}))},this.onScroll=()=>{if(!this.isScrolling){const t=this.animatedScroll;this.animatedScroll=this.targetScroll=this.actualScroll,this.velocity=0,this.direction=Math.sign(this.animatedScroll-t),this.emit()}},e&&console.warn(\"Lenis: `direction` option is deprecated, use `orientation` instead\"),s&&console.warn(\"Lenis: `gestureDirection` option is deprecated, use `gestureOrientation` instead\"),l&&console.warn(\"Lenis: `mouseMultiplier` option is deprecated, use `wheelMultiplier` instead\"),h&&console.warn(\"Lenis: `smooth` option is deprecated, use `smoothWheel` instead\"),window.lenisVersion=\"1.0.11\",a!==document.documentElement&&a!==document.body||(a=window),this.options={wrapper:a,content:c,wheelEventsTarget:u,smoothWheel:p,smoothTouch:d,syncTouch:m,syncTouchLerp:v,touchInertiaMultiplier:g,duration:S,easing:w,lerp:f,infinite:y,gestureOrientation:z,orientation:T,touchMultiplier:M,wheelMultiplier:E,normalizeWheel:L},this.dimensions=new o(a,c),this.rootElement.classList.add(\"lenis\"),this.velocity=0,this.isStopped=!1,this.isSmooth=p||d,this.isScrolling=!1,this.targetScroll=this.animatedScroll=this.actualScroll,this.animate=new i,this.emitter=n(),this.options.wrapper.addEventListener(\"scroll\",this.onScroll,{passive:!1}),this.virtualScroll=new r(u,{touchMultiplier:M,wheelMultiplier:E,normalizeWheel:L}),this.virtualScroll.on(\"scroll\",this.onVirtualScroll)}destroy(){this.emitter.events={},this.options.wrapper.removeEventListener(\"scroll\",this.onScroll,{passive:!1}),this.virtualScroll.destroy()}on(t,e){return this.emitter.on(t,e)}off(t,e){var i;this.emitter.events[t]=null==(i=this.emitter.events[t])?void 0:i.filter(t=>e!==t)}setScroll(t){this.isHorizontal?this.rootElement.scrollLeft=t:this.rootElement.scrollTop=t}emit(){this.emitter.emit(\"scroll\",this)}reset(){this.isLocked=!1,this.isScrolling=!1,this.velocity=0,this.animate.stop()}start(){this.isStopped=!1,this.reset()}stop(){this.isStopped=!0,this.animate.stop(),this.reset()}raf(t){const e=t-(this.time||t);this.time=t,this.animate.advance(.001*e)}scrollTo(t,{offset:i=0,immediate:s=!1,lock:o=!1,duration:n=this.options.duration,easing:r=this.options.easing,lerp:l=!n&&this.options.lerp,onComplete:h=null,force:a=!1,programmatic:c=!0}={}){if(!this.isStopped||a){if([\"top\",\"left\",\"start\"].includes(t))t=0;else if([\"bottom\",\"right\",\"end\"].includes(t))t=this.limit;else{var u;let e;if(\"string\"==typeof t?e=document.querySelector(t):null!=(u=t)&&u.nodeType&&(e=t),e){if(this.options.wrapper!==window){const t=this.options.wrapper.getBoundingClientRect();i-=this.isHorizontal?t.left:t.top}const s=e.getBoundingClientRect();t=(this.isHorizontal?s.left:s.top)+this.animatedScroll}}if(\"number\"==typeof t){if(t+=i,t=Math.round(t),this.options.infinite?c&&(this.targetScroll=this.animatedScroll=this.scroll):t=e(0,t,this.limit),s)return this.animatedScroll=this.targetScroll=t,this.setScroll(this.scroll),this.reset(),this.emit(),void(null==h||h());if(!c){if(t===this.targetScroll)return;this.targetScroll=t}this.animate.fromTo(this.animatedScroll,t,{duration:n,easing:r,lerp:l,onUpdate:(t,{completed:e})=>{o&&(this.isLocked=!0),this.isScrolling=!0,this.velocity=t-this.animatedScroll,this.direction=Math.sign(this.velocity),this.animatedScroll=t,this.setScroll(this.scroll),c&&(this.targetScroll=t),e&&(o&&(this.isLocked=!1),requestAnimationFrame(()=>{this.isScrolling=!1}),this.velocity=0,null==h||h()),this.emit()}})}}}get rootElement(){return this.options.wrapper===window?this.options.content:this.options.wrapper}get limit(){return this.isHorizontal?this.dimensions.limit.x:this.dimensions.limit.y}get isHorizontal(){return\"horizontal\"===this.options.orientation}get actualScroll(){return this.isHorizontal?this.rootElement.scrollLeft:this.rootElement.scrollTop}get scroll(){return this.options.infinite?function(t,e){let i=t%e;return(e>0&&i<0||e<0&&i>0)&&(i+=e),i}(this.animatedScroll,this.limit):this.animatedScroll}get progress(){return 0===this.limit?1:this.scroll/this.limit}get isSmooth(){return this.__isSmooth}set isSmooth(t){this.__isSmooth!==t&&(this.rootElement.classList.toggle(\"lenis-smooth\",t),this.__isSmooth=t)}get isScrolling(){return this.__isScrolling}set isScrolling(t){this.__isScrolling!==t&&(this.rootElement.classList.toggle(\"lenis-scrolling\",t),this.__isScrolling=t)}get isStopped(){return this.__isStopped}set isStopped(t){this.__isStopped!==t&&(this.rootElement.classList.toggle(\"lenis-stopped\",t),this.__isStopped=t)}}\n//# sourceMappingURL=lenis.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BzdHVkaW8tZnJlaWdodC9sZW5pcy9kaXN0L2xlbmlzLm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGFBQWEsd0RBQXdELFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHlCQUF5QixrQkFBa0IsaUNBQWlDLFFBQVEsV0FBVyxNQUFNLDBCQUEwQixTQUFTLDJIQUEySCxLQUFLLG9CQUFvQiw4Q0FBOEMsT0FBTywyQkFBMkIsMkNBQTJDLE1BQU0saURBQWlELFlBQVksaUJBQWlCLE9BQU8sa0JBQWtCLFlBQVksa0RBQWtELEVBQUUsaUlBQWlJLGdCQUFnQixNQUFNLGtCQUFrQix1QkFBdUIsd0NBQXdDLGFBQWEsS0FBSyxRQUFRLGlCQUFpQix5QkFBeUIsNERBQTRELDJCQUEyQiwwRUFBMEUsMkJBQTJCLG9FQUFvRSxnRUFBZ0UsOGFBQThhLFVBQVUsUUFBUSxzS0FBc0ssWUFBWSxPQUFPLGdFQUFnRSxZQUFZLFNBQVMsY0FBYyx5QkFBeUIsdUJBQXVCLElBQUksZUFBZSxTQUFTLE1BQU0sNkVBQTZFLE1BQU0sb0VBQW9FLEVBQUUsUUFBUSxlQUFlLDREQUE0RCxFQUFFLHNCQUFzQixNQUFNLG9CQUFvQixzQ0FBc0Msd0RBQXdELFNBQVMsc0JBQXNCLE1BQU0sb0JBQW9CLGtJQUFrSSx3REFBd0QsUUFBUSw2QkFBNkIsdUNBQXVDLEVBQUUscUJBQXFCLDRCQUE0QixnRkFBZ0YsRUFBRSxrQkFBa0IsSUFBSSxrQkFBa0IsR0FBRyxtSUFBbUksdUNBQXVDLEVBQUUscUdBQXFHLGNBQWMsc0VBQXNFLFdBQVcsZ0VBQWdFLFdBQVcsOERBQThELFdBQVcsNERBQTRELFdBQVcsRUFBRSxRQUFRLDRCQUE0QixVQUFVLHNCQUFzQix3REFBd0QsV0FBVyxtRUFBbUUsV0FBVyxpRUFBaUUsV0FBVywrREFBK0QsV0FBVyxHQUFHLFFBQVEsYUFBYSxtZUFBbWUsR0FBRyxFQUFFLHVCQUF1QiwyQ0FBMkMsSUFBSSxvQkFBb0Isa0NBQWtDLHFOQUFxTiw4R0FBOEcsZ0VBQWdFLHVLQUF1SyxtQkFBbUIsUUFBUSw2SEFBNkgsd0RBQXdELDhGQUE4RixnQkFBZ0IsS0FBSyw2QkFBNkIsR0FBRyxvQkFBb0Isc0JBQXNCLDRCQUE0QixxSUFBcUkscWRBQXFkLHVQQUF1UCx1U0FBdVMsV0FBVyw4QkFBOEIscURBQXFELHVEQUF1RCxVQUFVLHNCQUFzQixrRUFBa0UsV0FBVywrQkFBK0IsUUFBUSw0QkFBNEIsU0FBUyxNQUFNLGtGQUFrRixhQUFhLDZFQUE2RSxPQUFPLGlDQUFpQyxRQUFRLHlFQUF5RSxRQUFRLCtCQUErQixPQUFPLG1EQUFtRCxPQUFPLHlCQUF5Qix5Q0FBeUMsWUFBWSw4S0FBOEssR0FBRyxFQUFFLHVCQUF1QiwwQ0FBMEMsMERBQTBELEtBQUssTUFBTSxNQUFNLG9GQUFvRixrQ0FBa0MscURBQXFELGtDQUFrQyxrQ0FBa0Msd0RBQXdELHVCQUF1QixrUEFBa1AsT0FBTyxnQ0FBZ0Msb0JBQW9CLDJDQUEyQyx3Q0FBd0MsWUFBWSxJQUFJLHNQQUFzUCxvQkFBb0IsNkNBQTZDLElBQUksa0JBQWtCLCtFQUErRSxZQUFZLHlFQUF5RSxtQkFBbUIsOENBQThDLG1CQUFtQixnRkFBZ0YsYUFBYSwyQ0FBMkMsVUFBVSxxQ0FBcUMscURBQXFELGVBQWUsK0NBQStDLGVBQWUsdUJBQXVCLGdCQUFnQiw2RkFBNkYsa0JBQWtCLDBCQUEwQixtQkFBbUIsc0dBQXNHLGdCQUFnQix3QkFBd0IsaUJBQWlCLGlHQUFzSDtBQUNyeVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdHVkaW8tZnJlaWdodC9sZW5pcy9kaXN0L2xlbmlzLm1vZGVybi5tanM/NTRlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB0KCl7cmV0dXJuIHQ9T2JqZWN0LmFzc2lnbj9PYmplY3QuYXNzaWduLmJpbmQoKTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaT1hcmd1bWVudHNbZV07Zm9yKHZhciBzIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGkscykmJih0W3NdPWlbc10pfXJldHVybiB0fSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBlKHQsZSxpKXtyZXR1cm4gTWF0aC5tYXgodCxNYXRoLm1pbihlLGkpKX1jbGFzcyBpe2FkdmFuY2UodCl7dmFyIGk7aWYoIXRoaXMuaXNSdW5uaW5nKXJldHVybjtsZXQgcz0hMTtpZih0aGlzLmxlcnApdGhpcy52YWx1ZT0oMS0obz10aGlzLmxlcnApKSp0aGlzLnZhbHVlK28qdGhpcy50byxNYXRoLnJvdW5kKHRoaXMudmFsdWUpPT09dGhpcy50byYmKHRoaXMudmFsdWU9dGhpcy50byxzPSEwKTtlbHNle3RoaXMuY3VycmVudFRpbWUrPXQ7Y29uc3QgaT1lKDAsdGhpcy5jdXJyZW50VGltZS90aGlzLmR1cmF0aW9uLDEpO3M9aT49MTtjb25zdCBvPXM/MTp0aGlzLmVhc2luZyhpKTt0aGlzLnZhbHVlPXRoaXMuZnJvbSsodGhpcy50by10aGlzLmZyb20pKm99dmFyIG87bnVsbD09KGk9dGhpcy5vblVwZGF0ZSl8fGkuY2FsbCh0aGlzLHRoaXMudmFsdWUse2NvbXBsZXRlZDpzfSkscyYmdGhpcy5zdG9wKCl9c3RvcCgpe3RoaXMuaXNSdW5uaW5nPSExfWZyb21Ubyh0LGUse2xlcnA6aT0uMSxkdXJhdGlvbjpzPTEsZWFzaW5nOm89KHQ9PnQpLG9uVXBkYXRlOm59KXt0aGlzLmZyb209dGhpcy52YWx1ZT10LHRoaXMudG89ZSx0aGlzLmxlcnA9aSx0aGlzLmR1cmF0aW9uPXMsdGhpcy5lYXNpbmc9byx0aGlzLmN1cnJlbnRUaW1lPTAsdGhpcy5pc1J1bm5pbmc9ITAsdGhpcy5vblVwZGF0ZT1ufX1mdW5jdGlvbiBzKHQsZSl7bGV0IGk7cmV0dXJuIGZ1bmN0aW9uKCl7bGV0IHM9YXJndW1lbnRzLG89dGhpcztjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5hcHBseShvLHMpfSxlKX19Y2xhc3Mgb3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMub25XaW5kb3dSZXNpemU9KCk9Pnt0aGlzLndpZHRoPXdpbmRvdy5pbm5lcldpZHRoLHRoaXMuaGVpZ2h0PXdpbmRvdy5pbm5lckhlaWdodH0sdGhpcy5vbldyYXBwZXJSZXNpemU9KCk9Pnt0aGlzLndpZHRoPXRoaXMud3JhcHBlci5jbGllbnRXaWR0aCx0aGlzLmhlaWdodD10aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0fSx0aGlzLm9uQ29udGVudFJlc2l6ZT0oKT0+e2NvbnN0IHQ9dGhpcy53cmFwcGVyPT09d2luZG93P2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDp0aGlzLndyYXBwZXI7dGhpcy5zY3JvbGxIZWlnaHQ9dC5zY3JvbGxIZWlnaHQsdGhpcy5zY3JvbGxXaWR0aD10LnNjcm9sbFdpZHRofSx0aGlzLndyYXBwZXI9dCx0aGlzLmNvbnRlbnQ9ZSx0aGlzLndyYXBwZXI9PT13aW5kb3c/KHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5vbldpbmRvd1Jlc2l6ZSwhMSksdGhpcy5vbldpbmRvd1Jlc2l6ZSgpKToodGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXI9bmV3IFJlc2l6ZU9ic2VydmVyKHModGhpcy5vbldyYXBwZXJSZXNpemUsMTAwKSksdGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLndyYXBwZXIpLHRoaXMub25XcmFwcGVyUmVzaXplKCkpLHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyPW5ldyBSZXNpemVPYnNlcnZlcihzKHRoaXMub25Db250ZW50UmVzaXplLDEwMCkpLHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jb250ZW50KSx0aGlzLm9uQ29udGVudFJlc2l6ZSgpfWRlc3Ryb3koKXt2YXIgdCxlO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5vbldpbmRvd1Jlc2l6ZSwhMSksbnVsbD09KHQ9dGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXIpfHx0LmRpc2Nvbm5lY3QoKSxudWxsPT0oZT10aGlzLmNvbnRlbnRSZXNpemVPYnNlcnZlcil8fGUuZGlzY29ubmVjdCgpfWdldCBsaW1pdCgpe3JldHVybnt4OnRoaXMuc2Nyb2xsV2lkdGgtdGhpcy53aWR0aCx5OnRoaXMuc2Nyb2xsSGVpZ2h0LXRoaXMuaGVpZ2h0fX19bGV0IG49KCk9Pih7ZXZlbnRzOnt9LGVtaXQodCwuLi5lKXtsZXQgaT10aGlzLmV2ZW50c1t0XXx8W107Zm9yKGxldCB0PTAscz1pLmxlbmd0aDt0PHM7dCsrKWlbdF0oLi4uZSl9LG9uKHQsZSl7dmFyIGk7cmV0dXJuKG51bGw9PShpPXRoaXMuZXZlbnRzW3RdKT92b2lkIDA6aS5wdXNoKGUpKXx8KHRoaXMuZXZlbnRzW3RdPVtlXSksKCk9Pnt2YXIgaTt0aGlzLmV2ZW50c1t0XT1udWxsPT0oaT10aGlzLmV2ZW50c1t0XSk/dm9pZCAwOmkuZmlsdGVyKHQ9PmUhPT10KX19fSk7Y2xhc3Mgcntjb25zdHJ1Y3Rvcih0LHt3aGVlbE11bHRpcGxpZXI6aT0xLHRvdWNoTXVsdGlwbGllcjpzPTIsbm9ybWFsaXplV2hlZWw6bz0hMX0pe3RoaXMub25Ub3VjaFN0YXJ0PXQ9Pntjb25zdHtjbGllbnRYOmUsY2xpZW50WTppfT10LnRhcmdldFRvdWNoZXM/dC50YXJnZXRUb3VjaGVzWzBdOnQ7dGhpcy50b3VjaFN0YXJ0Lng9ZSx0aGlzLnRvdWNoU3RhcnQueT1pLHRoaXMubGFzdERlbHRhPXt4OjAseTowfX0sdGhpcy5vblRvdWNoTW92ZT10PT57Y29uc3R7Y2xpZW50WDplLGNsaWVudFk6aX09dC50YXJnZXRUb3VjaGVzP3QudGFyZ2V0VG91Y2hlc1swXTp0LHM9LShlLXRoaXMudG91Y2hTdGFydC54KSp0aGlzLnRvdWNoTXVsdGlwbGllcixvPS0oaS10aGlzLnRvdWNoU3RhcnQueSkqdGhpcy50b3VjaE11bHRpcGxpZXI7dGhpcy50b3VjaFN0YXJ0Lng9ZSx0aGlzLnRvdWNoU3RhcnQueT1pLHRoaXMubGFzdERlbHRhPXt4OnMseTpvfSx0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHt0eXBlOlwidG91Y2hcIixkZWx0YVg6cyxkZWx0YVk6byxldmVudDp0fSl9LHRoaXMub25Ub3VjaEVuZD10PT57dGhpcy5lbWl0dGVyLmVtaXQoXCJzY3JvbGxcIix7dHlwZTpcInRvdWNoXCIsaW5lcnRpYTohMCxkZWx0YVg6dGhpcy5sYXN0RGVsdGEueCxkZWx0YVk6dGhpcy5sYXN0RGVsdGEueSxldmVudDp0fSl9LHRoaXMub25XaGVlbD10PT57bGV0e2RlbHRhWDppLGRlbHRhWTpzfT10O3RoaXMubm9ybWFsaXplV2hlZWwmJihpPWUoLTEwMCxpLDEwMCkscz1lKC0xMDAscywxMDApKSxpKj10aGlzLndoZWVsTXVsdGlwbGllcixzKj10aGlzLndoZWVsTXVsdGlwbGllcix0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHt0eXBlOlwid2hlZWxcIixkZWx0YVg6aSxkZWx0YVk6cyxldmVudDp0fSl9LHRoaXMuZWxlbWVudD10LHRoaXMud2hlZWxNdWx0aXBsaWVyPWksdGhpcy50b3VjaE11bHRpcGxpZXI9cyx0aGlzLm5vcm1hbGl6ZVdoZWVsPW8sdGhpcy50b3VjaFN0YXJ0PXt4Om51bGwseTpudWxsfSx0aGlzLmVtaXR0ZXI9bigpLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIix0aGlzLm9uV2hlZWwse3Bhc3NpdmU6ITF9KSx0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLm9uVG91Y2hTdGFydCx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5vblRvdWNoTW92ZSx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm9uVG91Y2hFbmQse3Bhc3NpdmU6ITF9KX1vbih0LGUpe3JldHVybiB0aGlzLmVtaXR0ZXIub24odCxlKX1kZXN0cm95KCl7dGhpcy5lbWl0dGVyLmV2ZW50cz17fSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsdGhpcy5vbldoZWVsLHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5vblRvdWNoU3RhcnQse3Bhc3NpdmU6ITF9KSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMub25Ub3VjaE1vdmUse3Bhc3NpdmU6ITF9KSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5vblRvdWNoRW5kLHtwYXNzaXZlOiExfSl9fWNsYXNzIGx7Y29uc3RydWN0b3Ioe2RpcmVjdGlvbjplLGdlc3R1cmVEaXJlY3Rpb246cyxtb3VzZU11bHRpcGxpZXI6bCxzbW9vdGg6aCx3cmFwcGVyOmE9d2luZG93LGNvbnRlbnQ6Yz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsd2hlZWxFdmVudHNUYXJnZXQ6dT1hLHNtb290aFdoZWVsOnA9bnVsbD09aHx8aCxzbW9vdGhUb3VjaDpkPSExLHN5bmNUb3VjaDptPSExLHN5bmNUb3VjaExlcnA6dj0uMSx0b3VjaEluZXJ0aWFNdWx0aXBsaWVyOmc9MzUsZHVyYXRpb246UyxlYXNpbmc6dz0odD0+TWF0aC5taW4oMSwxLjAwMS1NYXRoLnBvdygyLC0xMCp0KSkpLGxlcnA6Zj0oUz9udWxsOi4xKSxpbmZpbml0ZTp5PSExLG9yaWVudGF0aW9uOlQ9KG51bGwhPWU/ZTpcInZlcnRpY2FsXCIpLGdlc3R1cmVPcmllbnRhdGlvbjp6PShudWxsIT1zP3M6XCJ2ZXJ0aWNhbFwiKSx0b3VjaE11bHRpcGxpZXI6TT0xLHdoZWVsTXVsdGlwbGllcjpFPShudWxsIT1sP2w6MSksbm9ybWFsaXplV2hlZWw6TD0hMX09e30pe3RoaXMub25WaXJ0dWFsU2Nyb2xsPSh7dHlwZTplLGluZXJ0aWE6aSxkZWx0YVg6cyxkZWx0YVk6byxldmVudDpufSk9PntpZihuLmN0cmxLZXkpcmV0dXJuO2NvbnN0IHI9XCJ0b3VjaFwiPT09ZSxsPVwid2hlZWxcIj09PWU7aWYoXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmMD09PW98fFwiaG9yaXpvbnRhbFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmMD09PXN8fHImJlwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24mJjA9PT10aGlzLnNjcm9sbCYmIXRoaXMub3B0aW9ucy5pbmZpbml0ZSYmbzw9MClyZXR1cm47aWYobi5jb21wb3NlZFBhdGgoKS5maW5kKHQ9Pm51bGw9PXR8fG51bGw9PXQuaGFzQXR0cmlidXRlP3ZvaWQgMDp0Lmhhc0F0dHJpYnV0ZShcImRhdGEtbGVuaXMtcHJldmVudFwiKSkpcmV0dXJuO2lmKHRoaXMuaXNTdG9wcGVkfHx0aGlzLmlzTG9ja2VkKXJldHVybiB2b2lkIG4ucHJldmVudERlZmF1bHQoKTtpZih0aGlzLmlzU21vb3RoPSh0aGlzLm9wdGlvbnMuc21vb3RoVG91Y2h8fHRoaXMub3B0aW9ucy5zeW5jVG91Y2gpJiZyfHx0aGlzLm9wdGlvbnMuc21vb3RoV2hlZWwmJmwsIXRoaXMuaXNTbW9vdGgpcmV0dXJuIHRoaXMuaXNTY3JvbGxpbmc9ITEsdm9pZCB0aGlzLmFuaW1hdGUuc3RvcCgpO24ucHJldmVudERlZmF1bHQoKTtsZXQgaD1vO1wiYm90aFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbj9oPU1hdGguYWJzKG8pPk1hdGguYWJzKHMpP286czpcImhvcml6b250YWxcIj09PXRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24mJihoPXMpO2NvbnN0IGE9ciYmdGhpcy5vcHRpb25zLnN5bmNUb3VjaCxjPXImJmkmJk1hdGguYWJzKGgpPjE7YyYmKGg9dGhpcy52ZWxvY2l0eSp0aGlzLm9wdGlvbnMudG91Y2hJbmVydGlhTXVsdGlwbGllciksdGhpcy5zY3JvbGxUbyh0aGlzLnRhcmdldFNjcm9sbCtoLHQoe3Byb2dyYW1tYXRpYzohMX0sYSYme2xlcnA6Yz90aGlzLnN5bmNUb3VjaExlcnA6LjR9KSl9LHRoaXMub25TY3JvbGw9KCk9PntpZighdGhpcy5pc1Njcm9sbGluZyl7Y29uc3QgdD10aGlzLmFuaW1hdGVkU2Nyb2xsO3RoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy50YXJnZXRTY3JvbGw9dGhpcy5hY3R1YWxTY3JvbGwsdGhpcy52ZWxvY2l0eT0wLHRoaXMuZGlyZWN0aW9uPU1hdGguc2lnbih0aGlzLmFuaW1hdGVkU2Nyb2xsLXQpLHRoaXMuZW1pdCgpfX0sZSYmY29uc29sZS53YXJuKFwiTGVuaXM6IGBkaXJlY3Rpb25gIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgYG9yaWVudGF0aW9uYCBpbnN0ZWFkXCIpLHMmJmNvbnNvbGUud2FybihcIkxlbmlzOiBgZ2VzdHVyZURpcmVjdGlvbmAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHVzZSBgZ2VzdHVyZU9yaWVudGF0aW9uYCBpbnN0ZWFkXCIpLGwmJmNvbnNvbGUud2FybihcIkxlbmlzOiBgbW91c2VNdWx0aXBsaWVyYCBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIGB3aGVlbE11bHRpcGxpZXJgIGluc3RlYWRcIiksaCYmY29uc29sZS53YXJuKFwiTGVuaXM6IGBzbW9vdGhgIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgYHNtb290aFdoZWVsYCBpbnN0ZWFkXCIpLHdpbmRvdy5sZW5pc1ZlcnNpb249XCIxLjAuMTFcIixhIT09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZhIT09ZG9jdW1lbnQuYm9keXx8KGE9d2luZG93KSx0aGlzLm9wdGlvbnM9e3dyYXBwZXI6YSxjb250ZW50OmMsd2hlZWxFdmVudHNUYXJnZXQ6dSxzbW9vdGhXaGVlbDpwLHNtb290aFRvdWNoOmQsc3luY1RvdWNoOm0sc3luY1RvdWNoTGVycDp2LHRvdWNoSW5lcnRpYU11bHRpcGxpZXI6ZyxkdXJhdGlvbjpTLGVhc2luZzp3LGxlcnA6ZixpbmZpbml0ZTp5LGdlc3R1cmVPcmllbnRhdGlvbjp6LG9yaWVudGF0aW9uOlQsdG91Y2hNdWx0aXBsaWVyOk0sd2hlZWxNdWx0aXBsaWVyOkUsbm9ybWFsaXplV2hlZWw6TH0sdGhpcy5kaW1lbnNpb25zPW5ldyBvKGEsYyksdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibGVuaXNcIiksdGhpcy52ZWxvY2l0eT0wLHRoaXMuaXNTdG9wcGVkPSExLHRoaXMuaXNTbW9vdGg9cHx8ZCx0aGlzLmlzU2Nyb2xsaW5nPSExLHRoaXMudGFyZ2V0U2Nyb2xsPXRoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy5hY3R1YWxTY3JvbGwsdGhpcy5hbmltYXRlPW5ldyBpLHRoaXMuZW1pdHRlcj1uKCksdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMub25TY3JvbGwse3Bhc3NpdmU6ITF9KSx0aGlzLnZpcnR1YWxTY3JvbGw9bmV3IHIodSx7dG91Y2hNdWx0aXBsaWVyOk0sd2hlZWxNdWx0aXBsaWVyOkUsbm9ybWFsaXplV2hlZWw6TH0pLHRoaXMudmlydHVhbFNjcm9sbC5vbihcInNjcm9sbFwiLHRoaXMub25WaXJ0dWFsU2Nyb2xsKX1kZXN0cm95KCl7dGhpcy5lbWl0dGVyLmV2ZW50cz17fSx0aGlzLm9wdGlvbnMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbCx7cGFzc2l2ZTohMX0pLHRoaXMudmlydHVhbFNjcm9sbC5kZXN0cm95KCl9b24odCxlKXtyZXR1cm4gdGhpcy5lbWl0dGVyLm9uKHQsZSl9b2ZmKHQsZSl7dmFyIGk7dGhpcy5lbWl0dGVyLmV2ZW50c1t0XT1udWxsPT0oaT10aGlzLmVtaXR0ZXIuZXZlbnRzW3RdKT92b2lkIDA6aS5maWx0ZXIodD0+ZSE9PXQpfXNldFNjcm9sbCh0KXt0aGlzLmlzSG9yaXpvbnRhbD90aGlzLnJvb3RFbGVtZW50LnNjcm9sbExlZnQ9dDp0aGlzLnJvb3RFbGVtZW50LnNjcm9sbFRvcD10fWVtaXQoKXt0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHRoaXMpfXJlc2V0KCl7dGhpcy5pc0xvY2tlZD0hMSx0aGlzLmlzU2Nyb2xsaW5nPSExLHRoaXMudmVsb2NpdHk9MCx0aGlzLmFuaW1hdGUuc3RvcCgpfXN0YXJ0KCl7dGhpcy5pc1N0b3BwZWQ9ITEsdGhpcy5yZXNldCgpfXN0b3AoKXt0aGlzLmlzU3RvcHBlZD0hMCx0aGlzLmFuaW1hdGUuc3RvcCgpLHRoaXMucmVzZXQoKX1yYWYodCl7Y29uc3QgZT10LSh0aGlzLnRpbWV8fHQpO3RoaXMudGltZT10LHRoaXMuYW5pbWF0ZS5hZHZhbmNlKC4wMDEqZSl9c2Nyb2xsVG8odCx7b2Zmc2V0Omk9MCxpbW1lZGlhdGU6cz0hMSxsb2NrOm89ITEsZHVyYXRpb246bj10aGlzLm9wdGlvbnMuZHVyYXRpb24sZWFzaW5nOnI9dGhpcy5vcHRpb25zLmVhc2luZyxsZXJwOmw9IW4mJnRoaXMub3B0aW9ucy5sZXJwLG9uQ29tcGxldGU6aD1udWxsLGZvcmNlOmE9ITEscHJvZ3JhbW1hdGljOmM9ITB9PXt9KXtpZighdGhpcy5pc1N0b3BwZWR8fGEpe2lmKFtcInRvcFwiLFwibGVmdFwiLFwic3RhcnRcIl0uaW5jbHVkZXModCkpdD0wO2Vsc2UgaWYoW1wiYm90dG9tXCIsXCJyaWdodFwiLFwiZW5kXCJdLmluY2x1ZGVzKHQpKXQ9dGhpcy5saW1pdDtlbHNle3ZhciB1O2xldCBlO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0P2U9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KTpudWxsIT0odT10KSYmdS5ub2RlVHlwZSYmKGU9dCksZSl7aWYodGhpcy5vcHRpb25zLndyYXBwZXIhPT13aW5kb3cpe2NvbnN0IHQ9dGhpcy5vcHRpb25zLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aS09dGhpcy5pc0hvcml6b250YWw/dC5sZWZ0OnQudG9wfWNvbnN0IHM9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0PSh0aGlzLmlzSG9yaXpvbnRhbD9zLmxlZnQ6cy50b3ApK3RoaXMuYW5pbWF0ZWRTY3JvbGx9fWlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZih0Kz1pLHQ9TWF0aC5yb3VuZCh0KSx0aGlzLm9wdGlvbnMuaW5maW5pdGU/YyYmKHRoaXMudGFyZ2V0U2Nyb2xsPXRoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy5zY3JvbGwpOnQ9ZSgwLHQsdGhpcy5saW1pdCkscylyZXR1cm4gdGhpcy5hbmltYXRlZFNjcm9sbD10aGlzLnRhcmdldFNjcm9sbD10LHRoaXMuc2V0U2Nyb2xsKHRoaXMuc2Nyb2xsKSx0aGlzLnJlc2V0KCksdGhpcy5lbWl0KCksdm9pZChudWxsPT1ofHxoKCkpO2lmKCFjKXtpZih0PT09dGhpcy50YXJnZXRTY3JvbGwpcmV0dXJuO3RoaXMudGFyZ2V0U2Nyb2xsPXR9dGhpcy5hbmltYXRlLmZyb21Ubyh0aGlzLmFuaW1hdGVkU2Nyb2xsLHQse2R1cmF0aW9uOm4sZWFzaW5nOnIsbGVycDpsLG9uVXBkYXRlOih0LHtjb21wbGV0ZWQ6ZX0pPT57byYmKHRoaXMuaXNMb2NrZWQ9ITApLHRoaXMuaXNTY3JvbGxpbmc9ITAsdGhpcy52ZWxvY2l0eT10LXRoaXMuYW5pbWF0ZWRTY3JvbGwsdGhpcy5kaXJlY3Rpb249TWF0aC5zaWduKHRoaXMudmVsb2NpdHkpLHRoaXMuYW5pbWF0ZWRTY3JvbGw9dCx0aGlzLnNldFNjcm9sbCh0aGlzLnNjcm9sbCksYyYmKHRoaXMudGFyZ2V0U2Nyb2xsPXQpLGUmJihvJiYodGhpcy5pc0xvY2tlZD0hMSkscmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dGhpcy5pc1Njcm9sbGluZz0hMX0pLHRoaXMudmVsb2NpdHk9MCxudWxsPT1ofHxoKCkpLHRoaXMuZW1pdCgpfX0pfX19Z2V0IHJvb3RFbGVtZW50KCl7cmV0dXJuIHRoaXMub3B0aW9ucy53cmFwcGVyPT09d2luZG93P3RoaXMub3B0aW9ucy5jb250ZW50OnRoaXMub3B0aW9ucy53cmFwcGVyfWdldCBsaW1pdCgpe3JldHVybiB0aGlzLmlzSG9yaXpvbnRhbD90aGlzLmRpbWVuc2lvbnMubGltaXQueDp0aGlzLmRpbWVuc2lvbnMubGltaXQueX1nZXQgaXNIb3Jpem9udGFsKCl7cmV0dXJuXCJob3Jpem9udGFsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb259Z2V0IGFjdHVhbFNjcm9sbCgpe3JldHVybiB0aGlzLmlzSG9yaXpvbnRhbD90aGlzLnJvb3RFbGVtZW50LnNjcm9sbExlZnQ6dGhpcy5yb290RWxlbWVudC5zY3JvbGxUb3B9Z2V0IHNjcm9sbCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaW5maW5pdGU/ZnVuY3Rpb24odCxlKXtsZXQgaT10JWU7cmV0dXJuKGU+MCYmaTwwfHxlPDAmJmk+MCkmJihpKz1lKSxpfSh0aGlzLmFuaW1hdGVkU2Nyb2xsLHRoaXMubGltaXQpOnRoaXMuYW5pbWF0ZWRTY3JvbGx9Z2V0IHByb2dyZXNzKCl7cmV0dXJuIDA9PT10aGlzLmxpbWl0PzE6dGhpcy5zY3JvbGwvdGhpcy5saW1pdH1nZXQgaXNTbW9vdGgoKXtyZXR1cm4gdGhpcy5fX2lzU21vb3RofXNldCBpc1Ntb290aCh0KXt0aGlzLl9faXNTbW9vdGghPT10JiYodGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwibGVuaXMtc21vb3RoXCIsdCksdGhpcy5fX2lzU21vb3RoPXQpfWdldCBpc1Njcm9sbGluZygpe3JldHVybiB0aGlzLl9faXNTY3JvbGxpbmd9c2V0IGlzU2Nyb2xsaW5nKHQpe3RoaXMuX19pc1Njcm9sbGluZyE9PXQmJih0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJsZW5pcy1zY3JvbGxpbmdcIix0KSx0aGlzLl9faXNTY3JvbGxpbmc9dCl9Z2V0IGlzU3RvcHBlZCgpe3JldHVybiB0aGlzLl9faXNTdG9wcGVkfXNldCBpc1N0b3BwZWQodCl7dGhpcy5fX2lzU3RvcHBlZCE9PXQmJih0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJsZW5pcy1zdG9wcGVkXCIsdCksdGhpcy5fX2lzU3RvcHBlZD10KX19ZXhwb3J0e2wgYXMgZGVmYXVsdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZW5pcy5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs\n"));

/***/ }),

/***/ "(app-client)/./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ LocomotiveScroll; }\n/* harmony export */ });\n/* harmony import */ var _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @studio-freight/lenis */ \"(app-client)/./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs\");\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\r\n * Intersection Observer\r\n *\r\n * Detecting visibility of an element in the viewport.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger inview/outOfView callbacks\r\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\r\n */\nclass IO {\n  constructor({\n    scrollElements,\n    rootMargin = '-1px -1px -1px -1px',\n    IORaf\n  }) {\n    this.scrollElements = void 0;\n    this.rootMargin = void 0;\n    this.IORaf = void 0;\n    this.observer = void 0;\n    // Parameters\n    this.scrollElements = scrollElements;\n    this.rootMargin = rootMargin;\n    this.IORaf = IORaf;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize Intersection Observer.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    // Options\n    const observerOptions = {\n      rootMargin: this.rootMargin\n    };\n    // Callback\n    const onIntersect = entries => {\n      entries.forEach(entry => {\n        const $targetItem = this.scrollElements.find(item => item.$el === entry.target);\n        if (entry.isIntersecting) {\n          $targetItem && ($targetItem.isAlreadyIntersected = true);\n          this._setInview(entry);\n        } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n          this._setOutOfView(entry);\n        }\n      });\n    };\n    // Instance\n    this.observer = new IntersectionObserver(onIntersect, observerOptions);\n    // Observe each default elements\n    for (const scrollElement of this.scrollElements) {\n      const $scrollElement = scrollElement.$el;\n      this.observe($scrollElement);\n    }\n  }\n  /**\r\n   * Lifecyle - Destroy Intersection Observer.\r\n   */\n  destroy() {\n    this.observer.disconnect();\n  }\n  /**\r\n   * Subscribe element to the Intersection Observer.\r\n   *\r\n   * @param {HTMLElement} $scrollElement - DOM Element to observe.\r\n   */\n  observe($scrollElement) {\n    if (!$scrollElement) {\n      return;\n    }\n    this.observer.observe($scrollElement);\n  }\n  /**\r\n   * Unsubscribe element to the Intersection Observer.\r\n   *\r\n   * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\r\n   */\n  unobserve($scrollElement) {\n    if (!$scrollElement) {\n      return;\n    }\n    this.observer.unobserve($scrollElement);\n  }\n  /**\r\n   * Find ScrollElementReference instance and trigger inview callbacks.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n   */\n  _setInview(entry) {\n    const scrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === entry.target);\n    this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInteractivityOn());\n    !this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInview());\n  }\n  /**\r\n   * Find ScrollElementReference instance and trigger out of view callbacks.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n   */\n  _setOutOfView(entry) {\n    const scrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === entry.target);\n    this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInteractivityOff());\n    !this.IORaf && (scrollElement == null ? void 0 : scrollElement.setOutOfView());\n    // Unobserve if element doesn't have repeat attribute\n    if (!(scrollElement != null && scrollElement.attributes.scrollRepeat) && !this.IORaf) {\n      this.unobserve(entry.target);\n    }\n  }\n}\n\n// https://greensock.com/docs/v3/GSAP/gsap.utils\n/**\r\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\r\n *\r\n * @param {number} min   - Minimum value expected.\r\n * @param {number} max   - Maximum value expected.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - Clamped value.\r\n */\nfunction clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n}\n/**\r\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\r\n *\r\n * @param {number} inMin  - Current minimum value.\r\n * @param {number} inMax  - Current maximum value.\r\n * @param {number} outMin - Maximum value expected.\r\n * @param {number} outMax - Maximum value expected.\r\n * @param {number} value  - Current value.\r\n *\r\n * @returns {number} - New value that should be between minimum value expected and maximum value.\r\n */\nfunction mapRange(inMin, inMax, outMin, outMax, value) {\n  const inRange = inMax - inMin;\n  const outRange = outMax - outMin;\n  return outMin + ((value - inMin) / inRange * outRange || 0);\n}\n/**\r\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\r\n *\r\n * @param {number} min   - Current minimum value.\r\n * @param {number} max   - Current maximum value.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - New value that should be between 0 and 1.\r\n */\nfunction normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n}\n/**\r\n * Get closest number from an array.\r\n *\r\n * @param {number[]} array  - Numbers array.\r\n * @param {number}   target - Reference value.\r\n *\r\n * @returns {number} - Closest number.\r\n */\nfunction closestNumber(array, target) {\n  return array.reduce((prev, curr) => {\n    return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n  });\n}\n\n/**\r\n * Scroll Element\r\n *\r\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\r\n *\r\n * Features functions to:\r\n *\r\n * - scrollClass - Add a custom class when the element is intersected by the offset\r\n * - scrollOffset - Determine offsets to intersect the element\r\n * - scrollPosition - Determine the element positions to consider an element as intersected.\r\n * - scrollModuleProgress - Send scroll progress to modular module that have a specific method (PROGRESS_MODULAR_METHOD)\r\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\r\n * - scrollEventProgress - Send scroll progress to custom event listeners.\r\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\r\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\r\n * - scrollCall - Call a custom event or a modular callback when the element is intersected\r\n */\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\nconst PROGRESS_MODULAR_METHOD = 'onScrollProgress';\nclass ScrollElement {\n  constructor({\n    $el,\n    id,\n    modularInstance,\n    subscribeElementUpdateFn,\n    unsubscribeElementUpdateFn,\n    needRaf,\n    scrollOrientation\n  }) {\n    var _this$$el$dataset$scr, _this$$el$dataset$scr2, _this$$el$dataset$scr3, _this$$el$dataset$scr4, _this$$el$dataset$scr5;\n    this.$el = void 0;\n    this.id = void 0;\n    this.needRaf = void 0;\n    this.attributes = void 0;\n    this.scrollOrientation = void 0;\n    this.isAlreadyIntersected = void 0;\n    this.intersection = void 0;\n    this.metrics = void 0;\n    this.currentScroll = void 0;\n    this.translateValue = void 0;\n    this.progress = void 0;\n    this.lastProgress = void 0;\n    this.modularInstance = void 0;\n    this.progressModularModules = void 0;\n    this.isInview = void 0;\n    this.isInteractive = void 0;\n    this.isInFold = void 0;\n    this.isFirstResize = void 0;\n    this.subscribeElementUpdateFn = void 0;\n    this.unsubscribeElementUpdateFn = void 0;\n    // Scroll DOM element\n    this.$el = $el;\n    // Unique ID\n    this.id = id;\n    // RAF option\n    this.needRaf = needRaf;\n    // Scroll Direction\n    this.scrollOrientation = scrollOrientation;\n    // Modular.js\n    this.modularInstance = modularInstance;\n    // Parent's callbacks\n    this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n    this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n    // Attributes\n    this.attributes = {\n      scrollClass: (_this$$el$dataset$scr = this.$el.dataset['scrollClass']) != null ? _this$$el$dataset$scr : INVIEW_CLASS,\n      scrollOffset: (_this$$el$dataset$scr2 = this.$el.dataset['scrollOffset']) != null ? _this$$el$dataset$scr2 : '0,0',\n      scrollPosition: (_this$$el$dataset$scr3 = this.$el.dataset['scrollPosition']) != null ? _this$$el$dataset$scr3 : 'start,end',\n      scrollModuleProgress: this.$el.dataset['scrollModuleProgress'] != null,\n      scrollCssProgress: this.$el.dataset['scrollCssProgress'] != null,\n      scrollEventProgress: (_this$$el$dataset$scr4 = this.$el.dataset['scrollEventProgress']) != null ? _this$$el$dataset$scr4 : null,\n      scrollSpeed: this.$el.dataset['scrollSpeed'] != null ? parseFloat(this.$el.dataset['scrollSpeed']) : null,\n      scrollRepeat: this.$el.dataset['scrollRepeat'] != null,\n      scrollCall: (_this$$el$dataset$scr5 = this.$el.dataset['scrollCall']) != null ? _this$$el$dataset$scr5 : null,\n      scrollCallSelf: this.$el.dataset['scrollCallSelf'] != null,\n      scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] != null,\n      scrollEnableTouchSpeed: this.$el.dataset['scrollEnableTouchSpeed'] != null\n    };\n    // Limits\n    this.intersection = {\n      start: 0,\n      end: 0\n    };\n    // Metrics\n    this.metrics = {\n      offsetStart: 0,\n      offsetEnd: 0,\n      bcr: {}\n    };\n    // Scroll Values\n    this.currentScroll = this.scrollOrientation === 'vertical' ? window.scrollY : window.scrollX;\n    // Parallax\n    this.translateValue = 0;\n    // Progress\n    this.progress = 0;\n    this.lastProgress = null;\n    this.progressModularModules = [];\n    // Inview\n    this.isInview = false;\n    this.isInteractive = false;\n    this.isAlreadyIntersected = false;\n    this.isInFold = false;\n    this.isFirstResize = true;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize progress tracking.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    if (!this.needRaf) {\n      return;\n    }\n    // Prepare modules progress\n    if (this.modularInstance && this.attributes.scrollModuleProgress) {\n      this._getProgressModularModules();\n    }\n    // First resize to compute all values\n    this._resize();\n  }\n  /**\r\n   * Callback - Resize callback\r\n   */\n  onResize({\n    currentScroll\n  }) {\n    this.currentScroll = currentScroll;\n    this._resize();\n  }\n  /**\r\n   * Callback - RAF callback\r\n   */\n  onRender({\n    currentScroll,\n    smooth\n  }) {\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    this.currentScroll = currentScroll;\n    this._computeProgress();\n    // Parallax\n    if (this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed)) {\n      // if touch detected or smooth disabled\n      if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n        if (this.translateValue) {\n          this.$el.style.transform = `translate3d(0, 0, 0)`;\n        }\n        this.translateValue = 0;\n        // if mousewheel or smooth enabled\n      } else {\n        // Check fold condition\n        if (this.isInFold) {\n          const progress = Math.max(0, this.progress);\n          this.translateValue = progress * wSize * this.attributes.scrollSpeed * -1;\n        } else {\n          const progress = mapRange(0, 1, -1, 1, this.progress);\n          this.translateValue = progress * wSize * this.attributes.scrollSpeed * -1;\n        }\n        this.$el.style.transform = this.scrollOrientation === 'vertical' ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`;\n      }\n    }\n  }\n  /**\r\n   * Inview callback\r\n   */\n  setInview() {\n    if (this.isInview) {\n      return;\n    }\n    this.isInview = true;\n    this.$el.classList.add(this.attributes.scrollClass);\n    const way = 'enter';\n    const from = this._getScrollCallFrom();\n    this.attributes.scrollCall && this._dispatchCall(way, from);\n  }\n  /**\r\n   * Out of view callback\r\n   */\n  setOutOfView() {\n    if (!(this.isInview && this.attributes.scrollRepeat)) {\n      return;\n    }\n    this.isInview = false;\n    this.$el.classList.remove(this.attributes.scrollClass);\n    const way = 'leave';\n    const from = this._getScrollCallFrom();\n    this.attributes.scrollCall && this._dispatchCall(way, from);\n  }\n  /**\r\n   * Switch interactivity on to subscribe the instance to the RAF\r\n   * and start calculations.\r\n   */\n  setInteractivityOn() {\n    if (this.isInteractive) {\n      return;\n    }\n    this.isInteractive = true;\n    this.subscribeElementUpdateFn(this);\n  }\n  /**\r\n   * Switch interactivity off to unsubscribe the instance to the RAF\r\n   * and stop calculations.\r\n   */\n  setInteractivityOff() {\n    if (!this.isInteractive) {\n      return;\n    }\n    this.isInteractive = false;\n    this.unsubscribeElementUpdateFn(this);\n    // Force progress to progress limit when the element is out\n    this.lastProgress != null && this._computeProgress(closestNumber([0, 1], this.lastProgress));\n  }\n  /**\r\n   * Resize method that compute the element's values.\r\n   *\r\n   * @private\r\n   */\n  _resize() {\n    this.metrics.bcr = this.$el.getBoundingClientRect();\n    this._computeMetrics();\n    this._computeIntersection();\n    // First resize logic\n    if (this.isFirstResize) {\n      this.isFirstResize = false;\n      // Dispatch default call if the element is in fold.\n      if (this.isInFold) {\n        this.setInview();\n      }\n    }\n  }\n  /**\r\n   * Compute element's offsets and determine if the element is in fold.\r\n   *\r\n   * @private\r\n   */\n  _computeMetrics() {\n    const {\n      top,\n      left,\n      height,\n      width\n    } = this.metrics.bcr;\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    const metricsStart = this.scrollOrientation === 'vertical' ? top : left;\n    const metricsSize = this.scrollOrientation === 'vertical' ? height : width;\n    this.metrics.offsetStart = this.currentScroll + metricsStart - this.translateValue;\n    this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n    if (this.metrics.offsetStart < wSize && !this.attributes.scrollIgnoreFold) {\n      this.isInFold = true;\n    } else {\n      this.isInFold = false;\n    }\n  }\n  /**\r\n   * Compute intersection values depending on the context.\r\n   *\r\n   * @private\r\n   */\n  _computeIntersection() {\n    // Window size\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    // Metrics size\n    const metricsSize = this.scrollOrientation === 'vertical' ? this.metrics.bcr.height : this.metrics.bcr.width;\n    // Offset\n    const offset = this.attributes.scrollOffset.split(',');\n    const offsetStart = offset[0] != undefined ? offset[0].trim() : '0';\n    const offsetEnd = offset[1] != undefined ? offset[1].trim() : '0';\n    // Positions\n    const scrollPosition = this.attributes.scrollPosition.split(',');\n    let scrollPositionStart = scrollPosition[0] != undefined ? scrollPosition[0].trim() : 'start';\n    const scrollPositionEnd = scrollPosition[1] != undefined ? scrollPosition[1].trim() : 'end';\n    // Viewport\n    const viewportStart = offsetStart.includes('%') ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01 : parseInt(offsetStart);\n    const viewportEnd = offsetEnd.includes('%') ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01 : parseInt(offsetEnd);\n    // Fold exception\n    if (this.isInFold) {\n      scrollPositionStart = 'fold';\n    }\n    // Define Intersection Start\n    switch (scrollPositionStart) {\n      case 'start':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart;\n        break;\n      case 'middle':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart + metricsSize * 0.5;\n        break;\n      case 'end':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart + metricsSize;\n        break;\n      case 'fold':\n        this.intersection.start = 0;\n        break;\n      default:\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart;\n        break;\n    }\n    // Define Intersection End\n    switch (scrollPositionEnd) {\n      case 'start':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd;\n        break;\n      case 'middle':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize * 0.5;\n        break;\n      case 'end':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize;\n        break;\n      default:\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize;\n        break;\n    }\n    // Avoid to have the end < the start intersection >\n    if (this.intersection.end <= this.intersection.start) {\n      switch (scrollPositionEnd) {\n        case 'start':\n          this.intersection.end = this.intersection.start + 1;\n          break;\n        case 'middle':\n          this.intersection.end = this.intersection.start + metricsSize * 0.5;\n          break;\n        case 'end':\n          this.intersection.end = this.intersection.start + metricsSize;\n          break;\n        default:\n          this.intersection.end = this.intersection.start + 1;\n          break;\n      }\n    }\n  }\n  /**\r\n   * Compute the scroll progress of the element depending\r\n   * on its intersection values.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [forcedProgress] - Value to force progress.\r\n   */\n  _computeProgress(forcedProgress) {\n    // Progress\n    const progress = forcedProgress != null ? forcedProgress : clamp(0, 1, normalize(this.intersection.start, this.intersection.end, this.currentScroll));\n    this.progress = progress;\n    if (progress != this.lastProgress) {\n      this.lastProgress = progress;\n      // Set the element's progress to the css variable\n      this.attributes.scrollCssProgress && this._setCssProgress(progress);\n      // Set the element's progress to the custom event listeners\n      this.attributes.scrollEventProgress && this._setCustomEventProgress(progress);\n      // Set the element's progress to inline modules\n      if (this.attributes.scrollModuleProgress) {\n        for (const modularModules of this.progressModularModules) {\n          this.modularInstance && this.modularInstance.call(PROGRESS_MODULAR_METHOD, progress, modularModules.moduleName, modularModules.moduleId);\n        }\n      }\n      // Logic to trigger the inview/out of view callbacks\n      progress > 0 && progress < 1 && this.setInview();\n      progress === 0 && this.setOutOfView();\n      progress === 1 && this.setOutOfView();\n    }\n  }\n  /**\r\n   * Set the element's progress to a specific css variable.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentProgress] - Progress value.\r\n   */\n  _setCssProgress(currentProgress = 0) {\n    this.$el.style.setProperty(PROGRESS_CSS_VAR, currentProgress.toString());\n  }\n  /**\r\n   * Set the element's progress to the custom event listeners.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentProgress] - Progress value.\r\n   */\n  _setCustomEventProgress(currentProgress = 0) {\n    const customEventName = this.attributes.scrollEventProgress;\n    if (!customEventName) return;\n    const customEvent = new CustomEvent(customEventName, {\n      detail: {\n        target: this.$el,\n        progress: currentProgress\n      }\n    });\n    window.dispatchEvent(customEvent);\n  }\n  /**\r\n   * Get modular modules that can listen the element's progress.\r\n   *\r\n   * @private\r\n   */\n  _getProgressModularModules() {\n    if (!this.modularInstance) {\n      return;\n    }\n    const modulesIdNames = Object.keys(this.$el.dataset).filter(key => key.includes('module'));\n    const modules = Object.entries(this.modularInstance.modules);\n    if (!modulesIdNames.length) {\n      return;\n    }\n    for (const modulesIdName of modulesIdNames) {\n      const moduleId = this.$el.dataset[modulesIdName];\n      if (!moduleId) {\n        return;\n      }\n      for (const module of modules) {\n        const [moduleName, moduleObj] = module;\n        if (moduleId in moduleObj) {\n          this.progressModularModules.push({\n            moduleName,\n            moduleId\n          });\n        }\n      }\n    }\n  }\n  /**\r\n   * Function to get scroll call from.\r\n   *\r\n   * @private\r\n   */\n  _getScrollCallFrom() {\n    const closestIntersectionValue = closestNumber([this.intersection.start, this.intersection.end], this.currentScroll);\n    return this.intersection.start === closestIntersectionValue ? 'start' : 'end';\n  }\n  /**\r\n   * Function to dispatch a custom event or call a modular callback.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {scrollCallWay} way - Enter or leave.\r\n   * @param {scrollCallFrom} from - Start or end.\r\n   */\n  _dispatchCall(way, from) {\n    var _this$attributes$scro, _this$attributes;\n    const callParameters = (_this$attributes$scro = this.attributes.scrollCall) == null ? void 0 : _this$attributes$scro.split(',');\n    const callSelf = (_this$attributes = this.attributes) == null ? void 0 : _this$attributes.scrollCallSelf;\n    if (callParameters && callParameters.length > 1) {\n      var _targetModuleId;\n      // Using Modular.js (https://github.com/modularorg/modularjs)\n      const [func, moduleName, moduleId] = callParameters;\n      let targetModuleId;\n      // If the module is set on the scroll element\n      if (callSelf) {\n        targetModuleId = this.$el.dataset[`module${moduleName.trim()}`];\n      } else {\n        targetModuleId = moduleId;\n      }\n      this.modularInstance && this.modularInstance.call(func.trim(), {\n        target: this.$el,\n        way,\n        from\n      }, moduleName.trim(), (_targetModuleId = targetModuleId) == null ? void 0 : _targetModuleId.trim());\n    } else if (callParameters) {\n      // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n      const [customEventName] = callParameters;\n      const customEvent = new CustomEvent(customEventName, {\n        detail: {\n          target: this.$el,\n          way,\n          from\n        }\n      });\n      window.dispatchEvent(customEvent);\n    }\n  }\n}\n\n/**\r\n * Integrates Lenis with Locomotive's built-in animation system\r\n */\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = ['scrollOffset', 'scrollPosition', 'scrollModuleProgress', 'scrollCssProgress', 'scrollEventProgress', 'scrollSpeed'];\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\nclass Core {\n  constructor({\n    $el,\n    modularInstance,\n    triggerRootMargin,\n    rafRootMargin,\n    scrollOrientation\n  }) {\n    this.$scrollContainer = void 0;\n    this.modularInstance = void 0;\n    this.triggerRootMargin = void 0;\n    this.rafRootMargin = void 0;\n    this.scrollElements = void 0;\n    this.triggeredScrollElements = void 0;\n    this.RAFScrollElements = void 0;\n    this.scrollElementsToUpdate = void 0;\n    this.IOTriggerInstance = void 0;\n    this.IORafInstance = void 0;\n    this.scrollOrientation = void 0;\n    if (!$el) {\n      console.error('Please provide a DOM Element as scrollContainer');\n      return;\n    }\n    // Scroll container\n    this.$scrollContainer = $el;\n    // Modular.js\n    this.modularInstance = modularInstance;\n    // Scroll Direction\n    this.scrollOrientation = scrollOrientation;\n    // IO Margins\n    this.triggerRootMargin = triggerRootMargin != null ? triggerRootMargin : TRIGGER_ROOT_MARGIN;\n    this.rafRootMargin = rafRootMargin != null ? rafRootMargin : RAF_ROOT_MARGIN;\n    // ScrollElements arrays\n    this.scrollElements = [];\n    this.triggeredScrollElements = [];\n    this.RAFScrollElements = [];\n    this.scrollElementsToUpdate = [];\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize the core.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    const $scrollElements = this.$scrollContainer.querySelectorAll('[data-scroll]');\n    const $scrollElementsArr = Array.from($scrollElements);\n    this._subscribeScrollElements($scrollElementsArr);\n    // Trigger IO\n    this.IOTriggerInstance = new IO({\n      scrollElements: [...this.triggeredScrollElements],\n      rootMargin: this.triggerRootMargin,\n      IORaf: false\n    });\n    // Raf IO\n    this.IORafInstance = new IO({\n      scrollElements: [...this.RAFScrollElements],\n      rootMargin: this.rafRootMargin,\n      IORaf: true\n    });\n  }\n  /**\r\n   * Lifecyle - Destroy core.\r\n   */\n  destroy() {\n    this.IOTriggerInstance.destroy();\n    this.IORafInstance.destroy();\n    this._unsubscribeAllScrollElements();\n  }\n  /**\r\n   * Callback - Resize callback.\r\n   */\n  onResize({\n    currentScroll\n  }) {\n    for (const scrollElement of this.RAFScrollElements) {\n      scrollElement.onResize({\n        currentScroll\n      });\n    }\n  }\n  /**\r\n   * Callback - RAF callback.\r\n   */\n  onRender({\n    currentScroll,\n    smooth\n  }) {\n    for (const scrollElement of this.scrollElementsToUpdate) {\n      scrollElement.onRender({\n        currentScroll,\n        smooth\n      });\n    }\n  }\n  /**\r\n   * Remove items from lists of scroll elements and compute all new values.\r\n   *\r\n   * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\r\n   */\n  removeScrollElements($oldContainer) {\n    const $scrollElementsToRemove = $oldContainer.querySelectorAll('[data-scroll]');\n    if (!$scrollElementsToRemove.length) return;\n    // 1. Remove from IO\n    for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n      const scrollElement = this.triggeredScrollElements[index];\n      const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove);\n      if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n        this.IOTriggerInstance.unobserve(scrollElement.$el);\n        this.triggeredScrollElements.splice(index, 1);\n      }\n    }\n    for (let index = 0; index < this.RAFScrollElements.length; index++) {\n      const scrollElement = this.RAFScrollElements[index];\n      const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove);\n      if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n        this.IORafInstance.unobserve(scrollElement.$el);\n        this.RAFScrollElements.splice(index, 1);\n      }\n    }\n    // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n    $scrollElementsToRemove.forEach($scrollElement => {\n      const targetScrollElementToUpdate = this.scrollElementsToUpdate.find(scrollElement => scrollElement.$el === $scrollElement);\n      const targetScrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === $scrollElement);\n      if (targetScrollElementToUpdate) {\n        this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n      }\n      if (targetScrollElement) {\n        this.scrollElements = this.scrollElements.filter(scrollElementItem => scrollElementItem.id != targetScrollElement.id);\n      }\n    });\n  }\n  /**\r\n   * Add items to lists of scroll elements and compute all new values.\r\n   *\r\n   * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\r\n   */\n  addScrollElements($newContainer) {\n    // 3. Rebuild ScrollElements\n    const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n    // 4. Get max scrollElement.id\n    const ids = [];\n    this.scrollElements.forEach(scrollElement => {\n      ids.push(scrollElement.id);\n    });\n    const maxID = Math.max(...ids);\n    const fromIndex = maxID + 1;\n    const $scrollElementsArr = Array.from($scrollElements);\n    this._subscribeScrollElements($scrollElementsArr, fromIndex, true);\n  }\n  /**\r\n   * Create a ScrollElement instance for each elements with\r\n   * `data-scroll` attribute.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {HTMLElement[]} $scrollElements - List of elements that need\r\n   *     to be regarded.\r\n   */\n  _subscribeScrollElements($scrollElements, fromIndex = 0, toObserve = false) {\n    // For each scroll element create a ScrollElement instance\n    for (let index = 0; index < $scrollElements.length; index++) {\n      const $scrollElement = $scrollElements[index];\n      const needRaf = this._checkRafNeeded($scrollElement);\n      const scrollElementInstance = new ScrollElement({\n        $el: $scrollElement,\n        id: fromIndex + index,\n        scrollOrientation: this.scrollOrientation,\n        modularInstance: this.modularInstance,\n        subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this),\n        unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this),\n        needRaf\n      });\n      // Push to common array\n      this.scrollElements.push(scrollElementInstance);\n      // Push to specific array\n      if (needRaf) {\n        this.RAFScrollElements.push(scrollElementInstance);\n        // Dynamic observe item\n        if (toObserve) {\n          this.IORafInstance.scrollElements.push(scrollElementInstance);\n          this.IORafInstance.observe(scrollElementInstance.$el);\n        }\n      } else {\n        this.triggeredScrollElements.push(scrollElementInstance);\n        // Dynamic observe item\n        if (toObserve) {\n          this.IOTriggerInstance.scrollElements.push(scrollElementInstance);\n          this.IOTriggerInstance.observe(scrollElementInstance.$el);\n        }\n      }\n    }\n  }\n  /**\r\n   * Clear all ScrollElement arrays.\r\n   *\r\n   * @private\r\n   */\n  _unsubscribeAllScrollElements() {\n    this.scrollElements = [];\n    this.RAFScrollElements = [];\n    this.triggeredScrollElements = [];\n    this.scrollElementsToUpdate = [];\n  }\n  /**\r\n   * Subscribe ScrollElement instance that needs to be updated.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {ScrollElement} scrollElement - ScrollElement instance inview\r\n   *     that needs to be updated.\r\n   */\n  _subscribeElementUpdate(scrollElement) {\n    this.scrollElementsToUpdate.push(scrollElement);\n  }\n  /**\r\n   * Unscribe ScrollElement instance that doesn't need to be updated.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {ScrollElement} scrollElement - The updated ScrollElement instance\r\n   *     out of view now.\r\n   */\n  _unsubscribeElementUpdate(scrollElement) {\n    this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(scrollElementToUpdate => scrollElementToUpdate.id != scrollElement.id);\n  }\n  /**\r\n   * Check if a DOM Element need a requestAnimationFrame to be used.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {HTMLElement} $scrollElement - The element that needs to be checked.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  _checkRafNeeded($scrollElement) {\n    let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n    // Remove utils\n    const removeAttribute = attributeToRemove => {\n      attributesThatNeedRaf = attributesThatNeedRaf.filter(attribute => attribute != attributeToRemove);\n    };\n    // 1. Check scroll offset values\n    if ($scrollElement.dataset.scrollOffset) {\n      const value = $scrollElement.dataset.scrollOffset.split(',').map(test => test.replace('%', '').trim()).join(',');\n      if (value != '0,0') {\n        return true;\n      } else {\n        removeAttribute('scrollOffset');\n      }\n    } else {\n      removeAttribute('scrollOffset');\n    }\n    // 2. Check scroll position values\n    if ($scrollElement.dataset.scrollPosition) {\n      const value = $scrollElement.dataset.scrollPosition.trim();\n      if (value != 'top,bottom') {\n        return true;\n      } else {\n        removeAttribute('scrollPosition');\n      }\n    } else {\n      removeAttribute('scrollPosition');\n    }\n    // 3. Check scroll speed values\n    if ($scrollElement.dataset.scrollSpeed && !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))) {\n      return true;\n    } else {\n      removeAttribute('scrollSpeed');\n    }\n    // 4. Check others attributes\n    for (const attribute of attributesThatNeedRaf) {\n      if (attribute in $scrollElement.dataset) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\r\n * Resize Observer\r\n *\r\n * The Resize Observer API provides a performant mechanism by which code can monitor an element for changes to its size,\r\n * with notifications being delivered to the observer each time the size changes.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger the resize callback if the specified element's size change.\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Resize_Observer_API}\r\n */\nclass RO {\n  constructor({\n    resizeElements,\n    resizeCallback = () => {}\n  }) {\n    this.$resizeElements = void 0;\n    this.isFirstObserve = void 0;\n    this.observer = void 0;\n    this.resizeCallback = void 0;\n    // Parameters\n    this.$resizeElements = resizeElements;\n    this.resizeCallback = resizeCallback;\n    // Flags\n    this.isFirstObserve = true;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize Resize Observer.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    // Callback\n    const onResize = entries => {\n      var _this$resizeCallback;\n      !this.isFirstObserve && ((_this$resizeCallback = this.resizeCallback) == null ? void 0 : _this$resizeCallback.call(this));\n      this.isFirstObserve = false;\n    };\n    // Instance\n    this.observer = new ResizeObserver(onResize);\n    // Observe each default elements\n    for (const $resizeElement of this.$resizeElements) {\n      this.observer.observe($resizeElement);\n    }\n  }\n  /**\r\n   * Lifecyle - Destroy Resize Observer.\r\n   */\n  destroy() {\n    this.observer.disconnect();\n  }\n}\n\n/**\r\n * @type {ILenisOptions}\r\n */\nconst defaultLenisOptions = {\n  wrapper: window,\n  content: document.documentElement,\n  lerp: 0.1,\n  duration: 1.2,\n  orientation: 'vertical',\n  gestureOrientation: 'vertical',\n  smoothWheel: true,\n  smoothTouch: false,\n  wheelMultiplier: 1,\n  touchMultiplier: 2,\n  normalizeWheel: true,\n  easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)) // https://www.desmos.com/calculator/brs54l4xou\n};\n/**\r\n * Locomotive Scroll\r\n *\r\n * Detection of elements in viewport & smooth scrolling with parallax.\r\n *\r\n * Inspired by\r\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\r\n * and built around\r\n * {@link https://github.com/studio-freight/lenis lenis.js}.\r\n */\nclass LocomotiveScroll {\n  constructor({\n    lenisOptions = {},\n    modularInstance,\n    triggerRootMargin,\n    rafRootMargin,\n    autoResize = true,\n    autoStart = true,\n    scrollCallback = () => {},\n    initCustomTicker,\n    destroyCustomTicker\n  } = {}) {\n    this.rafPlaying = void 0;\n    this.lenisInstance = void 0;\n    this.coreInstance = void 0;\n    this.lenisOptions = void 0;\n    this.modularInstance = void 0;\n    this.triggerRootMargin = void 0;\n    this.rafRootMargin = void 0;\n    this.rafInstance = void 0;\n    this.autoResize = void 0;\n    this.autoStart = void 0;\n    this.ROInstance = void 0;\n    this.initCustomTicker = void 0;\n    this.destroyCustomTicker = void 0;\n    this._onRenderBind = void 0;\n    this._onResizeBind = void 0;\n    this._onScrollToBind = void 0;\n    // Arguments\n    this.lenisOptions = _extends({}, defaultLenisOptions, lenisOptions);\n    Object.assign(this, {\n      lenisOptions,\n      modularInstance,\n      triggerRootMargin,\n      rafRootMargin,\n      autoResize,\n      autoStart,\n      scrollCallback,\n      initCustomTicker,\n      destroyCustomTicker\n    });\n    // Binding\n    this._onRenderBind = this._onRender.bind(this);\n    this._onScrollToBind = this._onScrollTo.bind(this);\n    this._onResizeBind = this._onResize.bind(this);\n    // Data\n    this.rafPlaying = false;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize instance.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    var _this$lenisInstance;\n    // Create Lenis instance\n    this.lenisInstance = new _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      wrapper: this.lenisOptions.wrapper,\n      content: this.lenisOptions.content,\n      lerp: this.lenisOptions.lerp,\n      duration: this.lenisOptions.duration,\n      orientation: this.lenisOptions.orientation,\n      gestureOrientation: this.lenisOptions.gestureOrientation,\n      smoothWheel: this.lenisOptions.smoothWheel,\n      smoothTouch: this.lenisOptions.smoothTouch,\n      wheelMultiplier: this.lenisOptions.wheelMultiplier,\n      touchMultiplier: this.lenisOptions.touchMultiplier,\n      normalizeWheel: this.lenisOptions.normalizeWheel,\n      easing: this.lenisOptions.easing\n    });\n    (_this$lenisInstance = this.lenisInstance) == null ? void 0 : _this$lenisInstance.on('scroll', this.scrollCallback);\n    // Add scroll direction attribute on body\n    document.documentElement.setAttribute('data-scroll-orientation', this.lenisInstance.options.orientation);\n    requestAnimationFrame(() => {\n      // Create Core Instance\n      this.coreInstance = new Core({\n        $el: this.lenisInstance.rootElement,\n        modularInstance: this.modularInstance,\n        triggerRootMargin: this.triggerRootMargin,\n        rafRootMargin: this.rafRootMargin,\n        scrollOrientation: this.lenisInstance.options.orientation\n      });\n      // Bind Events\n      this._bindEvents();\n      // RAF warning\n      if (this.initCustomTicker && !this.destroyCustomTicker) {\n        console.warn('initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.');\n      } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n        console.warn('destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.');\n      }\n      // Start RAF\n      this.autoStart && this.start();\n    });\n  }\n  /**\r\n   * Lifecyle - Destroy instance.\r\n   */\n  destroy() {\n    // Stop raf\n    this.stop();\n    // Unbind Events\n    this._unbindEvents();\n    // Destroy Lenis\n    this.lenisInstance.destroy();\n    // Destroy Core\n    this.coreInstance.destroy();\n  }\n  /**\r\n   * Events - Subscribe events to listen.\r\n   */\n  _bindEvents() {\n    this._bindScrollToEvents();\n    if (this.autoResize) {\n      if ('ResizeObserver' in window) {\n        this.ROInstance = new RO({\n          resizeElements: [document.body],\n          resizeCallback: this._onResizeBind\n        });\n      } else {\n        window.addEventListener('resize', this._onResizeBind);\n      }\n    }\n  }\n  /**\r\n   * Events - Unsubscribe listened events.\r\n   */\n  _unbindEvents() {\n    this._unbindScrollToEvents();\n    if (this.autoResize) {\n      if ('ResizeObserver' in window) {\n        this.ROInstance && this.ROInstance.destroy();\n      } else {\n        window.removeEventListener('resize', this._onResizeBind);\n      }\n    }\n  }\n  /**\r\n   * Events - Subscribe scrollTo events to listen.\r\n   */\n  _bindScrollToEvents($container) {\n    const $rootContainer = $container ? $container : this.lenisInstance.rootElement;\n    const $scrollToElements = $rootContainer == null ? void 0 : $rootContainer.querySelectorAll('[data-scroll-to]');\n    ($scrollToElements == null ? void 0 : $scrollToElements.length) && $scrollToElements.forEach($el => {\n      $el.addEventListener('click', this._onScrollToBind, false);\n    });\n  }\n  /**\r\n   * Events - Unsubscribe scrollTo listened events.\r\n   */\n  _unbindScrollToEvents($container) {\n    const $rootContainer = $container ? $container : this.lenisInstance.rootElement;\n    const $scrollToElements = $rootContainer == null ? void 0 : $rootContainer.querySelectorAll('[data-scroll-to]');\n    ($scrollToElements == null ? void 0 : $scrollToElements.length) && $scrollToElements.forEach($el => {\n      $el.removeEventListener('click', this._onScrollToBind, false);\n    });\n  }\n  /**\r\n   * Callback - Resize callback.\r\n   */\n  _onResize() {\n    // Waiting the next frame to get the new current scroll value return by Lenis\n    requestAnimationFrame(() => {\n      var _this$coreInstance;\n      (_this$coreInstance = this.coreInstance) == null ? void 0 : _this$coreInstance.onResize({\n        currentScroll: this.lenisInstance.scroll\n      });\n    });\n  }\n  /**\r\n   * Callback - Render callback.\r\n   */\n  _onRender() {\n    var _this$lenisInstance2, _this$coreInstance2;\n    (_this$lenisInstance2 = this.lenisInstance) == null ? void 0 : _this$lenisInstance2.raf(Date.now());\n    (_this$coreInstance2 = this.coreInstance) == null ? void 0 : _this$coreInstance2.onRender({\n      currentScroll: this.lenisInstance.scroll,\n      smooth: this.lenisInstance.isSmooth\n    });\n  }\n  /**\r\n   * Callback - Scroll To callback.\r\n   */\n  _onScrollTo(event) {\n    var _event$currentTarget;\n    event.preventDefault();\n    const $target = (_event$currentTarget = event.currentTarget) != null ? _event$currentTarget : null;\n    if (!$target) return;\n    const target = $target.getAttribute('data-scroll-to-href') || $target.getAttribute('href');\n    const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n    const duration = $target.getAttribute('data-scroll-to-duration') || this.lenisOptions.duration || defaultLenisOptions.duration;\n    target && this.scrollTo(target, {\n      offset: typeof offset === 'string' ? parseInt(offset) : offset,\n      duration: typeof duration === 'string' ? parseInt(duration) : duration\n    });\n  }\n  /**\r\n   * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   */\n  start() {\n    if (this.rafPlaying) {\n      return;\n    }\n    this.rafPlaying = true;\n    this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf();\n  }\n  /**\r\n   * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   */\n  stop() {\n    if (!this.rafPlaying) {\n      return;\n    }\n    this.rafPlaying = false;\n    this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n  }\n  /**\r\n   * Remove old scroll elements items and rebuild ScrollElements instances.\r\n   */\n  removeScrollElements($oldContainer) {\n    var _this$coreInstance3;\n    if (!$oldContainer) {\n      console.error('Please provide a DOM Element as $oldContainer');\n      return;\n    }\n    this._unbindScrollToEvents($oldContainer);\n    (_this$coreInstance3 = this.coreInstance) == null ? void 0 : _this$coreInstance3.removeScrollElements($oldContainer);\n  }\n  /**\r\n   * Add new scroll elements items and rebuild ScrollElements instances.\r\n   */\n  addScrollElements($newContainer) {\n    var _this$coreInstance4;\n    if (!$newContainer) {\n      console.error('Please provide a DOM Element as $newContainer');\n      return;\n    }\n    (_this$coreInstance4 = this.coreInstance) == null ? void 0 : _this$coreInstance4.addScrollElements($newContainer);\n    requestAnimationFrame(() => {\n      this._bindScrollToEvents($newContainer);\n    });\n  }\n  /**\r\n   * Trigger resize callback.\r\n   */\n  resize() {\n    this._onResizeBind();\n  }\n  /**\r\n   * Trigger scroll to callback.\r\n   */\n  scrollTo(target, options) {\n    var _this$lenisInstance3;\n    (_this$lenisInstance3 = this.lenisInstance) == null ? void 0 : _this$lenisInstance3.scrollTo(target, {\n      offset: options == null ? void 0 : options.offset,\n      lerp: options == null ? void 0 : options.lerp,\n      duration: options == null ? void 0 : options.duration,\n      immediate: options == null ? void 0 : options.immediate,\n      lock: options == null ? void 0 : options.lock,\n      force: options == null ? void 0 : options.force,\n      easing: options == null ? void 0 : options.easing,\n      onComplete: options == null ? void 0 : options.onComplete\n    });\n  }\n  /**\r\n   * RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   *\r\n   * @private\r\n   *\r\n   */\n  _raf() {\n    this._onRenderBind();\n    this.rafInstance = requestAnimationFrame(() => this._raf());\n  }\n}\n\n\n//# sourceMappingURL=locomotive-scroll.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2xvY29tb3RpdmUtc2Nyb2xsL2Rpc3QvbG9jb21vdGl2ZS1zY3JvbGwubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFMUM7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixvQkFBb0IseUJBQXlCLG9CQUFvQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQTZDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJLHVEQUF1RDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9jb21vdGl2ZS1zY3JvbGwvZGlzdC9sb2NvbW90aXZlLXNjcm9sbC5tb2Rlcm4ubWpzP2Q1ODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExlbmlzIGZyb20gJ0BzdHVkaW8tZnJlaWdodC9sZW5pcyc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcclxuICogSW50ZXJzZWN0aW9uIE9ic2VydmVyXHJcbiAqXHJcbiAqIERldGVjdGluZyB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQgaW4gdGhlIHZpZXdwb3J0LlxyXG4gKlxyXG4gKiBGZWF0dXJlcyBmdW5jdGlvbnMgdG86XHJcbiAqXHJcbiAqIC0gVHJpZ2dlciBpbnZpZXcvb3V0T2ZWaWV3IGNhbGxiYWNrc1xyXG4gKiAtIElmIHRoZSBlbGVtZW50IGhhcyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSBkZXBlbmRlbmN5LCBzZXQgaW50ZXJhY3Rpdnkgc3RhdHVzIGZvciB0aGUgU2Nyb2xsRWxlbWVudCBDbGFzc1xyXG4gKlxyXG4gKiBSZWZlcmVuY2VzOlxyXG4gKlxyXG4gKiAtIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uX09ic2VydmVyX0FQSX1cclxuICovXG5jbGFzcyBJTyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzY3JvbGxFbGVtZW50cyxcbiAgICByb290TWFyZ2luID0gJy0xcHggLTFweCAtMXB4IC0xcHgnLFxuICAgIElPUmFmXG4gIH0pIHtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMucm9vdE1hcmdpbiA9IHZvaWQgMDtcbiAgICB0aGlzLklPUmFmID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMgPSBzY3JvbGxFbGVtZW50cztcbiAgICB0aGlzLnJvb3RNYXJnaW4gPSByb290TWFyZ2luO1xuICAgIHRoaXMuSU9SYWYgPSBJT1JhZjtcbiAgICAvLyBJbml0XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gSW5pdGlhbGl6ZSBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICAvLyBPcHRpb25zXG4gICAgY29uc3Qgb2JzZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbjogdGhpcy5yb290TWFyZ2luXG4gICAgfTtcbiAgICAvLyBDYWxsYmFja1xuICAgIGNvbnN0IG9uSW50ZXJzZWN0ID0gZW50cmllcyA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBjb25zdCAkdGFyZ2V0SXRlbSA9IHRoaXMuc2Nyb2xsRWxlbWVudHMuZmluZChpdGVtID0+IGl0ZW0uJGVsID09PSBlbnRyeS50YXJnZXQpO1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAkdGFyZ2V0SXRlbSAmJiAoJHRhcmdldEl0ZW0uaXNBbHJlYWR5SW50ZXJzZWN0ZWQgPSB0cnVlKTtcbiAgICAgICAgICB0aGlzLl9zZXRJbnZpZXcoZW50cnkpO1xuICAgICAgICB9IGVsc2UgaWYgKCR0YXJnZXRJdGVtICYmICR0YXJnZXRJdGVtLmlzQWxyZWFkeUludGVyc2VjdGVkKSB7XG4gICAgICAgICAgdGhpcy5fc2V0T3V0T2ZWaWV3KGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBJbnN0YW5jZVxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIob25JbnRlcnNlY3QsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgLy8gT2JzZXJ2ZSBlYWNoIGRlZmF1bHQgZWxlbWVudHNcbiAgICBmb3IgKGNvbnN0IHNjcm9sbEVsZW1lbnQgb2YgdGhpcy5zY3JvbGxFbGVtZW50cykge1xuICAgICAgY29uc3QgJHNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50LiRlbDtcbiAgICAgIHRoaXMub2JzZXJ2ZSgkc2Nyb2xsRWxlbWVudCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gRGVzdHJveSBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIuXHJcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3Vic2NyaWJlIGVsZW1lbnQgdG8gdGhlIEludGVyc2VjdGlvbiBPYnNlcnZlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRzY3JvbGxFbGVtZW50IC0gRE9NIEVsZW1lbnQgdG8gb2JzZXJ2ZS5cclxuICAgKi9cbiAgb2JzZXJ2ZSgkc2Nyb2xsRWxlbWVudCkge1xuICAgIGlmICghJHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKCRzY3JvbGxFbGVtZW50KTtcbiAgfVxuICAvKipcclxuICAgKiBVbnN1YnNjcmliZSBlbGVtZW50IHRvIHRoZSBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkc2Nyb2xsRWxlbWVudCAtIERPTSBFbGVtZW50IHRvIHVub2JzZXJ2ZS5cclxuICAgKi9cbiAgdW5vYnNlcnZlKCRzY3JvbGxFbGVtZW50KSB7XG4gICAgaWYgKCEkc2Nyb2xsRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZSgkc2Nyb2xsRWxlbWVudCk7XG4gIH1cbiAgLyoqXHJcbiAgICogRmluZCBTY3JvbGxFbGVtZW50UmVmZXJlbmNlIGluc3RhbmNlIGFuZCB0cmlnZ2VyIGludmlldyBjYWxsYmFja3MuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5fSBlbnRyeSAtIERPTSBFbGVtZW50IHRvIG9ic2VydmUuXHJcbiAgICovXG4gIF9zZXRJbnZpZXcoZW50cnkpIHtcbiAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gdGhpcy5zY3JvbGxFbGVtZW50cy5maW5kKHNjcm9sbEVsZW1lbnQgPT4gc2Nyb2xsRWxlbWVudC4kZWwgPT09IGVudHJ5LnRhcmdldCk7XG4gICAgdGhpcy5JT1JhZiAmJiAoc2Nyb2xsRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsRWxlbWVudC5zZXRJbnRlcmFjdGl2aXR5T24oKSk7XG4gICAgIXRoaXMuSU9SYWYgJiYgKHNjcm9sbEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbEVsZW1lbnQuc2V0SW52aWV3KCkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgU2Nyb2xsRWxlbWVudFJlZmVyZW5jZSBpbnN0YW5jZSBhbmQgdHJpZ2dlciBvdXQgb2YgdmlldyBjYWxsYmFja3MuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5fSBlbnRyeSAtIERPTSBFbGVtZW50IHRvIG9ic2VydmUuXHJcbiAgICovXG4gIF9zZXRPdXRPZlZpZXcoZW50cnkpIHtcbiAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gdGhpcy5zY3JvbGxFbGVtZW50cy5maW5kKHNjcm9sbEVsZW1lbnQgPT4gc2Nyb2xsRWxlbWVudC4kZWwgPT09IGVudHJ5LnRhcmdldCk7XG4gICAgdGhpcy5JT1JhZiAmJiAoc2Nyb2xsRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsRWxlbWVudC5zZXRJbnRlcmFjdGl2aXR5T2ZmKCkpO1xuICAgICF0aGlzLklPUmFmICYmIChzY3JvbGxFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxFbGVtZW50LnNldE91dE9mVmlldygpKTtcbiAgICAvLyBVbm9ic2VydmUgaWYgZWxlbWVudCBkb2Vzbid0IGhhdmUgcmVwZWF0IGF0dHJpYnV0ZVxuICAgIGlmICghKHNjcm9sbEVsZW1lbnQgIT0gbnVsbCAmJiBzY3JvbGxFbGVtZW50LmF0dHJpYnV0ZXMuc2Nyb2xsUmVwZWF0KSAmJiAhdGhpcy5JT1JhZikge1xuICAgICAgdGhpcy51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9ncmVlbnNvY2suY29tL2RvY3MvdjMvR1NBUC9nc2FwLnV0aWxzXG4vKipcclxuICogQ2xhbXAgYSB2YWx1ZSB0byBmaXQgd2l0aGluIGEgc3BlY2lmaWMgcmFuZ2UgKGV4OiBjbGFtcCgwLCAxMDAsIC0xMikgLS0+IDApLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWluICAgLSBNaW5pbXVtIHZhbHVlIGV4cGVjdGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4ICAgLSBNYXhpbXVtIHZhbHVlIGV4cGVjdGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBDdXJyZW50IHZhbHVlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIENsYW1wZWQgdmFsdWUuXHJcbiAqL1xuZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG59XG4vKipcclxuICogTWFwIG9uZSByYW5nZSB0byBhbm90aGVyIChleDogbWFwUmFuZ2UoLTEwLCAxMCwgMCwgMTAwLCA1KSAtLT4gNzUpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5NaW4gIC0gQ3VycmVudCBtaW5pbXVtIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5NYXggIC0gQ3VycmVudCBtYXhpbXVtIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0TWluIC0gTWF4aW11bSB2YWx1ZSBleHBlY3RlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IG91dE1heCAtIE1heGltdW0gdmFsdWUgZXhwZWN0ZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAgLSBDdXJyZW50IHZhbHVlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIE5ldyB2YWx1ZSB0aGF0IHNob3VsZCBiZSBiZXR3ZWVuIG1pbmltdW0gdmFsdWUgZXhwZWN0ZWQgYW5kIG1heGltdW0gdmFsdWUuXHJcbiAqL1xuZnVuY3Rpb24gbWFwUmFuZ2UoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCwgdmFsdWUpIHtcbiAgY29uc3QgaW5SYW5nZSA9IGluTWF4IC0gaW5NaW47XG4gIGNvbnN0IG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbn1cbi8qKlxyXG4gKiBNYXAgYSBudW1iZXIgd2l0aGluIGEgcmFuZ2UgdG8gYSBwcm9ncmVzcyBiZXR3ZWVuIDAgdG8gMSAoZXg6IG5vcm1hbGl6ZSgxMDAsIDIwMCwgMTUwKSAtLT4gMC41KS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiAgIC0gQ3VycmVudCBtaW5pbXVtIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4ICAgLSBDdXJyZW50IG1heGltdW0gdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIEN1cnJlbnQgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gTmV3IHZhbHVlIHRoYXQgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMS5cclxuICovXG5mdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufVxuLyoqXHJcbiAqIEdldCBjbG9zZXN0IG51bWJlciBmcm9tIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAgLSBOdW1iZXJzIGFycmF5LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gICB0YXJnZXQgLSBSZWZlcmVuY2UgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gQ2xvc2VzdCBudW1iZXIuXHJcbiAqL1xuZnVuY3Rpb24gY2xvc2VzdE51bWJlcihhcnJheSwgdGFyZ2V0KSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMoY3VyciAtIHRhcmdldCkgPCBNYXRoLmFicyhwcmV2IC0gdGFyZ2V0KSA/IGN1cnIgOiBwcmV2O1xuICB9KTtcbn1cblxuLyoqXHJcbiAqIFNjcm9sbCBFbGVtZW50XHJcbiAqXHJcbiAqIEdpdmUgdG9vbHMgdG8gY29tcHV0ZSBlbGVtZW50IHByb2dyZXNzIGluIHRoZSB2aWV3cG9ydCBhbmQgdHJpZ2dlcnMgY2FsbGJhY2tzIHRvIGFuaW1hdGUgaXQuXHJcbiAqXHJcbiAqIEZlYXR1cmVzIGZ1bmN0aW9ucyB0bzpcclxuICpcclxuICogLSBzY3JvbGxDbGFzcyAtIEFkZCBhIGN1c3RvbSBjbGFzcyB3aGVuIHRoZSBlbGVtZW50IGlzIGludGVyc2VjdGVkIGJ5IHRoZSBvZmZzZXRcclxuICogLSBzY3JvbGxPZmZzZXQgLSBEZXRlcm1pbmUgb2Zmc2V0cyB0byBpbnRlcnNlY3QgdGhlIGVsZW1lbnRcclxuICogLSBzY3JvbGxQb3NpdGlvbiAtIERldGVybWluZSB0aGUgZWxlbWVudCBwb3NpdGlvbnMgdG8gY29uc2lkZXIgYW4gZWxlbWVudCBhcyBpbnRlcnNlY3RlZC5cclxuICogLSBzY3JvbGxNb2R1bGVQcm9ncmVzcyAtIFNlbmQgc2Nyb2xsIHByb2dyZXNzIHRvIG1vZHVsYXIgbW9kdWxlIHRoYXQgaGF2ZSBhIHNwZWNpZmljIG1ldGhvZCAoUFJPR1JFU1NfTU9EVUxBUl9NRVRIT0QpXHJcbiAqIC0gc2Nyb2xsQ3NzUHJvZ3Jlc3MgLSBBZGQgYSBzcGVjaWZpYyBjc3MgdmFyaWFibGUgKFBST0dSRVNTX0NTU19WQVIpIHRoYXQgc3RvcmUgdGhlIHNjcm9sbCBwcm9ncmVzc1xyXG4gKiAtIHNjcm9sbEV2ZW50UHJvZ3Jlc3MgLSBTZW5kIHNjcm9sbCBwcm9ncmVzcyB0byBjdXN0b20gZXZlbnQgbGlzdGVuZXJzLlxyXG4gKiAtIHNjcm9sbFNwZWVkIC0gQWRkIGEgc2Nyb2xsIG11bHRpcGxpY2F0b3IgdG8gY3JlYXRlIGEgcGFyYWxsYXggZWZmZWN0XHJcbiAqIC0gc2Nyb2xsUmVwZWF0IC0gUmVwZWF0IHRoZSBvcHRpb24gdG8gdHJpZ2dlciBhbmltYXRpb24gZWFjaCB0aW1lIHRoZSBlbGVtZW50IGlzIGludGVyc2VjdGVkXHJcbiAqIC0gc2Nyb2xsQ2FsbCAtIENhbGwgYSBjdXN0b20gZXZlbnQgb3IgYSBtb2R1bGFyIGNhbGxiYWNrIHdoZW4gdGhlIGVsZW1lbnQgaXMgaW50ZXJzZWN0ZWRcclxuICovXG4vKiogQ29uc3RhbnRzICovXG5jb25zdCBJTlZJRVdfQ0xBU1MgPSAnaXMtaW52aWV3JztcbmNvbnN0IFBST0dSRVNTX0NTU19WQVIgPSAnLS1wcm9ncmVzcyc7XG5jb25zdCBQUk9HUkVTU19NT0RVTEFSX01FVEhPRCA9ICdvblNjcm9sbFByb2dyZXNzJztcbmNsYXNzIFNjcm9sbEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgJGVsLFxuICAgIGlkLFxuICAgIG1vZHVsYXJJbnN0YW5jZSxcbiAgICBzdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4sXG4gICAgdW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4sXG4gICAgbmVlZFJhZixcbiAgICBzY3JvbGxPcmllbnRhdGlvblxuICB9KSB7XG4gICAgdmFyIF90aGlzJCRlbCRkYXRhc2V0JHNjciwgX3RoaXMkJGVsJGRhdGFzZXQkc2NyMiwgX3RoaXMkJGVsJGRhdGFzZXQkc2NyMywgX3RoaXMkJGVsJGRhdGFzZXQkc2NyNCwgX3RoaXMkJGVsJGRhdGFzZXQkc2NyNTtcbiAgICB0aGlzLiRlbCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubmVlZFJhZiA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQWxyZWFkeUludGVyc2VjdGVkID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMubWV0cmljcyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRTY3JvbGwgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2xhdGVWYWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnByb2dyZXNzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFByb2dyZXNzID0gdm9pZCAwO1xuICAgIHRoaXMubW9kdWxhckluc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMucHJvZ3Jlc3NNb2R1bGFyTW9kdWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzSW52aWV3ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzSW5Gb2xkID0gdm9pZCAwO1xuICAgIHRoaXMuaXNGaXJzdFJlc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbiA9IHZvaWQgMDtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuID0gdm9pZCAwO1xuICAgIC8vIFNjcm9sbCBET00gZWxlbWVudFxuICAgIHRoaXMuJGVsID0gJGVsO1xuICAgIC8vIFVuaXF1ZSBJRFxuICAgIHRoaXMuaWQgPSBpZDtcbiAgICAvLyBSQUYgb3B0aW9uXG4gICAgdGhpcy5uZWVkUmFmID0gbmVlZFJhZjtcbiAgICAvLyBTY3JvbGwgRGlyZWN0aW9uXG4gICAgdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9IHNjcm9sbE9yaWVudGF0aW9uO1xuICAgIC8vIE1vZHVsYXIuanNcbiAgICB0aGlzLm1vZHVsYXJJbnN0YW5jZSA9IG1vZHVsYXJJbnN0YW5jZTtcbiAgICAvLyBQYXJlbnQncyBjYWxsYmFja3NcbiAgICB0aGlzLnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbiA9IHN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbjtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuID0gdW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm47XG4gICAgLy8gQXR0cmlidXRlc1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgIHNjcm9sbENsYXNzOiAoX3RoaXMkJGVsJGRhdGFzZXQkc2NyID0gdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsQ2xhc3MnXSkgIT0gbnVsbCA/IF90aGlzJCRlbCRkYXRhc2V0JHNjciA6IElOVklFV19DTEFTUyxcbiAgICAgIHNjcm9sbE9mZnNldDogKF90aGlzJCRlbCRkYXRhc2V0JHNjcjIgPSB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxPZmZzZXQnXSkgIT0gbnVsbCA/IF90aGlzJCRlbCRkYXRhc2V0JHNjcjIgOiAnMCwwJyxcbiAgICAgIHNjcm9sbFBvc2l0aW9uOiAoX3RoaXMkJGVsJGRhdGFzZXQkc2NyMyA9IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbFBvc2l0aW9uJ10pICE9IG51bGwgPyBfdGhpcyQkZWwkZGF0YXNldCRzY3IzIDogJ3N0YXJ0LGVuZCcsXG4gICAgICBzY3JvbGxNb2R1bGVQcm9ncmVzczogdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsTW9kdWxlUHJvZ3Jlc3MnXSAhPSBudWxsLFxuICAgICAgc2Nyb2xsQ3NzUHJvZ3Jlc3M6IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbENzc1Byb2dyZXNzJ10gIT0gbnVsbCxcbiAgICAgIHNjcm9sbEV2ZW50UHJvZ3Jlc3M6IChfdGhpcyQkZWwkZGF0YXNldCRzY3I0ID0gdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsRXZlbnRQcm9ncmVzcyddKSAhPSBudWxsID8gX3RoaXMkJGVsJGRhdGFzZXQkc2NyNCA6IG51bGwsXG4gICAgICBzY3JvbGxTcGVlZDogdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsU3BlZWQnXSAhPSBudWxsID8gcGFyc2VGbG9hdCh0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxTcGVlZCddKSA6IG51bGwsXG4gICAgICBzY3JvbGxSZXBlYXQ6IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbFJlcGVhdCddICE9IG51bGwsXG4gICAgICBzY3JvbGxDYWxsOiAoX3RoaXMkJGVsJGRhdGFzZXQkc2NyNSA9IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbENhbGwnXSkgIT0gbnVsbCA/IF90aGlzJCRlbCRkYXRhc2V0JHNjcjUgOiBudWxsLFxuICAgICAgc2Nyb2xsQ2FsbFNlbGY6IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbENhbGxTZWxmJ10gIT0gbnVsbCxcbiAgICAgIHNjcm9sbElnbm9yZUZvbGQ6IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbElnbm9yZUZvbGQnXSAhPSBudWxsLFxuICAgICAgc2Nyb2xsRW5hYmxlVG91Y2hTcGVlZDogdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsRW5hYmxlVG91Y2hTcGVlZCddICE9IG51bGxcbiAgICB9O1xuICAgIC8vIExpbWl0c1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICAgIC8vIE1ldHJpY3NcbiAgICB0aGlzLm1ldHJpY3MgPSB7XG4gICAgICBvZmZzZXRTdGFydDogMCxcbiAgICAgIG9mZnNldEVuZDogMCxcbiAgICAgIGJjcjoge31cbiAgICB9O1xuICAgIC8vIFNjcm9sbCBWYWx1ZXNcbiAgICB0aGlzLmN1cnJlbnRTY3JvbGwgPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gd2luZG93LnNjcm9sbFkgOiB3aW5kb3cuc2Nyb2xsWDtcbiAgICAvLyBQYXJhbGxheFxuICAgIHRoaXMudHJhbnNsYXRlVmFsdWUgPSAwO1xuICAgIC8vIFByb2dyZXNzXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMucHJvZ3Jlc3NNb2R1bGFyTW9kdWxlcyA9IFtdO1xuICAgIC8vIEludmlld1xuICAgIHRoaXMuaXNJbnZpZXcgPSBmYWxzZTtcbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmlzQWxyZWFkeUludGVyc2VjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5pc0luRm9sZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNGaXJzdFJlc2l6ZSA9IHRydWU7XG4gICAgLy8gSW5pdFxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIEluaXRpYWxpemUgcHJvZ3Jlc3MgdHJhY2tpbmcuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMubmVlZFJhZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBQcmVwYXJlIG1vZHVsZXMgcHJvZ3Jlc3NcbiAgICBpZiAodGhpcy5tb2R1bGFySW5zdGFuY2UgJiYgdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbE1vZHVsZVByb2dyZXNzKSB7XG4gICAgICB0aGlzLl9nZXRQcm9ncmVzc01vZHVsYXJNb2R1bGVzKCk7XG4gICAgfVxuICAgIC8vIEZpcnN0IHJlc2l6ZSB0byBjb21wdXRlIGFsbCB2YWx1ZXNcbiAgICB0aGlzLl9yZXNpemUoKTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayAtIFJlc2l6ZSBjYWxsYmFja1xyXG4gICAqL1xuICBvblJlc2l6ZSh7XG4gICAgY3VycmVudFNjcm9sbFxuICB9KSB7XG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsID0gY3VycmVudFNjcm9sbDtcbiAgICB0aGlzLl9yZXNpemUoKTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayAtIFJBRiBjYWxsYmFja1xyXG4gICAqL1xuICBvblJlbmRlcih7XG4gICAgY3VycmVudFNjcm9sbCxcbiAgICBzbW9vdGhcbiAgfSkge1xuICAgIGNvbnN0IHdTaXplID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMuY3VycmVudFNjcm9sbCA9IGN1cnJlbnRTY3JvbGw7XG4gICAgdGhpcy5fY29tcHV0ZVByb2dyZXNzKCk7XG4gICAgLy8gUGFyYWxsYXhcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLnNjcm9sbFNwZWVkICYmICFpc05hTih0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsU3BlZWQpKSB7XG4gICAgICAvLyBpZiB0b3VjaCBkZXRlY3RlZCBvciBzbW9vdGggZGlzYWJsZWRcbiAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbEVuYWJsZVRvdWNoU3BlZWQgJiYgIXNtb290aCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuJGVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2xhdGVWYWx1ZSA9IDA7XG4gICAgICAgIC8vIGlmIG1vdXNld2hlZWwgb3Igc21vb3RoIGVuYWJsZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGZvbGQgY29uZGl0aW9uXG4gICAgICAgIGlmICh0aGlzLmlzSW5Gb2xkKSB7XG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1heCgwLCB0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVZhbHVlID0gcHJvZ3Jlc3MgKiB3U2l6ZSAqIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxTcGVlZCAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gbWFwUmFuZ2UoMCwgMSwgLTEsIDEsIHRoaXMucHJvZ3Jlc3MpO1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRlVmFsdWUgPSBwcm9ncmVzcyAqIHdTaXplICogdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbFNwZWVkICogLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMudHJhbnNsYXRlVmFsdWV9cHgsIDApYCA6IGB0cmFuc2xhdGUzZCgke3RoaXMudHJhbnNsYXRlVmFsdWV9cHgsIDAsIDApYDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSW52aWV3IGNhbGxiYWNrXHJcbiAgICovXG4gIHNldEludmlldygpIHtcbiAgICBpZiAodGhpcy5pc0ludmlldykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzSW52aWV3ID0gdHJ1ZTtcbiAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKHRoaXMuYXR0cmlidXRlcy5zY3JvbGxDbGFzcyk7XG4gICAgY29uc3Qgd2F5ID0gJ2VudGVyJztcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZ2V0U2Nyb2xsQ2FsbEZyb20oKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsQ2FsbCAmJiB0aGlzLl9kaXNwYXRjaENhbGwod2F5LCBmcm9tKTtcbiAgfVxuICAvKipcclxuICAgKiBPdXQgb2YgdmlldyBjYWxsYmFja1xyXG4gICAqL1xuICBzZXRPdXRPZlZpZXcoKSB7XG4gICAgaWYgKCEodGhpcy5pc0ludmlldyAmJiB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsUmVwZWF0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzSW52aWV3ID0gZmFsc2U7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsQ2xhc3MpO1xuICAgIGNvbnN0IHdheSA9ICdsZWF2ZSc7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2dldFNjcm9sbENhbGxGcm9tKCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbENhbGwgJiYgdGhpcy5fZGlzcGF0Y2hDYWxsKHdheSwgZnJvbSk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3dpdGNoIGludGVyYWN0aXZpdHkgb24gdG8gc3Vic2NyaWJlIHRoZSBpbnN0YW5jZSB0byB0aGUgUkFGXHJcbiAgICogYW5kIHN0YXJ0IGNhbGN1bGF0aW9ucy5cclxuICAgKi9cbiAgc2V0SW50ZXJhY3Rpdml0eU9uKCkge1xuICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbih0aGlzKTtcbiAgfVxuICAvKipcclxuICAgKiBTd2l0Y2ggaW50ZXJhY3Rpdml0eSBvZmYgdG8gdW5zdWJzY3JpYmUgdGhlIGluc3RhbmNlIHRvIHRoZSBSQUZcclxuICAgKiBhbmQgc3RvcCBjYWxjdWxhdGlvbnMuXHJcbiAgICovXG4gIHNldEludGVyYWN0aXZpdHlPZmYoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW50ZXJhY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy51bnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbih0aGlzKTtcbiAgICAvLyBGb3JjZSBwcm9ncmVzcyB0byBwcm9ncmVzcyBsaW1pdCB3aGVuIHRoZSBlbGVtZW50IGlzIG91dFxuICAgIHRoaXMubGFzdFByb2dyZXNzICE9IG51bGwgJiYgdGhpcy5fY29tcHV0ZVByb2dyZXNzKGNsb3Nlc3ROdW1iZXIoWzAsIDFdLCB0aGlzLmxhc3RQcm9ncmVzcykpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2l6ZSBtZXRob2QgdGhhdCBjb21wdXRlIHRoZSBlbGVtZW50J3MgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX3Jlc2l6ZSgpIHtcbiAgICB0aGlzLm1ldHJpY3MuYmNyID0gdGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5fY29tcHV0ZU1ldHJpY3MoKTtcbiAgICB0aGlzLl9jb21wdXRlSW50ZXJzZWN0aW9uKCk7XG4gICAgLy8gRmlyc3QgcmVzaXplIGxvZ2ljXG4gICAgaWYgKHRoaXMuaXNGaXJzdFJlc2l6ZSkge1xuICAgICAgdGhpcy5pc0ZpcnN0UmVzaXplID0gZmFsc2U7XG4gICAgICAvLyBEaXNwYXRjaCBkZWZhdWx0IGNhbGwgaWYgdGhlIGVsZW1lbnQgaXMgaW4gZm9sZC5cbiAgICAgIGlmICh0aGlzLmlzSW5Gb2xkKSB7XG4gICAgICAgIHRoaXMuc2V0SW52aWV3KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbXB1dGUgZWxlbWVudCdzIG9mZnNldHMgYW5kIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyBpbiBmb2xkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2NvbXB1dGVNZXRyaWNzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSB0aGlzLm1ldHJpY3MuYmNyO1xuICAgIGNvbnN0IHdTaXplID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNvbnN0IG1ldHJpY3NTdGFydCA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB0b3AgOiBsZWZ0O1xuICAgIGNvbnN0IG1ldHJpY3NTaXplID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IGhlaWdodCA6IHdpZHRoO1xuICAgIHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCA9IHRoaXMuY3VycmVudFNjcm9sbCArIG1ldHJpY3NTdGFydCAtIHRoaXMudHJhbnNsYXRlVmFsdWU7XG4gICAgdGhpcy5tZXRyaWNzLm9mZnNldEVuZCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCArIG1ldHJpY3NTaXplO1xuICAgIGlmICh0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgPCB3U2l6ZSAmJiAhdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbElnbm9yZUZvbGQpIHtcbiAgICAgIHRoaXMuaXNJbkZvbGQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzSW5Gb2xkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbXB1dGUgaW50ZXJzZWN0aW9uIHZhbHVlcyBkZXBlbmRpbmcgb24gdGhlIGNvbnRleHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfY29tcHV0ZUludGVyc2VjdGlvbigpIHtcbiAgICAvLyBXaW5kb3cgc2l6ZVxuICAgIGNvbnN0IHdTaXplID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIC8vIE1ldHJpY3Mgc2l6ZVxuICAgIGNvbnN0IG1ldHJpY3NTaXplID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHRoaXMubWV0cmljcy5iY3IuaGVpZ2h0IDogdGhpcy5tZXRyaWNzLmJjci53aWR0aDtcbiAgICAvLyBPZmZzZXRcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsT2Zmc2V0LnNwbGl0KCcsJyk7XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSBvZmZzZXRbMF0gIT0gdW5kZWZpbmVkID8gb2Zmc2V0WzBdLnRyaW0oKSA6ICcwJztcbiAgICBjb25zdCBvZmZzZXRFbmQgPSBvZmZzZXRbMV0gIT0gdW5kZWZpbmVkID8gb2Zmc2V0WzFdLnRyaW0oKSA6ICcwJztcbiAgICAvLyBQb3NpdGlvbnNcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5zY3JvbGxQb3NpdGlvbi5zcGxpdCgnLCcpO1xuICAgIGxldCBzY3JvbGxQb3NpdGlvblN0YXJ0ID0gc2Nyb2xsUG9zaXRpb25bMF0gIT0gdW5kZWZpbmVkID8gc2Nyb2xsUG9zaXRpb25bMF0udHJpbSgpIDogJ3N0YXJ0JztcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbkVuZCA9IHNjcm9sbFBvc2l0aW9uWzFdICE9IHVuZGVmaW5lZCA/IHNjcm9sbFBvc2l0aW9uWzFdLnRyaW0oKSA6ICdlbmQnO1xuICAgIC8vIFZpZXdwb3J0XG4gICAgY29uc3Qgdmlld3BvcnRTdGFydCA9IG9mZnNldFN0YXJ0LmluY2x1ZGVzKCclJykgPyB3U2l6ZSAqIHBhcnNlSW50KG9mZnNldFN0YXJ0LnJlcGxhY2UoJyUnLCAnJykudHJpbSgpKSAqIDAuMDEgOiBwYXJzZUludChvZmZzZXRTdGFydCk7XG4gICAgY29uc3Qgdmlld3BvcnRFbmQgPSBvZmZzZXRFbmQuaW5jbHVkZXMoJyUnKSA/IHdTaXplICogcGFyc2VJbnQob2Zmc2V0RW5kLnJlcGxhY2UoJyUnLCAnJykudHJpbSgpKSAqIDAuMDEgOiBwYXJzZUludChvZmZzZXRFbmQpO1xuICAgIC8vIEZvbGQgZXhjZXB0aW9uXG4gICAgaWYgKHRoaXMuaXNJbkZvbGQpIHtcbiAgICAgIHNjcm9sbFBvc2l0aW9uU3RhcnQgPSAnZm9sZCc7XG4gICAgfVxuICAgIC8vIERlZmluZSBJbnRlcnNlY3Rpb24gU3RhcnRcbiAgICBzd2l0Y2ggKHNjcm9sbFBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB3U2l6ZSArIHZpZXdwb3J0U3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB3U2l6ZSArIHZpZXdwb3J0U3RhcnQgKyBtZXRyaWNzU2l6ZSAqIDAuNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5zdGFydCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHdTaXplICsgdmlld3BvcnRTdGFydCArIG1ldHJpY3NTaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZvbGQnOlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5zdGFydCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB3U2l6ZSArIHZpZXdwb3J0U3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBEZWZpbmUgSW50ZXJzZWN0aW9uIEVuZFxuICAgIHN3aXRjaCAoc2Nyb2xsUG9zaXRpb25FbmQpIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gdmlld3BvcnRFbmQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gdmlld3BvcnRFbmQgKyBtZXRyaWNzU2l6ZSAqIDAuNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB2aWV3cG9ydEVuZCArIG1ldHJpY3NTaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHZpZXdwb3J0RW5kICsgbWV0cmljc1NpemU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBBdm9pZCB0byBoYXZlIHRoZSBlbmQgPCB0aGUgc3RhcnQgaW50ZXJzZWN0aW9uID5cbiAgICBpZiAodGhpcy5pbnRlcnNlY3Rpb24uZW5kIDw9IHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0KSB7XG4gICAgICBzd2l0Y2ggKHNjcm9sbFBvc2l0aW9uRW5kKSB7XG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLmludGVyc2VjdGlvbi5zdGFydCArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgKyBtZXRyaWNzU2l6ZSAqIDAuNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLmludGVyc2VjdGlvbi5zdGFydCArIG1ldHJpY3NTaXplO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ29tcHV0ZSB0aGUgc2Nyb2xsIHByb2dyZXNzIG9mIHRoZSBlbGVtZW50IGRlcGVuZGluZ1xyXG4gICAqIG9uIGl0cyBpbnRlcnNlY3Rpb24gdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZm9yY2VkUHJvZ3Jlc3NdIC0gVmFsdWUgdG8gZm9yY2UgcHJvZ3Jlc3MuXHJcbiAgICovXG4gIF9jb21wdXRlUHJvZ3Jlc3MoZm9yY2VkUHJvZ3Jlc3MpIHtcbiAgICAvLyBQcm9ncmVzc1xuICAgIGNvbnN0IHByb2dyZXNzID0gZm9yY2VkUHJvZ3Jlc3MgIT0gbnVsbCA/IGZvcmNlZFByb2dyZXNzIDogY2xhbXAoMCwgMSwgbm9ybWFsaXplKHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0LCB0aGlzLmludGVyc2VjdGlvbi5lbmQsIHRoaXMuY3VycmVudFNjcm9sbCkpO1xuICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICBpZiAocHJvZ3Jlc3MgIT0gdGhpcy5sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMubGFzdFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAvLyBTZXQgdGhlIGVsZW1lbnQncyBwcm9ncmVzcyB0byB0aGUgY3NzIHZhcmlhYmxlXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsQ3NzUHJvZ3Jlc3MgJiYgdGhpcy5fc2V0Q3NzUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgLy8gU2V0IHRoZSBlbGVtZW50J3MgcHJvZ3Jlc3MgdG8gdGhlIGN1c3RvbSBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxFdmVudFByb2dyZXNzICYmIHRoaXMuX3NldEN1c3RvbUV2ZW50UHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgLy8gU2V0IHRoZSBlbGVtZW50J3MgcHJvZ3Jlc3MgdG8gaW5saW5lIG1vZHVsZXNcbiAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsTW9kdWxlUHJvZ3Jlc3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGFyTW9kdWxlcyBvZiB0aGlzLnByb2dyZXNzTW9kdWxhck1vZHVsZXMpIHtcbiAgICAgICAgICB0aGlzLm1vZHVsYXJJbnN0YW5jZSAmJiB0aGlzLm1vZHVsYXJJbnN0YW5jZS5jYWxsKFBST0dSRVNTX01PRFVMQVJfTUVUSE9ELCBwcm9ncmVzcywgbW9kdWxhck1vZHVsZXMubW9kdWxlTmFtZSwgbW9kdWxhck1vZHVsZXMubW9kdWxlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2dpYyB0byB0cmlnZ2VyIHRoZSBpbnZpZXcvb3V0IG9mIHZpZXcgY2FsbGJhY2tzXG4gICAgICBwcm9ncmVzcyA+IDAgJiYgcHJvZ3Jlc3MgPCAxICYmIHRoaXMuc2V0SW52aWV3KCk7XG4gICAgICBwcm9ncmVzcyA9PT0gMCAmJiB0aGlzLnNldE91dE9mVmlldygpO1xuICAgICAgcHJvZ3Jlc3MgPT09IDEgJiYgdGhpcy5zZXRPdXRPZlZpZXcoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBlbGVtZW50J3MgcHJvZ3Jlc3MgdG8gYSBzcGVjaWZpYyBjc3MgdmFyaWFibGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50UHJvZ3Jlc3NdIC0gUHJvZ3Jlc3MgdmFsdWUuXHJcbiAgICovXG4gIF9zZXRDc3NQcm9ncmVzcyhjdXJyZW50UHJvZ3Jlc3MgPSAwKSB7XG4gICAgdGhpcy4kZWwuc3R5bGUuc2V0UHJvcGVydHkoUFJPR1JFU1NfQ1NTX1ZBUiwgY3VycmVudFByb2dyZXNzLnRvU3RyaW5nKCkpO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCB0aGUgZWxlbWVudCdzIHByb2dyZXNzIHRvIHRoZSBjdXN0b20gZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VycmVudFByb2dyZXNzXSAtIFByb2dyZXNzIHZhbHVlLlxyXG4gICAqL1xuICBfc2V0Q3VzdG9tRXZlbnRQcm9ncmVzcyhjdXJyZW50UHJvZ3Jlc3MgPSAwKSB7XG4gICAgY29uc3QgY3VzdG9tRXZlbnROYW1lID0gdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbEV2ZW50UHJvZ3Jlc3M7XG4gICAgaWYgKCFjdXN0b21FdmVudE5hbWUpIHJldHVybjtcbiAgICBjb25zdCBjdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChjdXN0b21FdmVudE5hbWUsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGVsLFxuICAgICAgICBwcm9ncmVzczogY3VycmVudFByb2dyZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBtb2R1bGFyIG1vZHVsZXMgdGhhdCBjYW4gbGlzdGVuIHRoZSBlbGVtZW50J3MgcHJvZ3Jlc3MuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfZ2V0UHJvZ3Jlc3NNb2R1bGFyTW9kdWxlcygpIHtcbiAgICBpZiAoIXRoaXMubW9kdWxhckluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZXNJZE5hbWVzID0gT2JqZWN0LmtleXModGhpcy4kZWwuZGF0YXNldCkuZmlsdGVyKGtleSA9PiBrZXkuaW5jbHVkZXMoJ21vZHVsZScpKTtcbiAgICBjb25zdCBtb2R1bGVzID0gT2JqZWN0LmVudHJpZXModGhpcy5tb2R1bGFySW5zdGFuY2UubW9kdWxlcyk7XG4gICAgaWYgKCFtb2R1bGVzSWROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2R1bGVzSWROYW1lIG9mIG1vZHVsZXNJZE5hbWVzKSB7XG4gICAgICBjb25zdCBtb2R1bGVJZCA9IHRoaXMuJGVsLmRhdGFzZXRbbW9kdWxlc0lkTmFtZV07XG4gICAgICBpZiAoIW1vZHVsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgY29uc3QgW21vZHVsZU5hbWUsIG1vZHVsZU9ial0gPSBtb2R1bGU7XG4gICAgICAgIGlmIChtb2R1bGVJZCBpbiBtb2R1bGVPYmopIHtcbiAgICAgICAgICB0aGlzLnByb2dyZXNzTW9kdWxhck1vZHVsZXMucHVzaCh7XG4gICAgICAgICAgICBtb2R1bGVOYW1lLFxuICAgICAgICAgICAgbW9kdWxlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBGdW5jdGlvbiB0byBnZXQgc2Nyb2xsIGNhbGwgZnJvbS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9nZXRTY3JvbGxDYWxsRnJvbSgpIHtcbiAgICBjb25zdCBjbG9zZXN0SW50ZXJzZWN0aW9uVmFsdWUgPSBjbG9zZXN0TnVtYmVyKFt0aGlzLmludGVyc2VjdGlvbi5zdGFydCwgdGhpcy5pbnRlcnNlY3Rpb24uZW5kXSwgdGhpcy5jdXJyZW50U2Nyb2xsKTtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgPT09IGNsb3Nlc3RJbnRlcnNlY3Rpb25WYWx1ZSA/ICdzdGFydCcgOiAnZW5kJztcbiAgfVxuICAvKipcclxuICAgKiBGdW5jdGlvbiB0byBkaXNwYXRjaCBhIGN1c3RvbSBldmVudCBvciBjYWxsIGEgbW9kdWxhciBjYWxsYmFjay5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3Njcm9sbENhbGxXYXl9IHdheSAtIEVudGVyIG9yIGxlYXZlLlxyXG4gICAqIEBwYXJhbSB7c2Nyb2xsQ2FsbEZyb219IGZyb20gLSBTdGFydCBvciBlbmQuXHJcbiAgICovXG4gIF9kaXNwYXRjaENhbGwod2F5LCBmcm9tKSB7XG4gICAgdmFyIF90aGlzJGF0dHJpYnV0ZXMkc2NybywgX3RoaXMkYXR0cmlidXRlcztcbiAgICBjb25zdCBjYWxsUGFyYW1ldGVycyA9IChfdGhpcyRhdHRyaWJ1dGVzJHNjcm8gPSB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsQ2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGF0dHJpYnV0ZXMkc2Nyby5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IGNhbGxTZWxmID0gKF90aGlzJGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdHRyaWJ1dGVzLnNjcm9sbENhbGxTZWxmO1xuICAgIGlmIChjYWxsUGFyYW1ldGVycyAmJiBjYWxsUGFyYW1ldGVycy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgX3RhcmdldE1vZHVsZUlkO1xuICAgICAgLy8gVXNpbmcgTW9kdWxhci5qcyAoaHR0cHM6Ly9naXRodWIuY29tL21vZHVsYXJvcmcvbW9kdWxhcmpzKVxuICAgICAgY29uc3QgW2Z1bmMsIG1vZHVsZU5hbWUsIG1vZHVsZUlkXSA9IGNhbGxQYXJhbWV0ZXJzO1xuICAgICAgbGV0IHRhcmdldE1vZHVsZUlkO1xuICAgICAgLy8gSWYgdGhlIG1vZHVsZSBpcyBzZXQgb24gdGhlIHNjcm9sbCBlbGVtZW50XG4gICAgICBpZiAoY2FsbFNlbGYpIHtcbiAgICAgICAgdGFyZ2V0TW9kdWxlSWQgPSB0aGlzLiRlbC5kYXRhc2V0W2Btb2R1bGUke21vZHVsZU5hbWUudHJpbSgpfWBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0TW9kdWxlSWQgPSBtb2R1bGVJZDtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kdWxhckluc3RhbmNlICYmIHRoaXMubW9kdWxhckluc3RhbmNlLmNhbGwoZnVuYy50cmltKCksIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRlbCxcbiAgICAgICAgd2F5LFxuICAgICAgICBmcm9tXG4gICAgICB9LCBtb2R1bGVOYW1lLnRyaW0oKSwgKF90YXJnZXRNb2R1bGVJZCA9IHRhcmdldE1vZHVsZUlkKSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldE1vZHVsZUlkLnRyaW0oKSk7XG4gICAgfSBlbHNlIGlmIChjYWxsUGFyYW1ldGVycykge1xuICAgICAgLy8gVXNpbmcgQ3VzdG9tRXZlbnQgQVBJIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpXG4gICAgICBjb25zdCBbY3VzdG9tRXZlbnROYW1lXSA9IGNhbGxQYXJhbWV0ZXJzO1xuICAgICAgY29uc3QgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnROYW1lLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIHRhcmdldDogdGhpcy4kZWwsXG4gICAgICAgICAgd2F5LFxuICAgICAgICAgIGZyb21cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxyXG4gKiBJbnRlZ3JhdGVzIExlbmlzIHdpdGggTG9jb21vdGl2ZSdzIGJ1aWx0LWluIGFuaW1hdGlvbiBzeXN0ZW1cclxuICovXG4vKiogRGVmaW5lZCBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuY29uc3QgQVRUUklCVVRFU19USEFUX05FRURfUkFGID0gWydzY3JvbGxPZmZzZXQnLCAnc2Nyb2xsUG9zaXRpb24nLCAnc2Nyb2xsTW9kdWxlUHJvZ3Jlc3MnLCAnc2Nyb2xsQ3NzUHJvZ3Jlc3MnLCAnc2Nyb2xsRXZlbnRQcm9ncmVzcycsICdzY3JvbGxTcGVlZCddO1xuLyoqIERlZmF1bHQgcm9vdCBtYXJnaW5zICovXG5jb25zdCBUUklHR0VSX1JPT1RfTUFSR0lOID0gJy0xcHggLTFweCAtMXB4IC0xcHgnO1xuY29uc3QgUkFGX1JPT1RfTUFSR0lOID0gJzEwMCUgMTAwJSAxMDAlIDEwMCUnOyAvLyBBZGQgMTAwdmggdG9wL2JvdHRvbSAmJiAxMDB2dyBsZWZ0L3JpZ2h0IHRvIHVzZSBhIGJpZ2dlc3QgdmFsdWUgd2l0aCBkYXRhLXNjcm9sbC1zcGVlZFxuY2xhc3MgQ29yZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICAkZWwsXG4gICAgbW9kdWxhckluc3RhbmNlLFxuICAgIHRyaWdnZXJSb290TWFyZ2luLFxuICAgIHJhZlJvb3RNYXJnaW4sXG4gICAgc2Nyb2xsT3JpZW50YXRpb25cbiAgfSkge1xuICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZHVsYXJJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJSb290TWFyZ2luID0gdm9pZCAwO1xuICAgIHRoaXMucmFmUm9vdE1hcmdpbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5SQUZTY3JvbGxFbGVtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5JT1RyaWdnZXJJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLklPUmFmSW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9IHZvaWQgMDtcbiAgICBpZiAoISRlbCkge1xuICAgICAgY29uc29sZS5lcnJvcignUGxlYXNlIHByb3ZpZGUgYSBET00gRWxlbWVudCBhcyBzY3JvbGxDb250YWluZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2Nyb2xsIGNvbnRhaW5lclxuICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lciA9ICRlbDtcbiAgICAvLyBNb2R1bGFyLmpzXG4gICAgdGhpcy5tb2R1bGFySW5zdGFuY2UgPSBtb2R1bGFySW5zdGFuY2U7XG4gICAgLy8gU2Nyb2xsIERpcmVjdGlvblxuICAgIHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPSBzY3JvbGxPcmllbnRhdGlvbjtcbiAgICAvLyBJTyBNYXJnaW5zXG4gICAgdGhpcy50cmlnZ2VyUm9vdE1hcmdpbiA9IHRyaWdnZXJSb290TWFyZ2luICE9IG51bGwgPyB0cmlnZ2VyUm9vdE1hcmdpbiA6IFRSSUdHRVJfUk9PVF9NQVJHSU47XG4gICAgdGhpcy5yYWZSb290TWFyZ2luID0gcmFmUm9vdE1hcmdpbiAhPSBudWxsID8gcmFmUm9vdE1hcmdpbiA6IFJBRl9ST09UX01BUkdJTjtcbiAgICAvLyBTY3JvbGxFbGVtZW50cyBhcnJheXNcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzID0gW107XG4gICAgdGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuUkFGU2Nyb2xsRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUgPSBbXTtcbiAgICAvLyBJbml0XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gSW5pdGlhbGl6ZSB0aGUgY29yZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9pbml0KCkge1xuICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50cyA9IHRoaXMuJHNjcm9sbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zY3JvbGxdJyk7XG4gICAgY29uc3QgJHNjcm9sbEVsZW1lbnRzQXJyID0gQXJyYXkuZnJvbSgkc2Nyb2xsRWxlbWVudHMpO1xuICAgIHRoaXMuX3N1YnNjcmliZVNjcm9sbEVsZW1lbnRzKCRzY3JvbGxFbGVtZW50c0Fycik7XG4gICAgLy8gVHJpZ2dlciBJT1xuICAgIHRoaXMuSU9UcmlnZ2VySW5zdGFuY2UgPSBuZXcgSU8oe1xuICAgICAgc2Nyb2xsRWxlbWVudHM6IFsuLi50aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzXSxcbiAgICAgIHJvb3RNYXJnaW46IHRoaXMudHJpZ2dlclJvb3RNYXJnaW4sXG4gICAgICBJT1JhZjogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBSYWYgSU9cbiAgICB0aGlzLklPUmFmSW5zdGFuY2UgPSBuZXcgSU8oe1xuICAgICAgc2Nyb2xsRWxlbWVudHM6IFsuLi50aGlzLlJBRlNjcm9sbEVsZW1lbnRzXSxcbiAgICAgIHJvb3RNYXJnaW46IHRoaXMucmFmUm9vdE1hcmdpbixcbiAgICAgIElPUmFmOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBEZXN0cm95IGNvcmUuXHJcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5JT1RyaWdnZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgdGhpcy5JT1JhZkluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB0aGlzLl91bnN1YnNjcmliZUFsbFNjcm9sbEVsZW1lbnRzKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgLSBSZXNpemUgY2FsbGJhY2suXHJcbiAgICovXG4gIG9uUmVzaXplKHtcbiAgICBjdXJyZW50U2Nyb2xsXG4gIH0pIHtcbiAgICBmb3IgKGNvbnN0IHNjcm9sbEVsZW1lbnQgb2YgdGhpcy5SQUZTY3JvbGxFbGVtZW50cykge1xuICAgICAgc2Nyb2xsRWxlbWVudC5vblJlc2l6ZSh7XG4gICAgICAgIGN1cnJlbnRTY3JvbGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayAtIFJBRiBjYWxsYmFjay5cclxuICAgKi9cbiAgb25SZW5kZXIoe1xuICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgc21vb3RoXG4gIH0pIHtcbiAgICBmb3IgKGNvbnN0IHNjcm9sbEVsZW1lbnQgb2YgdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlKSB7XG4gICAgICBzY3JvbGxFbGVtZW50Lm9uUmVuZGVyKHtcbiAgICAgICAgY3VycmVudFNjcm9sbCxcbiAgICAgICAgc21vb3RoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlIGl0ZW1zIGZyb20gbGlzdHMgb2Ygc2Nyb2xsIGVsZW1lbnRzIGFuZCBjb21wdXRlIGFsbCBuZXcgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJG9sZENvbnRhaW5lciAtIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgZGF0YS1zY3JvbGwgZWxlbWVudHMgdG8gdW5zdWJzY3JpYmVcclxuICAgKi9cbiAgcmVtb3ZlU2Nyb2xsRWxlbWVudHMoJG9sZENvbnRhaW5lcikge1xuICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlID0gJG9sZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zY3JvbGxdJyk7XG4gICAgaWYgKCEkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZS5sZW5ndGgpIHJldHVybjtcbiAgICAvLyAxLiBSZW1vdmUgZnJvbSBJT1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHNbaW5kZXhdO1xuICAgICAgY29uc3QgJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmVBcnIgPSBBcnJheS5mcm9tKCRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlKTtcbiAgICAgIGlmICgkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZUFyci5pbmRleE9mKHNjcm9sbEVsZW1lbnQuJGVsKSA+IC0xKSB7XG4gICAgICAgIHRoaXMuSU9UcmlnZ2VySW5zdGFuY2UudW5vYnNlcnZlKHNjcm9sbEVsZW1lbnQuJGVsKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5SQUZTY3JvbGxFbGVtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzW2luZGV4XTtcbiAgICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlQXJyID0gQXJyYXkuZnJvbSgkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZSk7XG4gICAgICBpZiAoJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmVBcnIuaW5kZXhPZihzY3JvbGxFbGVtZW50LiRlbCkgPiAtMSkge1xuICAgICAgICB0aGlzLklPUmFmSW5zdGFuY2UudW5vYnNlcnZlKHNjcm9sbEVsZW1lbnQuJGVsKTtcbiAgICAgICAgdGhpcy5SQUZTY3JvbGxFbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAyLiBSZW1vdmUgZnJvbSBzY3JvbGxFbGVtZW50c1RvVXBkYXRlW10gYW5kIHNjcm9sbEVsZW1lbnRzW11cbiAgICAkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZS5mb3JFYWNoKCRzY3JvbGxFbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFNjcm9sbEVsZW1lbnRUb1VwZGF0ZSA9IHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZS5maW5kKHNjcm9sbEVsZW1lbnQgPT4gc2Nyb2xsRWxlbWVudC4kZWwgPT09ICRzY3JvbGxFbGVtZW50KTtcbiAgICAgIGNvbnN0IHRhcmdldFNjcm9sbEVsZW1lbnQgPSB0aGlzLnNjcm9sbEVsZW1lbnRzLmZpbmQoc2Nyb2xsRWxlbWVudCA9PiBzY3JvbGxFbGVtZW50LiRlbCA9PT0gJHNjcm9sbEVsZW1lbnQpO1xuICAgICAgaWYgKHRhcmdldFNjcm9sbEVsZW1lbnRUb1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZUVsZW1lbnRVcGRhdGUodGFyZ2V0U2Nyb2xsRWxlbWVudFRvVXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRTY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMgPSB0aGlzLnNjcm9sbEVsZW1lbnRzLmZpbHRlcihzY3JvbGxFbGVtZW50SXRlbSA9PiBzY3JvbGxFbGVtZW50SXRlbS5pZCAhPSB0YXJnZXRTY3JvbGxFbGVtZW50LmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBBZGQgaXRlbXMgdG8gbGlzdHMgb2Ygc2Nyb2xsIGVsZW1lbnRzIGFuZCBjb21wdXRlIGFsbCBuZXcgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJG5ld0NvbnRhaW5lciAtIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgZGF0YS1zY3JvbGwgZWxlbWVudHMgdG8gc3Vic2NyaWJlXHJcbiAgICovXG4gIGFkZFNjcm9sbEVsZW1lbnRzKCRuZXdDb250YWluZXIpIHtcbiAgICAvLyAzLiBSZWJ1aWxkIFNjcm9sbEVsZW1lbnRzXG4gICAgY29uc3QgJHNjcm9sbEVsZW1lbnRzID0gJG5ld0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zY3JvbGxdJyk7XG4gICAgLy8gNC4gR2V0IG1heCBzY3JvbGxFbGVtZW50LmlkXG4gICAgY29uc3QgaWRzID0gW107XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50cy5mb3JFYWNoKHNjcm9sbEVsZW1lbnQgPT4ge1xuICAgICAgaWRzLnB1c2goc2Nyb2xsRWxlbWVudC5pZCk7XG4gICAgfSk7XG4gICAgY29uc3QgbWF4SUQgPSBNYXRoLm1heCguLi5pZHMpO1xuICAgIGNvbnN0IGZyb21JbmRleCA9IG1heElEICsgMTtcbiAgICBjb25zdCAkc2Nyb2xsRWxlbWVudHNBcnIgPSBBcnJheS5mcm9tKCRzY3JvbGxFbGVtZW50cyk7XG4gICAgdGhpcy5fc3Vic2NyaWJlU2Nyb2xsRWxlbWVudHMoJHNjcm9sbEVsZW1lbnRzQXJyLCBmcm9tSW5kZXgsIHRydWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIFNjcm9sbEVsZW1lbnQgaW5zdGFuY2UgZm9yIGVhY2ggZWxlbWVudHMgd2l0aFxyXG4gICAqIGBkYXRhLXNjcm9sbGAgYXR0cmlidXRlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gJHNjcm9sbEVsZW1lbnRzIC0gTGlzdCBvZiBlbGVtZW50cyB0aGF0IG5lZWRcclxuICAgKiAgICAgdG8gYmUgcmVnYXJkZWQuXHJcbiAgICovXG4gIF9zdWJzY3JpYmVTY3JvbGxFbGVtZW50cygkc2Nyb2xsRWxlbWVudHMsIGZyb21JbmRleCA9IDAsIHRvT2JzZXJ2ZSA9IGZhbHNlKSB7XG4gICAgLy8gRm9yIGVhY2ggc2Nyb2xsIGVsZW1lbnQgY3JlYXRlIGEgU2Nyb2xsRWxlbWVudCBpbnN0YW5jZVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAkc2Nyb2xsRWxlbWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCAkc2Nyb2xsRWxlbWVudCA9ICRzY3JvbGxFbGVtZW50c1tpbmRleF07XG4gICAgICBjb25zdCBuZWVkUmFmID0gdGhpcy5fY2hlY2tSYWZOZWVkZWQoJHNjcm9sbEVsZW1lbnQpO1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudEluc3RhbmNlID0gbmV3IFNjcm9sbEVsZW1lbnQoe1xuICAgICAgICAkZWw6ICRzY3JvbGxFbGVtZW50LFxuICAgICAgICBpZDogZnJvbUluZGV4ICsgaW5kZXgsXG4gICAgICAgIHNjcm9sbE9yaWVudGF0aW9uOiB0aGlzLnNjcm9sbE9yaWVudGF0aW9uLFxuICAgICAgICBtb2R1bGFySW5zdGFuY2U6IHRoaXMubW9kdWxhckluc3RhbmNlLFxuICAgICAgICBzdWJzY3JpYmVFbGVtZW50VXBkYXRlRm46IHRoaXMuX3N1YnNjcmliZUVsZW1lbnRVcGRhdGUuYmluZCh0aGlzKSxcbiAgICAgICAgdW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm46IHRoaXMuX3Vuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgICBuZWVkUmFmXG4gICAgICB9KTtcbiAgICAgIC8vIFB1c2ggdG8gY29tbW9uIGFycmF5XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnRzLnB1c2goc2Nyb2xsRWxlbWVudEluc3RhbmNlKTtcbiAgICAgIC8vIFB1c2ggdG8gc3BlY2lmaWMgYXJyYXlcbiAgICAgIGlmIChuZWVkUmFmKSB7XG4gICAgICAgIHRoaXMuUkFGU2Nyb2xsRWxlbWVudHMucHVzaChzY3JvbGxFbGVtZW50SW5zdGFuY2UpO1xuICAgICAgICAvLyBEeW5hbWljIG9ic2VydmUgaXRlbVxuICAgICAgICBpZiAodG9PYnNlcnZlKSB7XG4gICAgICAgICAgdGhpcy5JT1JhZkluc3RhbmNlLnNjcm9sbEVsZW1lbnRzLnB1c2goc2Nyb2xsRWxlbWVudEluc3RhbmNlKTtcbiAgICAgICAgICB0aGlzLklPUmFmSW5zdGFuY2Uub2JzZXJ2ZShzY3JvbGxFbGVtZW50SW5zdGFuY2UuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50cy5wdXNoKHNjcm9sbEVsZW1lbnRJbnN0YW5jZSk7XG4gICAgICAgIC8vIER5bmFtaWMgb2JzZXJ2ZSBpdGVtXG4gICAgICAgIGlmICh0b09ic2VydmUpIHtcbiAgICAgICAgICB0aGlzLklPVHJpZ2dlckluc3RhbmNlLnNjcm9sbEVsZW1lbnRzLnB1c2goc2Nyb2xsRWxlbWVudEluc3RhbmNlKTtcbiAgICAgICAgICB0aGlzLklPVHJpZ2dlckluc3RhbmNlLm9ic2VydmUoc2Nyb2xsRWxlbWVudEluc3RhbmNlLiRlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xlYXIgYWxsIFNjcm9sbEVsZW1lbnQgYXJyYXlzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX3Vuc3Vic2NyaWJlQWxsU2Nyb2xsRWxlbWVudHMoKSB7XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuUkFGU2Nyb2xsRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlID0gW107XG4gIH1cbiAgLyoqXHJcbiAgICogU3Vic2NyaWJlIFNjcm9sbEVsZW1lbnQgaW5zdGFuY2UgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2Nyb2xsRWxlbWVudH0gc2Nyb2xsRWxlbWVudCAtIFNjcm9sbEVsZW1lbnQgaW5zdGFuY2UgaW52aWV3XHJcbiAgICogICAgIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZC5cclxuICAgKi9cbiAgX3N1YnNjcmliZUVsZW1lbnRVcGRhdGUoc2Nyb2xsRWxlbWVudCkge1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZS5wdXNoKHNjcm9sbEVsZW1lbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVuc2NyaWJlIFNjcm9sbEVsZW1lbnQgaW5zdGFuY2UgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdXBkYXRlZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1Njcm9sbEVsZW1lbnR9IHNjcm9sbEVsZW1lbnQgLSBUaGUgdXBkYXRlZCBTY3JvbGxFbGVtZW50IGluc3RhbmNlXHJcbiAgICogICAgIG91dCBvZiB2aWV3IG5vdy5cclxuICAgKi9cbiAgX3Vuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZShzY3JvbGxFbGVtZW50KSB7XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlID0gdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlLmZpbHRlcihzY3JvbGxFbGVtZW50VG9VcGRhdGUgPT4gc2Nyb2xsRWxlbWVudFRvVXBkYXRlLmlkICE9IHNjcm9sbEVsZW1lbnQuaWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgRE9NIEVsZW1lbnQgbmVlZCBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0byBiZSB1c2VkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRzY3JvbGxFbGVtZW50IC0gVGhlIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBiZSBjaGVja2VkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXG4gIF9jaGVja1JhZk5lZWRlZCgkc2Nyb2xsRWxlbWVudCkge1xuICAgIGxldCBhdHRyaWJ1dGVzVGhhdE5lZWRSYWYgPSBbLi4uQVRUUklCVVRFU19USEFUX05FRURfUkFGXTtcbiAgICAvLyBSZW1vdmUgdXRpbHNcbiAgICBjb25zdCByZW1vdmVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVUb1JlbW92ZSA9PiB7XG4gICAgICBhdHRyaWJ1dGVzVGhhdE5lZWRSYWYgPSBhdHRyaWJ1dGVzVGhhdE5lZWRSYWYuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUgIT0gYXR0cmlidXRlVG9SZW1vdmUpO1xuICAgIH07XG4gICAgLy8gMS4gQ2hlY2sgc2Nyb2xsIG9mZnNldCB2YWx1ZXNcbiAgICBpZiAoJHNjcm9sbEVsZW1lbnQuZGF0YXNldC5zY3JvbGxPZmZzZXQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gJHNjcm9sbEVsZW1lbnQuZGF0YXNldC5zY3JvbGxPZmZzZXQuc3BsaXQoJywnKS5tYXAodGVzdCA9PiB0ZXN0LnJlcGxhY2UoJyUnLCAnJykudHJpbSgpKS5qb2luKCcsJyk7XG4gICAgICBpZiAodmFsdWUgIT0gJzAsMCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVBdHRyaWJ1dGUoJ3Njcm9sbE9mZnNldCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoJ3Njcm9sbE9mZnNldCcpO1xuICAgIH1cbiAgICAvLyAyLiBDaGVjayBzY3JvbGwgcG9zaXRpb24gdmFsdWVzXG4gICAgaWYgKCRzY3JvbGxFbGVtZW50LmRhdGFzZXQuc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gJHNjcm9sbEVsZW1lbnQuZGF0YXNldC5zY3JvbGxQb3NpdGlvbi50cmltKCk7XG4gICAgICBpZiAodmFsdWUgIT0gJ3RvcCxib3R0b20nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQXR0cmlidXRlKCdzY3JvbGxQb3NpdGlvbicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoJ3Njcm9sbFBvc2l0aW9uJyk7XG4gICAgfVxuICAgIC8vIDMuIENoZWNrIHNjcm9sbCBzcGVlZCB2YWx1ZXNcbiAgICBpZiAoJHNjcm9sbEVsZW1lbnQuZGF0YXNldC5zY3JvbGxTcGVlZCAmJiAhaXNOYU4ocGFyc2VGbG9hdCgkc2Nyb2xsRWxlbWVudC5kYXRhc2V0LnNjcm9sbFNwZWVkKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoJ3Njcm9sbFNwZWVkJyk7XG4gICAgfVxuICAgIC8vIDQuIENoZWNrIG90aGVycyBhdHRyaWJ1dGVzXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlc1RoYXROZWVkUmFmKSB7XG4gICAgICBpZiAoYXR0cmlidXRlIGluICRzY3JvbGxFbGVtZW50LmRhdGFzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcclxuICogUmVzaXplIE9ic2VydmVyXHJcbiAqXHJcbiAqIFRoZSBSZXNpemUgT2JzZXJ2ZXIgQVBJIHByb3ZpZGVzIGEgcGVyZm9ybWFudCBtZWNoYW5pc20gYnkgd2hpY2ggY29kZSBjYW4gbW9uaXRvciBhbiBlbGVtZW50IGZvciBjaGFuZ2VzIHRvIGl0cyBzaXplLFxyXG4gKiB3aXRoIG5vdGlmaWNhdGlvbnMgYmVpbmcgZGVsaXZlcmVkIHRvIHRoZSBvYnNlcnZlciBlYWNoIHRpbWUgdGhlIHNpemUgY2hhbmdlcy5cclxuICpcclxuICogRmVhdHVyZXMgZnVuY3Rpb25zIHRvOlxyXG4gKlxyXG4gKiAtIFRyaWdnZXIgdGhlIHJlc2l6ZSBjYWxsYmFjayBpZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQncyBzaXplIGNoYW5nZS5cclxuICpcclxuICogUmVmZXJlbmNlczpcclxuICpcclxuICogLSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc2l6ZV9PYnNlcnZlcl9BUEl9XHJcbiAqL1xuY2xhc3MgUk8ge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmVzaXplRWxlbWVudHMsXG4gICAgcmVzaXplQ2FsbGJhY2sgPSAoKSA9PiB7fVxuICB9KSB7XG4gICAgdGhpcy4kcmVzaXplRWxlbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0ZpcnN0T2JzZXJ2ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMucmVzaXplQ2FsbGJhY2sgPSB2b2lkIDA7XG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIHRoaXMuJHJlc2l6ZUVsZW1lbnRzID0gcmVzaXplRWxlbWVudHM7XG4gICAgdGhpcy5yZXNpemVDYWxsYmFjayA9IHJlc2l6ZUNhbGxiYWNrO1xuICAgIC8vIEZsYWdzXG4gICAgdGhpcy5pc0ZpcnN0T2JzZXJ2ZSA9IHRydWU7XG4gICAgLy8gSW5pdFxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIEluaXRpYWxpemUgUmVzaXplIE9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgLy8gQ2FsbGJhY2tcbiAgICBjb25zdCBvblJlc2l6ZSA9IGVudHJpZXMgPT4ge1xuICAgICAgdmFyIF90aGlzJHJlc2l6ZUNhbGxiYWNrO1xuICAgICAgIXRoaXMuaXNGaXJzdE9ic2VydmUgJiYgKChfdGhpcyRyZXNpemVDYWxsYmFjayA9IHRoaXMucmVzaXplQ2FsbGJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRyZXNpemVDYWxsYmFjay5jYWxsKHRoaXMpKTtcbiAgICAgIHRoaXMuaXNGaXJzdE9ic2VydmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8vIEluc3RhbmNlXG4gICAgdGhpcy5vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihvblJlc2l6ZSk7XG4gICAgLy8gT2JzZXJ2ZSBlYWNoIGRlZmF1bHQgZWxlbWVudHNcbiAgICBmb3IgKGNvbnN0ICRyZXNpemVFbGVtZW50IG9mIHRoaXMuJHJlc2l6ZUVsZW1lbnRzKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUoJHJlc2l6ZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIERlc3Ryb3kgUmVzaXplIE9ic2VydmVyLlxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG59XG5cbi8qKlxyXG4gKiBAdHlwZSB7SUxlbmlzT3B0aW9uc31cclxuICovXG5jb25zdCBkZWZhdWx0TGVuaXNPcHRpb25zID0ge1xuICB3cmFwcGVyOiB3aW5kb3csXG4gIGNvbnRlbnQ6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgbGVycDogMC4xLFxuICBkdXJhdGlvbjogMS4yLFxuICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgZ2VzdHVyZU9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICBzbW9vdGhXaGVlbDogdHJ1ZSxcbiAgc21vb3RoVG91Y2g6IGZhbHNlLFxuICB3aGVlbE11bHRpcGxpZXI6IDEsXG4gIHRvdWNoTXVsdGlwbGllcjogMixcbiAgbm9ybWFsaXplV2hlZWw6IHRydWUsXG4gIGVhc2luZzogdCA9PiBNYXRoLm1pbigxLCAxLjAwMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpKSAvLyBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvYnJzNTRsNHhvdVxufTtcbi8qKlxyXG4gKiBMb2NvbW90aXZlIFNjcm9sbFxyXG4gKlxyXG4gKiBEZXRlY3Rpb24gb2YgZWxlbWVudHMgaW4gdmlld3BvcnQgJiBzbW9vdGggc2Nyb2xsaW5nIHdpdGggcGFyYWxsYXguXHJcbiAqXHJcbiAqIEluc3BpcmVkIGJ5XHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbG9jb21vdGl2ZW10bC9sb2NvbW90aXZlLXNjcm9sbCBsb2NvbW90aXZlLXNjcm9sbC5qc31cclxuICogYW5kIGJ1aWx0IGFyb3VuZFxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3N0dWRpby1mcmVpZ2h0L2xlbmlzIGxlbmlzLmpzfS5cclxuICovXG5jbGFzcyBMb2NvbW90aXZlU2Nyb2xsIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGxlbmlzT3B0aW9ucyA9IHt9LFxuICAgIG1vZHVsYXJJbnN0YW5jZSxcbiAgICB0cmlnZ2VyUm9vdE1hcmdpbixcbiAgICByYWZSb290TWFyZ2luLFxuICAgIGF1dG9SZXNpemUgPSB0cnVlLFxuICAgIGF1dG9TdGFydCA9IHRydWUsXG4gICAgc2Nyb2xsQ2FsbGJhY2sgPSAoKSA9PiB7fSxcbiAgICBpbml0Q3VzdG9tVGlja2VyLFxuICAgIGRlc3Ryb3lDdXN0b21UaWNrZXJcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5yYWZQbGF5aW5nID0gdm9pZCAwO1xuICAgIHRoaXMubGVuaXNJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvcmVJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxlbmlzT3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZHVsYXJJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJSb290TWFyZ2luID0gdm9pZCAwO1xuICAgIHRoaXMucmFmUm9vdE1hcmdpbiA9IHZvaWQgMDtcbiAgICB0aGlzLnJhZkluc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9TdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLlJPSW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0Q3VzdG9tVGlja2VyID0gdm9pZCAwO1xuICAgIHRoaXMuZGVzdHJveUN1c3RvbVRpY2tlciA9IHZvaWQgMDtcbiAgICB0aGlzLl9vblJlbmRlckJpbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5fb25SZXNpemVCaW5kID0gdm9pZCAwO1xuICAgIHRoaXMuX29uU2Nyb2xsVG9CaW5kID0gdm9pZCAwO1xuICAgIC8vIEFyZ3VtZW50c1xuICAgIHRoaXMubGVuaXNPcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRMZW5pc09wdGlvbnMsIGxlbmlzT3B0aW9ucyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICBsZW5pc09wdGlvbnMsXG4gICAgICBtb2R1bGFySW5zdGFuY2UsXG4gICAgICB0cmlnZ2VyUm9vdE1hcmdpbixcbiAgICAgIHJhZlJvb3RNYXJnaW4sXG4gICAgICBhdXRvUmVzaXplLFxuICAgICAgYXV0b1N0YXJ0LFxuICAgICAgc2Nyb2xsQ2FsbGJhY2ssXG4gICAgICBpbml0Q3VzdG9tVGlja2VyLFxuICAgICAgZGVzdHJveUN1c3RvbVRpY2tlclxuICAgIH0pO1xuICAgIC8vIEJpbmRpbmdcbiAgICB0aGlzLl9vblJlbmRlckJpbmQgPSB0aGlzLl9vblJlbmRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2Nyb2xsVG9CaW5kID0gdGhpcy5fb25TY3JvbGxUby5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUmVzaXplQmluZCA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgLy8gRGF0YVxuICAgIHRoaXMucmFmUGxheWluZyA9IGZhbHNlO1xuICAgIC8vIEluaXRcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBJbml0aWFsaXplIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyIF90aGlzJGxlbmlzSW5zdGFuY2U7XG4gICAgLy8gQ3JlYXRlIExlbmlzIGluc3RhbmNlXG4gICAgdGhpcy5sZW5pc0luc3RhbmNlID0gbmV3IExlbmlzKHtcbiAgICAgIHdyYXBwZXI6IHRoaXMubGVuaXNPcHRpb25zLndyYXBwZXIsXG4gICAgICBjb250ZW50OiB0aGlzLmxlbmlzT3B0aW9ucy5jb250ZW50LFxuICAgICAgbGVycDogdGhpcy5sZW5pc09wdGlvbnMubGVycCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmxlbmlzT3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIG9yaWVudGF0aW9uOiB0aGlzLmxlbmlzT3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgIGdlc3R1cmVPcmllbnRhdGlvbjogdGhpcy5sZW5pc09wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uLFxuICAgICAgc21vb3RoV2hlZWw6IHRoaXMubGVuaXNPcHRpb25zLnNtb290aFdoZWVsLFxuICAgICAgc21vb3RoVG91Y2g6IHRoaXMubGVuaXNPcHRpb25zLnNtb290aFRvdWNoLFxuICAgICAgd2hlZWxNdWx0aXBsaWVyOiB0aGlzLmxlbmlzT3B0aW9ucy53aGVlbE11bHRpcGxpZXIsXG4gICAgICB0b3VjaE11bHRpcGxpZXI6IHRoaXMubGVuaXNPcHRpb25zLnRvdWNoTXVsdGlwbGllcixcbiAgICAgIG5vcm1hbGl6ZVdoZWVsOiB0aGlzLmxlbmlzT3B0aW9ucy5ub3JtYWxpemVXaGVlbCxcbiAgICAgIGVhc2luZzogdGhpcy5sZW5pc09wdGlvbnMuZWFzaW5nXG4gICAgfSk7XG4gICAgKF90aGlzJGxlbmlzSW5zdGFuY2UgPSB0aGlzLmxlbmlzSW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZW5pc0luc3RhbmNlLm9uKCdzY3JvbGwnLCB0aGlzLnNjcm9sbENhbGxiYWNrKTtcbiAgICAvLyBBZGQgc2Nyb2xsIGRpcmVjdGlvbiBhdHRyaWJ1dGUgb24gYm9keVxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLW9yaWVudGF0aW9uJywgdGhpcy5sZW5pc0luc3RhbmNlLm9wdGlvbnMub3JpZW50YXRpb24pO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgQ29yZSBJbnN0YW5jZVxuICAgICAgdGhpcy5jb3JlSW5zdGFuY2UgPSBuZXcgQ29yZSh7XG4gICAgICAgICRlbDogdGhpcy5sZW5pc0luc3RhbmNlLnJvb3RFbGVtZW50LFxuICAgICAgICBtb2R1bGFySW5zdGFuY2U6IHRoaXMubW9kdWxhckluc3RhbmNlLFxuICAgICAgICB0cmlnZ2VyUm9vdE1hcmdpbjogdGhpcy50cmlnZ2VyUm9vdE1hcmdpbixcbiAgICAgICAgcmFmUm9vdE1hcmdpbjogdGhpcy5yYWZSb290TWFyZ2luLFxuICAgICAgICBzY3JvbGxPcmllbnRhdGlvbjogdGhpcy5sZW5pc0luc3RhbmNlLm9wdGlvbnMub3JpZW50YXRpb25cbiAgICAgIH0pO1xuICAgICAgLy8gQmluZCBFdmVudHNcbiAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICAgIC8vIFJBRiB3YXJuaW5nXG4gICAgICBpZiAodGhpcy5pbml0Q3VzdG9tVGlja2VyICYmICF0aGlzLmRlc3Ryb3lDdXN0b21UaWNrZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdpbml0Q3VzdG9tVGlja2VyIGNhbGxiYWNrIGlzIGRlY2xhcmVkLCBidXQgZGVzdHJveUN1c3RvbVRpY2tlciBpcyBub3QuIFBsZWFzZSBwYXkgYXR0ZW50aW9uLiBJdCBjb3VsZCBjYXVzZSB0cm91YmxlLicpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5pbml0Q3VzdG9tVGlja2VyICYmIHRoaXMuZGVzdHJveUN1c3RvbVRpY2tlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2Rlc3Ryb3lDdXN0b21UaWNrZXIgY2FsbGJhY2sgaXMgZGVjbGFyZWQsIGJ1dCBpbml0Q3VzdG9tVGlja2VyIGlzIG5vdC4gUGxlYXNlIHBheSBhdHRlbnRpb24uIEl0IGNvdWxkIGNhdXNlIHRyb3VibGUuJyk7XG4gICAgICB9XG4gICAgICAvLyBTdGFydCBSQUZcbiAgICAgIHRoaXMuYXV0b1N0YXJ0ICYmIHRoaXMuc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIERlc3Ryb3kgaW5zdGFuY2UuXHJcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3RvcCByYWZcbiAgICB0aGlzLnN0b3AoKTtcbiAgICAvLyBVbmJpbmQgRXZlbnRzXG4gICAgdGhpcy5fdW5iaW5kRXZlbnRzKCk7XG4gICAgLy8gRGVzdHJveSBMZW5pc1xuICAgIHRoaXMubGVuaXNJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgLy8gRGVzdHJveSBDb3JlXG4gICAgdGhpcy5jb3JlSW5zdGFuY2UuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEV2ZW50cyAtIFN1YnNjcmliZSBldmVudHMgdG8gbGlzdGVuLlxyXG4gICAqL1xuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLl9iaW5kU2Nyb2xsVG9FdmVudHMoKTtcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICBpZiAoJ1Jlc2l6ZU9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgdGhpcy5ST0luc3RhbmNlID0gbmV3IFJPKHtcbiAgICAgICAgICByZXNpemVFbGVtZW50czogW2RvY3VtZW50LmJvZHldLFxuICAgICAgICAgIHJlc2l6ZUNhbGxiYWNrOiB0aGlzLl9vblJlc2l6ZUJpbmRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCaW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogRXZlbnRzIC0gVW5zdWJzY3JpYmUgbGlzdGVuZWQgZXZlbnRzLlxyXG4gICAqL1xuICBfdW5iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuX3VuYmluZFNjcm9sbFRvRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgaWYgKCdSZXNpemVPYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICAgIHRoaXMuUk9JbnN0YW5jZSAmJiB0aGlzLlJPSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQmluZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEV2ZW50cyAtIFN1YnNjcmliZSBzY3JvbGxUbyBldmVudHMgdG8gbGlzdGVuLlxyXG4gICAqL1xuICBfYmluZFNjcm9sbFRvRXZlbnRzKCRjb250YWluZXIpIHtcbiAgICBjb25zdCAkcm9vdENvbnRhaW5lciA9ICRjb250YWluZXIgPyAkY29udGFpbmVyIDogdGhpcy5sZW5pc0luc3RhbmNlLnJvb3RFbGVtZW50O1xuICAgIGNvbnN0ICRzY3JvbGxUb0VsZW1lbnRzID0gJHJvb3RDb250YWluZXIgPT0gbnVsbCA/IHZvaWQgMCA6ICRyb290Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNjcm9sbC10b10nKTtcbiAgICAoJHNjcm9sbFRvRWxlbWVudHMgPT0gbnVsbCA/IHZvaWQgMCA6ICRzY3JvbGxUb0VsZW1lbnRzLmxlbmd0aCkgJiYgJHNjcm9sbFRvRWxlbWVudHMuZm9yRWFjaCgkZWwgPT4ge1xuICAgICAgJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25TY3JvbGxUb0JpbmQsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBFdmVudHMgLSBVbnN1YnNjcmliZSBzY3JvbGxUbyBsaXN0ZW5lZCBldmVudHMuXHJcbiAgICovXG4gIF91bmJpbmRTY3JvbGxUb0V2ZW50cygkY29udGFpbmVyKSB7XG4gICAgY29uc3QgJHJvb3RDb250YWluZXIgPSAkY29udGFpbmVyID8gJGNvbnRhaW5lciA6IHRoaXMubGVuaXNJbnN0YW5jZS5yb290RWxlbWVudDtcbiAgICBjb25zdCAkc2Nyb2xsVG9FbGVtZW50cyA9ICRyb290Q29udGFpbmVyID09IG51bGwgPyB2b2lkIDAgOiAkcm9vdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zY3JvbGwtdG9dJyk7XG4gICAgKCRzY3JvbGxUb0VsZW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiAkc2Nyb2xsVG9FbGVtZW50cy5sZW5ndGgpICYmICRzY3JvbGxUb0VsZW1lbnRzLmZvckVhY2goJGVsID0+IHtcbiAgICAgICRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uU2Nyb2xsVG9CaW5kLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgLSBSZXNpemUgY2FsbGJhY2suXHJcbiAgICovXG4gIF9vblJlc2l6ZSgpIHtcbiAgICAvLyBXYWl0aW5nIHRoZSBuZXh0IGZyYW1lIHRvIGdldCB0aGUgbmV3IGN1cnJlbnQgc2Nyb2xsIHZhbHVlIHJldHVybiBieSBMZW5pc1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkY29yZUluc3RhbmNlO1xuICAgICAgKF90aGlzJGNvcmVJbnN0YW5jZSA9IHRoaXMuY29yZUluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29yZUluc3RhbmNlLm9uUmVzaXplKHtcbiAgICAgICAgY3VycmVudFNjcm9sbDogdGhpcy5sZW5pc0luc3RhbmNlLnNjcm9sbFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgLSBSZW5kZXIgY2FsbGJhY2suXHJcbiAgICovXG4gIF9vblJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkbGVuaXNJbnN0YW5jZTIsIF90aGlzJGNvcmVJbnN0YW5jZTI7XG4gICAgKF90aGlzJGxlbmlzSW5zdGFuY2UyID0gdGhpcy5sZW5pc0luc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGVuaXNJbnN0YW5jZTIucmFmKERhdGUubm93KCkpO1xuICAgIChfdGhpcyRjb3JlSW5zdGFuY2UyID0gdGhpcy5jb3JlSW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb3JlSW5zdGFuY2UyLm9uUmVuZGVyKHtcbiAgICAgIGN1cnJlbnRTY3JvbGw6IHRoaXMubGVuaXNJbnN0YW5jZS5zY3JvbGwsXG4gICAgICBzbW9vdGg6IHRoaXMubGVuaXNJbnN0YW5jZS5pc1Ntb290aFxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIC0gU2Nyb2xsIFRvIGNhbGxiYWNrLlxyXG4gICAqL1xuICBfb25TY3JvbGxUbyhldmVudCkge1xuICAgIHZhciBfZXZlbnQkY3VycmVudFRhcmdldDtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0ICR0YXJnZXQgPSAoX2V2ZW50JGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0KSAhPSBudWxsID8gX2V2ZW50JGN1cnJlbnRUYXJnZXQgOiBudWxsO1xuICAgIGlmICghJHRhcmdldCkgcmV0dXJuO1xuICAgIGNvbnN0IHRhcmdldCA9ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC10by1ocmVmJykgfHwgJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICBjb25zdCBvZmZzZXQgPSAkdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtdG8tb2Zmc2V0JykgfHwgMDtcbiAgICBjb25zdCBkdXJhdGlvbiA9ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC10by1kdXJhdGlvbicpIHx8IHRoaXMubGVuaXNPcHRpb25zLmR1cmF0aW9uIHx8IGRlZmF1bHRMZW5pc09wdGlvbnMuZHVyYXRpb247XG4gICAgdGFyZ2V0ICYmIHRoaXMuc2Nyb2xsVG8odGFyZ2V0LCB7XG4gICAgICBvZmZzZXQ6IHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQob2Zmc2V0KSA6IG9mZnNldCxcbiAgICAgIGR1cmF0aW9uOiB0eXBlb2YgZHVyYXRpb24gPT09ICdzdHJpbmcnID8gcGFyc2VJbnQoZHVyYXRpb24pIDogZHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBTdGFydCBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGhhdCBhY3RpdmUgTGVuaXMgc21vb3RoIGFuZCBzY3JvbGwgcHJvZ3Jlc3MuXHJcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLnJhZlBsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yYWZQbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmluaXRDdXN0b21UaWNrZXIgPyB0aGlzLmluaXRDdXN0b21UaWNrZXIodGhpcy5fb25SZW5kZXJCaW5kKSA6IHRoaXMuX3JhZigpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0b3AgUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRoYXQgYWN0aXZlIExlbmlzIHNtb290aCBhbmQgc2Nyb2xsIHByb2dyZXNzLlxyXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICghdGhpcy5yYWZQbGF5aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmFmUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveUN1c3RvbVRpY2tlciA/IHRoaXMuZGVzdHJveUN1c3RvbVRpY2tlcih0aGlzLl9vblJlbmRlckJpbmQpIDogdGhpcy5yYWZJbnN0YW5jZSAmJiBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZkluc3RhbmNlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmUgb2xkIHNjcm9sbCBlbGVtZW50cyBpdGVtcyBhbmQgcmVidWlsZCBTY3JvbGxFbGVtZW50cyBpbnN0YW5jZXMuXHJcbiAgICovXG4gIHJlbW92ZVNjcm9sbEVsZW1lbnRzKCRvbGRDb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXMkY29yZUluc3RhbmNlMztcbiAgICBpZiAoISRvbGRDb250YWluZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgRE9NIEVsZW1lbnQgYXMgJG9sZENvbnRhaW5lcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91bmJpbmRTY3JvbGxUb0V2ZW50cygkb2xkQ29udGFpbmVyKTtcbiAgICAoX3RoaXMkY29yZUluc3RhbmNlMyA9IHRoaXMuY29yZUluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29yZUluc3RhbmNlMy5yZW1vdmVTY3JvbGxFbGVtZW50cygkb2xkQ29udGFpbmVyKTtcbiAgfVxuICAvKipcclxuICAgKiBBZGQgbmV3IHNjcm9sbCBlbGVtZW50cyBpdGVtcyBhbmQgcmVidWlsZCBTY3JvbGxFbGVtZW50cyBpbnN0YW5jZXMuXHJcbiAgICovXG4gIGFkZFNjcm9sbEVsZW1lbnRzKCRuZXdDb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXMkY29yZUluc3RhbmNlNDtcbiAgICBpZiAoISRuZXdDb250YWluZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgRE9NIEVsZW1lbnQgYXMgJG5ld0NvbnRhaW5lcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoX3RoaXMkY29yZUluc3RhbmNlNCA9IHRoaXMuY29yZUluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29yZUluc3RhbmNlNC5hZGRTY3JvbGxFbGVtZW50cygkbmV3Q29udGFpbmVyKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5fYmluZFNjcm9sbFRvRXZlbnRzKCRuZXdDb250YWluZXIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgcmVzaXplIGNhbGxiYWNrLlxyXG4gICAqL1xuICByZXNpemUoKSB7XG4gICAgdGhpcy5fb25SZXNpemVCaW5kKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVHJpZ2dlciBzY3JvbGwgdG8gY2FsbGJhY2suXHJcbiAgICovXG4gIHNjcm9sbFRvKHRhcmdldCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyRsZW5pc0luc3RhbmNlMztcbiAgICAoX3RoaXMkbGVuaXNJbnN0YW5jZTMgPSB0aGlzLmxlbmlzSW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZW5pc0luc3RhbmNlMy5zY3JvbGxUbyh0YXJnZXQsIHtcbiAgICAgIG9mZnNldDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQsXG4gICAgICBsZXJwOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmxlcnAsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIGltbWVkaWF0ZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbW1lZGlhdGUsXG4gICAgICBsb2NrOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2ssXG4gICAgICBmb3JjZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZSxcbiAgICAgIGVhc2luZzogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5lYXNpbmcsXG4gICAgICBvbkNvbXBsZXRlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uQ29tcGxldGVcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGhhdCBhY3RpdmUgTGVuaXMgc21vb3RoIGFuZCBzY3JvbGwgcHJvZ3Jlc3MuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICovXG4gIF9yYWYoKSB7XG4gICAgdGhpcy5fb25SZW5kZXJCaW5kKCk7XG4gICAgdGhpcy5yYWZJbnN0YW5jZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLl9yYWYoKSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgTG9jb21vdGl2ZVNjcm9sbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NvbW90aXZlLXNjcm9sbC5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs\n"));

/***/ })

}]);