"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_sc_client_node_modules_locomotive-scroll_dist_locomotive-scroll_modern_mjs";
exports.ids = ["_sc_client_node_modules_locomotive-scroll_dist_locomotive-scroll_modern_mjs"];
exports.modules = {

/***/ "(sc_client)/./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ l)\n/* harmony export */ });\nfunction t(){return t=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(t[s]=i[s])}return t},t.apply(this,arguments)}function e(t,e,i){return Math.max(t,Math.min(e,i))}class i{advance(t){var i;if(!this.isRunning)return;let s=!1;if(this.lerp)this.value=(1-(o=this.lerp))*this.value+o*this.to,Math.round(this.value)===this.to&&(this.value=this.to,s=!0);else{this.currentTime+=t;const i=e(0,this.currentTime/this.duration,1);s=i>=1;const o=s?1:this.easing(i);this.value=this.from+(this.to-this.from)*o}var o;null==(i=this.onUpdate)||i.call(this,this.value,{completed:s}),s&&this.stop()}stop(){this.isRunning=!1}fromTo(t,e,{lerp:i=.1,duration:s=1,easing:o=(t=>t),onUpdate:n}){this.from=this.value=t,this.to=e,this.lerp=i,this.duration=s,this.easing=o,this.currentTime=0,this.isRunning=!0,this.onUpdate=n}}function s(t,e){let i;return function(){let s=arguments,o=this;clearTimeout(i),i=setTimeout(function(){t.apply(o,s)},e)}}class o{constructor(t,e){this.onWindowResize=()=>{this.width=window.innerWidth,this.height=window.innerHeight},this.onWrapperResize=()=>{this.width=this.wrapper.clientWidth,this.height=this.wrapper.clientHeight},this.onContentResize=()=>{const t=this.wrapper===window?document.documentElement:this.wrapper;this.scrollHeight=t.scrollHeight,this.scrollWidth=t.scrollWidth},this.wrapper=t,this.content=e,this.wrapper===window?(window.addEventListener(\"resize\",this.onWindowResize,!1),this.onWindowResize()):(this.wrapperResizeObserver=new ResizeObserver(s(this.onWrapperResize,100)),this.wrapperResizeObserver.observe(this.wrapper),this.onWrapperResize()),this.contentResizeObserver=new ResizeObserver(s(this.onContentResize,100)),this.contentResizeObserver.observe(this.content),this.onContentResize()}destroy(){var t,e;window.removeEventListener(\"resize\",this.onWindowResize,!1),null==(t=this.wrapperResizeObserver)||t.disconnect(),null==(e=this.contentResizeObserver)||e.disconnect()}get limit(){return{x:this.scrollWidth-this.width,y:this.scrollHeight-this.height}}}let n=()=>({events:{},emit(t,...e){let i=this.events[t]||[];for(let t=0,s=i.length;t<s;t++)i[t](...e)},on(t,e){var i;return(null==(i=this.events[t])?void 0:i.push(e))||(this.events[t]=[e]),()=>{var i;this.events[t]=null==(i=this.events[t])?void 0:i.filter(t=>e!==t)}}});class r{constructor(t,{wheelMultiplier:i=1,touchMultiplier:s=2,normalizeWheel:o=!1}){this.onTouchStart=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:0,y:0}},this.onTouchMove=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t,s=-(e-this.touchStart.x)*this.touchMultiplier,o=-(i-this.touchStart.y)*this.touchMultiplier;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:s,y:o},this.emitter.emit(\"scroll\",{type:\"touch\",deltaX:s,deltaY:o,event:t})},this.onTouchEnd=t=>{this.emitter.emit(\"scroll\",{type:\"touch\",inertia:!0,deltaX:this.lastDelta.x,deltaY:this.lastDelta.y,event:t})},this.onWheel=t=>{let{deltaX:i,deltaY:s}=t;this.normalizeWheel&&(i=e(-100,i,100),s=e(-100,s,100)),i*=this.wheelMultiplier,s*=this.wheelMultiplier,this.emitter.emit(\"scroll\",{type:\"wheel\",deltaX:i,deltaY:s,event:t})},this.element=t,this.wheelMultiplier=i,this.touchMultiplier=s,this.normalizeWheel=o,this.touchStart={x:null,y:null},this.emitter=n(),this.element.addEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.addEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.addEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.addEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}on(t,e){return this.emitter.on(t,e)}destroy(){this.emitter.events={},this.element.removeEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.removeEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.removeEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.removeEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}}class l{constructor({direction:e,gestureDirection:s,mouseMultiplier:l,smooth:h,wrapper:a=window,content:c=document.documentElement,wheelEventsTarget:u=a,smoothWheel:p=null==h||h,smoothTouch:d=!1,syncTouch:m=!1,syncTouchLerp:v=.1,touchInertiaMultiplier:g=35,duration:S,easing:w=(t=>Math.min(1,1.001-Math.pow(2,-10*t))),lerp:f=(S?null:.1),infinite:y=!1,orientation:T=(null!=e?e:\"vertical\"),gestureOrientation:z=(null!=s?s:\"vertical\"),touchMultiplier:M=1,wheelMultiplier:E=(null!=l?l:1),normalizeWheel:L=!1}={}){this.onVirtualScroll=({type:e,inertia:i,deltaX:s,deltaY:o,event:n})=>{if(n.ctrlKey)return;const r=\"touch\"===e,l=\"wheel\"===e;if(\"vertical\"===this.options.gestureOrientation&&0===o||\"horizontal\"===this.options.gestureOrientation&&0===s||r&&\"vertical\"===this.options.gestureOrientation&&0===this.scroll&&!this.options.infinite&&o<=0)return;if(n.composedPath().find(t=>null==t||null==t.hasAttribute?void 0:t.hasAttribute(\"data-lenis-prevent\")))return;if(this.isStopped||this.isLocked)return void n.preventDefault();if(this.isSmooth=(this.options.smoothTouch||this.options.syncTouch)&&r||this.options.smoothWheel&&l,!this.isSmooth)return this.isScrolling=!1,void this.animate.stop();n.preventDefault();let h=o;\"both\"===this.options.gestureOrientation?h=Math.abs(o)>Math.abs(s)?o:s:\"horizontal\"===this.options.gestureOrientation&&(h=s);const a=r&&this.options.syncTouch,c=r&&i&&Math.abs(h)>1;c&&(h=this.velocity*this.options.touchInertiaMultiplier),this.scrollTo(this.targetScroll+h,t({programmatic:!1},a&&{lerp:c?this.syncTouchLerp:.4}))},this.onScroll=()=>{if(!this.isScrolling){const t=this.animatedScroll;this.animatedScroll=this.targetScroll=this.actualScroll,this.velocity=0,this.direction=Math.sign(this.animatedScroll-t),this.emit()}},e&&console.warn(\"Lenis: `direction` option is deprecated, use `orientation` instead\"),s&&console.warn(\"Lenis: `gestureDirection` option is deprecated, use `gestureOrientation` instead\"),l&&console.warn(\"Lenis: `mouseMultiplier` option is deprecated, use `wheelMultiplier` instead\"),h&&console.warn(\"Lenis: `smooth` option is deprecated, use `smoothWheel` instead\"),window.lenisVersion=\"1.0.11\",a!==document.documentElement&&a!==document.body||(a=window),this.options={wrapper:a,content:c,wheelEventsTarget:u,smoothWheel:p,smoothTouch:d,syncTouch:m,syncTouchLerp:v,touchInertiaMultiplier:g,duration:S,easing:w,lerp:f,infinite:y,gestureOrientation:z,orientation:T,touchMultiplier:M,wheelMultiplier:E,normalizeWheel:L},this.dimensions=new o(a,c),this.rootElement.classList.add(\"lenis\"),this.velocity=0,this.isStopped=!1,this.isSmooth=p||d,this.isScrolling=!1,this.targetScroll=this.animatedScroll=this.actualScroll,this.animate=new i,this.emitter=n(),this.options.wrapper.addEventListener(\"scroll\",this.onScroll,{passive:!1}),this.virtualScroll=new r(u,{touchMultiplier:M,wheelMultiplier:E,normalizeWheel:L}),this.virtualScroll.on(\"scroll\",this.onVirtualScroll)}destroy(){this.emitter.events={},this.options.wrapper.removeEventListener(\"scroll\",this.onScroll,{passive:!1}),this.virtualScroll.destroy()}on(t,e){return this.emitter.on(t,e)}off(t,e){var i;this.emitter.events[t]=null==(i=this.emitter.events[t])?void 0:i.filter(t=>e!==t)}setScroll(t){this.isHorizontal?this.rootElement.scrollLeft=t:this.rootElement.scrollTop=t}emit(){this.emitter.emit(\"scroll\",this)}reset(){this.isLocked=!1,this.isScrolling=!1,this.velocity=0,this.animate.stop()}start(){this.isStopped=!1,this.reset()}stop(){this.isStopped=!0,this.animate.stop(),this.reset()}raf(t){const e=t-(this.time||t);this.time=t,this.animate.advance(.001*e)}scrollTo(t,{offset:i=0,immediate:s=!1,lock:o=!1,duration:n=this.options.duration,easing:r=this.options.easing,lerp:l=!n&&this.options.lerp,onComplete:h=null,force:a=!1,programmatic:c=!0}={}){if(!this.isStopped||a){if([\"top\",\"left\",\"start\"].includes(t))t=0;else if([\"bottom\",\"right\",\"end\"].includes(t))t=this.limit;else{var u;let e;if(\"string\"==typeof t?e=document.querySelector(t):null!=(u=t)&&u.nodeType&&(e=t),e){if(this.options.wrapper!==window){const t=this.options.wrapper.getBoundingClientRect();i-=this.isHorizontal?t.left:t.top}const s=e.getBoundingClientRect();t=(this.isHorizontal?s.left:s.top)+this.animatedScroll}}if(\"number\"==typeof t){if(t+=i,t=Math.round(t),this.options.infinite?c&&(this.targetScroll=this.animatedScroll=this.scroll):t=e(0,t,this.limit),s)return this.animatedScroll=this.targetScroll=t,this.setScroll(this.scroll),this.reset(),this.emit(),void(null==h||h());if(!c){if(t===this.targetScroll)return;this.targetScroll=t}this.animate.fromTo(this.animatedScroll,t,{duration:n,easing:r,lerp:l,onUpdate:(t,{completed:e})=>{o&&(this.isLocked=!0),this.isScrolling=!0,this.velocity=t-this.animatedScroll,this.direction=Math.sign(this.velocity),this.animatedScroll=t,this.setScroll(this.scroll),c&&(this.targetScroll=t),e&&(o&&(this.isLocked=!1),requestAnimationFrame(()=>{this.isScrolling=!1}),this.velocity=0,null==h||h()),this.emit()}})}}}get rootElement(){return this.options.wrapper===window?this.options.content:this.options.wrapper}get limit(){return this.isHorizontal?this.dimensions.limit.x:this.dimensions.limit.y}get isHorizontal(){return\"horizontal\"===this.options.orientation}get actualScroll(){return this.isHorizontal?this.rootElement.scrollLeft:this.rootElement.scrollTop}get scroll(){return this.options.infinite?function(t,e){let i=t%e;return(e>0&&i<0||e<0&&i>0)&&(i+=e),i}(this.animatedScroll,this.limit):this.animatedScroll}get progress(){return 0===this.limit?1:this.scroll/this.limit}get isSmooth(){return this.__isSmooth}set isSmooth(t){this.__isSmooth!==t&&(this.rootElement.classList.toggle(\"lenis-smooth\",t),this.__isSmooth=t)}get isScrolling(){return this.__isScrolling}set isScrolling(t){this.__isScrolling!==t&&(this.rootElement.classList.toggle(\"lenis-scrolling\",t),this.__isScrolling=t)}get isStopped(){return this.__isStopped}set isStopped(t){this.__isStopped!==t&&(this.rootElement.classList.toggle(\"lenis-stopped\",t),this.__isStopped=t)}}\n//# sourceMappingURL=lenis.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvQHN0dWRpby1mcmVpZ2h0L2xlbmlzL2Rpc3QvbGVuaXMubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsYUFBYSx3REFBd0QsWUFBWSxtQkFBbUIsS0FBSyxtQkFBbUIsc0VBQXNFLFNBQVMseUJBQXlCLGtCQUFrQixpQ0FBaUMsUUFBUSxXQUFXLE1BQU0sMEJBQTBCLFNBQVMsMkhBQTJILEtBQUssb0JBQW9CLDhDQUE4QyxPQUFPLDJCQUEyQiwyQ0FBMkMsTUFBTSxpREFBaUQsWUFBWSxpQkFBaUIsT0FBTyxrQkFBa0IsWUFBWSxrREFBa0QsRUFBRSxpSUFBaUksZ0JBQWdCLE1BQU0sa0JBQWtCLHVCQUF1Qix3Q0FBd0MsYUFBYSxLQUFLLFFBQVEsaUJBQWlCLHlCQUF5Qiw0REFBNEQsMkJBQTJCLDBFQUEwRSwyQkFBMkIsb0VBQW9FLGdFQUFnRSw4YUFBOGEsVUFBVSxRQUFRLHNLQUFzSyxZQUFZLE9BQU8sZ0VBQWdFLFlBQVksU0FBUyxjQUFjLHlCQUF5Qix1QkFBdUIsSUFBSSxlQUFlLFNBQVMsTUFBTSw2RUFBNkUsTUFBTSxvRUFBb0UsRUFBRSxRQUFRLGVBQWUsNERBQTRELEVBQUUsc0JBQXNCLE1BQU0sb0JBQW9CLHNDQUFzQyx3REFBd0QsU0FBUyxzQkFBc0IsTUFBTSxvQkFBb0Isa0lBQWtJLHdEQUF3RCxRQUFRLDZCQUE2Qix1Q0FBdUMsRUFBRSxxQkFBcUIsNEJBQTRCLGdGQUFnRixFQUFFLGtCQUFrQixJQUFJLGtCQUFrQixHQUFHLG1JQUFtSSx1Q0FBdUMsRUFBRSxxR0FBcUcsY0FBYyxzRUFBc0UsV0FBVyxnRUFBZ0UsV0FBVyw4REFBOEQsV0FBVyw0REFBNEQsV0FBVyxFQUFFLFFBQVEsNEJBQTRCLFVBQVUsc0JBQXNCLHdEQUF3RCxXQUFXLG1FQUFtRSxXQUFXLGlFQUFpRSxXQUFXLCtEQUErRCxXQUFXLEdBQUcsUUFBUSxhQUFhLG1lQUFtZSxHQUFHLEVBQUUsdUJBQXVCLDJDQUEyQyxJQUFJLG9CQUFvQixrQ0FBa0MscU5BQXFOLDhHQUE4RyxnRUFBZ0UsdUtBQXVLLG1CQUFtQixRQUFRLDZIQUE2SCx3REFBd0QsOEZBQThGLGdCQUFnQixLQUFLLDZCQUE2QixHQUFHLG9CQUFvQixzQkFBc0IsNEJBQTRCLHFJQUFxSSxxZEFBcWQsdVBBQXVQLHVTQUF1UyxXQUFXLDhCQUE4QixxREFBcUQsdURBQXVELFVBQVUsc0JBQXNCLGtFQUFrRSxXQUFXLCtCQUErQixRQUFRLDRCQUE0QixTQUFTLE1BQU0sa0ZBQWtGLGFBQWEsNkVBQTZFLE9BQU8saUNBQWlDLFFBQVEseUVBQXlFLFFBQVEsK0JBQStCLE9BQU8sbURBQW1ELE9BQU8seUJBQXlCLHlDQUF5QyxZQUFZLDhLQUE4SyxHQUFHLEVBQUUsdUJBQXVCLDBDQUEwQywwREFBMEQsS0FBSyxNQUFNLE1BQU0sb0ZBQW9GLGtDQUFrQyxxREFBcUQsa0NBQWtDLGtDQUFrQyx3REFBd0QsdUJBQXVCLGtQQUFrUCxPQUFPLGdDQUFnQyxvQkFBb0IsMkNBQTJDLHdDQUF3QyxZQUFZLElBQUksc1BBQXNQLG9CQUFvQiw2Q0FBNkMsSUFBSSxrQkFBa0IsK0VBQStFLFlBQVkseUVBQXlFLG1CQUFtQiw4Q0FBOEMsbUJBQW1CLGdGQUFnRixhQUFhLDJDQUEyQyxVQUFVLHFDQUFxQyxxREFBcUQsZUFBZSwrQ0FBK0MsZUFBZSx1QkFBdUIsZ0JBQWdCLDZGQUE2RixrQkFBa0IsMEJBQTBCLG1CQUFtQixzR0FBc0csZ0JBQWdCLHdCQUF3QixpQkFBaUIsaUdBQXNIO0FBQ3J5VCIsInNvdXJjZXMiOlsid2VicGFjazovL3Ntb290aC1zY3JvbGwtdjIvLi9ub2RlX21vZHVsZXMvQHN0dWRpby1mcmVpZ2h0L2xlbmlzL2Rpc3QvbGVuaXMubW9kZXJuLm1qcz80N2ZiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHQoKXtyZXR1cm4gdD1PYmplY3QuYXNzaWduP09iamVjdC5hc3NpZ24uYmluZCgpOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBpPWFyZ3VtZW50c1tlXTtmb3IodmFyIHMgaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxzKSYmKHRbc109aVtzXSl9cmV0dXJuIHR9LHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGUodCxlLGkpe3JldHVybiBNYXRoLm1heCh0LE1hdGgubWluKGUsaSkpfWNsYXNzIGl7YWR2YW5jZSh0KXt2YXIgaTtpZighdGhpcy5pc1J1bm5pbmcpcmV0dXJuO2xldCBzPSExO2lmKHRoaXMubGVycCl0aGlzLnZhbHVlPSgxLShvPXRoaXMubGVycCkpKnRoaXMudmFsdWUrbyp0aGlzLnRvLE1hdGgucm91bmQodGhpcy52YWx1ZSk9PT10aGlzLnRvJiYodGhpcy52YWx1ZT10aGlzLnRvLHM9ITApO2Vsc2V7dGhpcy5jdXJyZW50VGltZSs9dDtjb25zdCBpPWUoMCx0aGlzLmN1cnJlbnRUaW1lL3RoaXMuZHVyYXRpb24sMSk7cz1pPj0xO2NvbnN0IG89cz8xOnRoaXMuZWFzaW5nKGkpO3RoaXMudmFsdWU9dGhpcy5mcm9tKyh0aGlzLnRvLXRoaXMuZnJvbSkqb312YXIgbztudWxsPT0oaT10aGlzLm9uVXBkYXRlKXx8aS5jYWxsKHRoaXMsdGhpcy52YWx1ZSx7Y29tcGxldGVkOnN9KSxzJiZ0aGlzLnN0b3AoKX1zdG9wKCl7dGhpcy5pc1J1bm5pbmc9ITF9ZnJvbVRvKHQsZSx7bGVycDppPS4xLGR1cmF0aW9uOnM9MSxlYXNpbmc6bz0odD0+dCksb25VcGRhdGU6bn0pe3RoaXMuZnJvbT10aGlzLnZhbHVlPXQsdGhpcy50bz1lLHRoaXMubGVycD1pLHRoaXMuZHVyYXRpb249cyx0aGlzLmVhc2luZz1vLHRoaXMuY3VycmVudFRpbWU9MCx0aGlzLmlzUnVubmluZz0hMCx0aGlzLm9uVXBkYXRlPW59fWZ1bmN0aW9uIHModCxlKXtsZXQgaTtyZXR1cm4gZnVuY3Rpb24oKXtsZXQgcz1hcmd1bWVudHMsbz10aGlzO2NsZWFyVGltZW91dChpKSxpPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LmFwcGx5KG8scyl9LGUpfX1jbGFzcyBve2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5vbldpbmRvd1Jlc2l6ZT0oKT0+e3RoaXMud2lkdGg9d2luZG93LmlubmVyV2lkdGgsdGhpcy5oZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0fSx0aGlzLm9uV3JhcHBlclJlc2l6ZT0oKT0+e3RoaXMud2lkdGg9dGhpcy53cmFwcGVyLmNsaWVudFdpZHRoLHRoaXMuaGVpZ2h0PXRoaXMud3JhcHBlci5jbGllbnRIZWlnaHR9LHRoaXMub25Db250ZW50UmVzaXplPSgpPT57Y29uc3QgdD10aGlzLndyYXBwZXI9PT13aW5kb3c/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OnRoaXMud3JhcHBlcjt0aGlzLnNjcm9sbEhlaWdodD10LnNjcm9sbEhlaWdodCx0aGlzLnNjcm9sbFdpZHRoPXQuc2Nyb2xsV2lkdGh9LHRoaXMud3JhcHBlcj10LHRoaXMuY29udGVudD1lLHRoaXMud3JhcHBlcj09PXdpbmRvdz8od2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLm9uV2luZG93UmVzaXplLCExKSx0aGlzLm9uV2luZG93UmVzaXplKCkpOih0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlcj1uZXcgUmVzaXplT2JzZXJ2ZXIocyh0aGlzLm9uV3JhcHBlclJlc2l6ZSwxMDApKSx0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMud3JhcHBlciksdGhpcy5vbldyYXBwZXJSZXNpemUoKSksdGhpcy5jb250ZW50UmVzaXplT2JzZXJ2ZXI9bmV3IFJlc2l6ZU9ic2VydmVyKHModGhpcy5vbkNvbnRlbnRSZXNpemUsMTAwKSksdGhpcy5jb250ZW50UmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNvbnRlbnQpLHRoaXMub25Db250ZW50UmVzaXplKCl9ZGVzdHJveSgpe3ZhciB0LGU7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLm9uV2luZG93UmVzaXplLCExKSxudWxsPT0odD10aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlcil8fHQuZGlzY29ubmVjdCgpLG51bGw9PShlPXRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyKXx8ZS5kaXNjb25uZWN0KCl9Z2V0IGxpbWl0KCl7cmV0dXJue3g6dGhpcy5zY3JvbGxXaWR0aC10aGlzLndpZHRoLHk6dGhpcy5zY3JvbGxIZWlnaHQtdGhpcy5oZWlnaHR9fX1sZXQgbj0oKT0+KHtldmVudHM6e30sZW1pdCh0LC4uLmUpe2xldCBpPXRoaXMuZXZlbnRzW3RdfHxbXTtmb3IobGV0IHQ9MCxzPWkubGVuZ3RoO3Q8czt0KyspaVt0XSguLi5lKX0sb24odCxlKXt2YXIgaTtyZXR1cm4obnVsbD09KGk9dGhpcy5ldmVudHNbdF0pP3ZvaWQgMDppLnB1c2goZSkpfHwodGhpcy5ldmVudHNbdF09W2VdKSwoKT0+e3ZhciBpO3RoaXMuZXZlbnRzW3RdPW51bGw9PShpPXRoaXMuZXZlbnRzW3RdKT92b2lkIDA6aS5maWx0ZXIodD0+ZSE9PXQpfX19KTtjbGFzcyBye2NvbnN0cnVjdG9yKHQse3doZWVsTXVsdGlwbGllcjppPTEsdG91Y2hNdWx0aXBsaWVyOnM9Mixub3JtYWxpemVXaGVlbDpvPSExfSl7dGhpcy5vblRvdWNoU3RhcnQ9dD0+e2NvbnN0e2NsaWVudFg6ZSxjbGllbnRZOml9PXQudGFyZ2V0VG91Y2hlcz90LnRhcmdldFRvdWNoZXNbMF06dDt0aGlzLnRvdWNoU3RhcnQueD1lLHRoaXMudG91Y2hTdGFydC55PWksdGhpcy5sYXN0RGVsdGE9e3g6MCx5OjB9fSx0aGlzLm9uVG91Y2hNb3ZlPXQ9Pntjb25zdHtjbGllbnRYOmUsY2xpZW50WTppfT10LnRhcmdldFRvdWNoZXM/dC50YXJnZXRUb3VjaGVzWzBdOnQscz0tKGUtdGhpcy50b3VjaFN0YXJ0LngpKnRoaXMudG91Y2hNdWx0aXBsaWVyLG89LShpLXRoaXMudG91Y2hTdGFydC55KSp0aGlzLnRvdWNoTXVsdGlwbGllcjt0aGlzLnRvdWNoU3RhcnQueD1lLHRoaXMudG91Y2hTdGFydC55PWksdGhpcy5sYXN0RGVsdGE9e3g6cyx5Om99LHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIse3R5cGU6XCJ0b3VjaFwiLGRlbHRhWDpzLGRlbHRhWTpvLGV2ZW50OnR9KX0sdGhpcy5vblRvdWNoRW5kPXQ9Pnt0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHt0eXBlOlwidG91Y2hcIixpbmVydGlhOiEwLGRlbHRhWDp0aGlzLmxhc3REZWx0YS54LGRlbHRhWTp0aGlzLmxhc3REZWx0YS55LGV2ZW50OnR9KX0sdGhpcy5vbldoZWVsPXQ9PntsZXR7ZGVsdGFYOmksZGVsdGFZOnN9PXQ7dGhpcy5ub3JtYWxpemVXaGVlbCYmKGk9ZSgtMTAwLGksMTAwKSxzPWUoLTEwMCxzLDEwMCkpLGkqPXRoaXMud2hlZWxNdWx0aXBsaWVyLHMqPXRoaXMud2hlZWxNdWx0aXBsaWVyLHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIse3R5cGU6XCJ3aGVlbFwiLGRlbHRhWDppLGRlbHRhWTpzLGV2ZW50OnR9KX0sdGhpcy5lbGVtZW50PXQsdGhpcy53aGVlbE11bHRpcGxpZXI9aSx0aGlzLnRvdWNoTXVsdGlwbGllcj1zLHRoaXMubm9ybWFsaXplV2hlZWw9byx0aGlzLnRvdWNoU3RhcnQ9e3g6bnVsbCx5Om51bGx9LHRoaXMuZW1pdHRlcj1uKCksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHRoaXMub25XaGVlbCx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMub25Ub3VjaFN0YXJ0LHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLm9uVG91Y2hNb3ZlLHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMub25Ub3VjaEVuZCx7cGFzc2l2ZTohMX0pfW9uKHQsZSl7cmV0dXJuIHRoaXMuZW1pdHRlci5vbih0LGUpfWRlc3Ryb3koKXt0aGlzLmVtaXR0ZXIuZXZlbnRzPXt9LHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIix0aGlzLm9uV2hlZWwse3Bhc3NpdmU6ITF9KSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLm9uVG91Y2hTdGFydCx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5vblRvdWNoTW92ZSx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm9uVG91Y2hFbmQse3Bhc3NpdmU6ITF9KX19Y2xhc3MgbHtjb25zdHJ1Y3Rvcih7ZGlyZWN0aW9uOmUsZ2VzdHVyZURpcmVjdGlvbjpzLG1vdXNlTXVsdGlwbGllcjpsLHNtb290aDpoLHdyYXBwZXI6YT13aW5kb3csY29udGVudDpjPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCx3aGVlbEV2ZW50c1RhcmdldDp1PWEsc21vb3RoV2hlZWw6cD1udWxsPT1ofHxoLHNtb290aFRvdWNoOmQ9ITEsc3luY1RvdWNoOm09ITEsc3luY1RvdWNoTGVycDp2PS4xLHRvdWNoSW5lcnRpYU11bHRpcGxpZXI6Zz0zNSxkdXJhdGlvbjpTLGVhc2luZzp3PSh0PT5NYXRoLm1pbigxLDEuMDAxLU1hdGgucG93KDIsLTEwKnQpKSksbGVycDpmPShTP251bGw6LjEpLGluZmluaXRlOnk9ITEsb3JpZW50YXRpb246VD0obnVsbCE9ZT9lOlwidmVydGljYWxcIiksZ2VzdHVyZU9yaWVudGF0aW9uOno9KG51bGwhPXM/czpcInZlcnRpY2FsXCIpLHRvdWNoTXVsdGlwbGllcjpNPTEsd2hlZWxNdWx0aXBsaWVyOkU9KG51bGwhPWw/bDoxKSxub3JtYWxpemVXaGVlbDpMPSExfT17fSl7dGhpcy5vblZpcnR1YWxTY3JvbGw9KHt0eXBlOmUsaW5lcnRpYTppLGRlbHRhWDpzLGRlbHRhWTpvLGV2ZW50Om59KT0+e2lmKG4uY3RybEtleSlyZXR1cm47Y29uc3Qgcj1cInRvdWNoXCI9PT1lLGw9XCJ3aGVlbFwiPT09ZTtpZihcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uJiYwPT09b3x8XCJob3Jpem9udGFsXCI9PT10aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uJiYwPT09c3x8ciYmXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmMD09PXRoaXMuc2Nyb2xsJiYhdGhpcy5vcHRpb25zLmluZmluaXRlJiZvPD0wKXJldHVybjtpZihuLmNvbXBvc2VkUGF0aCgpLmZpbmQodD0+bnVsbD09dHx8bnVsbD09dC5oYXNBdHRyaWJ1dGU/dm9pZCAwOnQuaGFzQXR0cmlidXRlKFwiZGF0YS1sZW5pcy1wcmV2ZW50XCIpKSlyZXR1cm47aWYodGhpcy5pc1N0b3BwZWR8fHRoaXMuaXNMb2NrZWQpcmV0dXJuIHZvaWQgbi5wcmV2ZW50RGVmYXVsdCgpO2lmKHRoaXMuaXNTbW9vdGg9KHRoaXMub3B0aW9ucy5zbW9vdGhUb3VjaHx8dGhpcy5vcHRpb25zLnN5bmNUb3VjaCkmJnJ8fHRoaXMub3B0aW9ucy5zbW9vdGhXaGVlbCYmbCwhdGhpcy5pc1Ntb290aClyZXR1cm4gdGhpcy5pc1Njcm9sbGluZz0hMSx2b2lkIHRoaXMuYW5pbWF0ZS5zdG9wKCk7bi5wcmV2ZW50RGVmYXVsdCgpO2xldCBoPW87XCJib3RoXCI9PT10aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uP2g9TWF0aC5hYnMobyk+TWF0aC5hYnMocyk/bzpzOlwiaG9yaXpvbnRhbFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmKGg9cyk7Y29uc3QgYT1yJiZ0aGlzLm9wdGlvbnMuc3luY1RvdWNoLGM9ciYmaSYmTWF0aC5hYnMoaCk+MTtjJiYoaD10aGlzLnZlbG9jaXR5KnRoaXMub3B0aW9ucy50b3VjaEluZXJ0aWFNdWx0aXBsaWVyKSx0aGlzLnNjcm9sbFRvKHRoaXMudGFyZ2V0U2Nyb2xsK2gsdCh7cHJvZ3JhbW1hdGljOiExfSxhJiZ7bGVycDpjP3RoaXMuc3luY1RvdWNoTGVycDouNH0pKX0sdGhpcy5vblNjcm9sbD0oKT0+e2lmKCF0aGlzLmlzU2Nyb2xsaW5nKXtjb25zdCB0PXRoaXMuYW5pbWF0ZWRTY3JvbGw7dGhpcy5hbmltYXRlZFNjcm9sbD10aGlzLnRhcmdldFNjcm9sbD10aGlzLmFjdHVhbFNjcm9sbCx0aGlzLnZlbG9jaXR5PTAsdGhpcy5kaXJlY3Rpb249TWF0aC5zaWduKHRoaXMuYW5pbWF0ZWRTY3JvbGwtdCksdGhpcy5lbWl0KCl9fSxlJiZjb25zb2xlLndhcm4oXCJMZW5pczogYGRpcmVjdGlvbmAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHVzZSBgb3JpZW50YXRpb25gIGluc3RlYWRcIikscyYmY29uc29sZS53YXJuKFwiTGVuaXM6IGBnZXN0dXJlRGlyZWN0aW9uYCBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIGBnZXN0dXJlT3JpZW50YXRpb25gIGluc3RlYWRcIiksbCYmY29uc29sZS53YXJuKFwiTGVuaXM6IGBtb3VzZU11bHRpcGxpZXJgIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgYHdoZWVsTXVsdGlwbGllcmAgaW5zdGVhZFwiKSxoJiZjb25zb2xlLndhcm4oXCJMZW5pczogYHNtb290aGAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHVzZSBgc21vb3RoV2hlZWxgIGluc3RlYWRcIiksd2luZG93LmxlbmlzVmVyc2lvbj1cIjEuMC4xMVwiLGEhPT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJmEhPT1kb2N1bWVudC5ib2R5fHwoYT13aW5kb3cpLHRoaXMub3B0aW9ucz17d3JhcHBlcjphLGNvbnRlbnQ6Yyx3aGVlbEV2ZW50c1RhcmdldDp1LHNtb290aFdoZWVsOnAsc21vb3RoVG91Y2g6ZCxzeW5jVG91Y2g6bSxzeW5jVG91Y2hMZXJwOnYsdG91Y2hJbmVydGlhTXVsdGlwbGllcjpnLGR1cmF0aW9uOlMsZWFzaW5nOncsbGVycDpmLGluZmluaXRlOnksZ2VzdHVyZU9yaWVudGF0aW9uOnosb3JpZW50YXRpb246VCx0b3VjaE11bHRpcGxpZXI6TSx3aGVlbE11bHRpcGxpZXI6RSxub3JtYWxpemVXaGVlbDpMfSx0aGlzLmRpbWVuc2lvbnM9bmV3IG8oYSxjKSx0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJsZW5pc1wiKSx0aGlzLnZlbG9jaXR5PTAsdGhpcy5pc1N0b3BwZWQ9ITEsdGhpcy5pc1Ntb290aD1wfHxkLHRoaXMuaXNTY3JvbGxpbmc9ITEsdGhpcy50YXJnZXRTY3JvbGw9dGhpcy5hbmltYXRlZFNjcm9sbD10aGlzLmFjdHVhbFNjcm9sbCx0aGlzLmFuaW1hdGU9bmV3IGksdGhpcy5lbWl0dGVyPW4oKSx0aGlzLm9wdGlvbnMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbCx7cGFzc2l2ZTohMX0pLHRoaXMudmlydHVhbFNjcm9sbD1uZXcgcih1LHt0b3VjaE11bHRpcGxpZXI6TSx3aGVlbE11bHRpcGxpZXI6RSxub3JtYWxpemVXaGVlbDpMfSksdGhpcy52aXJ0dWFsU2Nyb2xsLm9uKFwic2Nyb2xsXCIsdGhpcy5vblZpcnR1YWxTY3JvbGwpfWRlc3Ryb3koKXt0aGlzLmVtaXR0ZXIuZXZlbnRzPXt9LHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLm9uU2Nyb2xsLHtwYXNzaXZlOiExfSksdGhpcy52aXJ0dWFsU2Nyb2xsLmRlc3Ryb3koKX1vbih0LGUpe3JldHVybiB0aGlzLmVtaXR0ZXIub24odCxlKX1vZmYodCxlKXt2YXIgaTt0aGlzLmVtaXR0ZXIuZXZlbnRzW3RdPW51bGw9PShpPXRoaXMuZW1pdHRlci5ldmVudHNbdF0pP3ZvaWQgMDppLmZpbHRlcih0PT5lIT09dCl9c2V0U2Nyb2xsKHQpe3RoaXMuaXNIb3Jpem9udGFsP3RoaXMucm9vdEVsZW1lbnQuc2Nyb2xsTGVmdD10OnRoaXMucm9vdEVsZW1lbnQuc2Nyb2xsVG9wPXR9ZW1pdCgpe3RoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsdGhpcyl9cmVzZXQoKXt0aGlzLmlzTG9ja2VkPSExLHRoaXMuaXNTY3JvbGxpbmc9ITEsdGhpcy52ZWxvY2l0eT0wLHRoaXMuYW5pbWF0ZS5zdG9wKCl9c3RhcnQoKXt0aGlzLmlzU3RvcHBlZD0hMSx0aGlzLnJlc2V0KCl9c3RvcCgpe3RoaXMuaXNTdG9wcGVkPSEwLHRoaXMuYW5pbWF0ZS5zdG9wKCksdGhpcy5yZXNldCgpfXJhZih0KXtjb25zdCBlPXQtKHRoaXMudGltZXx8dCk7dGhpcy50aW1lPXQsdGhpcy5hbmltYXRlLmFkdmFuY2UoLjAwMSplKX1zY3JvbGxUbyh0LHtvZmZzZXQ6aT0wLGltbWVkaWF0ZTpzPSExLGxvY2s6bz0hMSxkdXJhdGlvbjpuPXRoaXMub3B0aW9ucy5kdXJhdGlvbixlYXNpbmc6cj10aGlzLm9wdGlvbnMuZWFzaW5nLGxlcnA6bD0hbiYmdGhpcy5vcHRpb25zLmxlcnAsb25Db21wbGV0ZTpoPW51bGwsZm9yY2U6YT0hMSxwcm9ncmFtbWF0aWM6Yz0hMH09e30pe2lmKCF0aGlzLmlzU3RvcHBlZHx8YSl7aWYoW1widG9wXCIsXCJsZWZ0XCIsXCJzdGFydFwiXS5pbmNsdWRlcyh0KSl0PTA7ZWxzZSBpZihbXCJib3R0b21cIixcInJpZ2h0XCIsXCJlbmRcIl0uaW5jbHVkZXModCkpdD10aGlzLmxpbWl0O2Vsc2V7dmFyIHU7bGV0IGU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQ/ZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpOm51bGwhPSh1PXQpJiZ1Lm5vZGVUeXBlJiYoZT10KSxlKXtpZih0aGlzLm9wdGlvbnMud3JhcHBlciE9PXdpbmRvdyl7Y29uc3QgdD10aGlzLm9wdGlvbnMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpLT10aGlzLmlzSG9yaXpvbnRhbD90LmxlZnQ6dC50b3B9Y29uc3Qgcz1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Q9KHRoaXMuaXNIb3Jpem9udGFsP3MubGVmdDpzLnRvcCkrdGhpcy5hbmltYXRlZFNjcm9sbH19aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2lmKHQrPWksdD1NYXRoLnJvdW5kKHQpLHRoaXMub3B0aW9ucy5pbmZpbml0ZT9jJiYodGhpcy50YXJnZXRTY3JvbGw9dGhpcy5hbmltYXRlZFNjcm9sbD10aGlzLnNjcm9sbCk6dD1lKDAsdCx0aGlzLmxpbWl0KSxzKXJldHVybiB0aGlzLmFuaW1hdGVkU2Nyb2xsPXRoaXMudGFyZ2V0U2Nyb2xsPXQsdGhpcy5zZXRTY3JvbGwodGhpcy5zY3JvbGwpLHRoaXMucmVzZXQoKSx0aGlzLmVtaXQoKSx2b2lkKG51bGw9PWh8fGgoKSk7aWYoIWMpe2lmKHQ9PT10aGlzLnRhcmdldFNjcm9sbClyZXR1cm47dGhpcy50YXJnZXRTY3JvbGw9dH10aGlzLmFuaW1hdGUuZnJvbVRvKHRoaXMuYW5pbWF0ZWRTY3JvbGwsdCx7ZHVyYXRpb246bixlYXNpbmc6cixsZXJwOmwsb25VcGRhdGU6KHQse2NvbXBsZXRlZDplfSk9PntvJiYodGhpcy5pc0xvY2tlZD0hMCksdGhpcy5pc1Njcm9sbGluZz0hMCx0aGlzLnZlbG9jaXR5PXQtdGhpcy5hbmltYXRlZFNjcm9sbCx0aGlzLmRpcmVjdGlvbj1NYXRoLnNpZ24odGhpcy52ZWxvY2l0eSksdGhpcy5hbmltYXRlZFNjcm9sbD10LHRoaXMuc2V0U2Nyb2xsKHRoaXMuc2Nyb2xsKSxjJiYodGhpcy50YXJnZXRTY3JvbGw9dCksZSYmKG8mJih0aGlzLmlzTG9ja2VkPSExKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9Pnt0aGlzLmlzU2Nyb2xsaW5nPSExfSksdGhpcy52ZWxvY2l0eT0wLG51bGw9PWh8fGgoKSksdGhpcy5lbWl0KCl9fSl9fX1nZXQgcm9vdEVsZW1lbnQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLndyYXBwZXI9PT13aW5kb3c/dGhpcy5vcHRpb25zLmNvbnRlbnQ6dGhpcy5vcHRpb25zLndyYXBwZXJ9Z2V0IGxpbWl0KCl7cmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsP3RoaXMuZGltZW5zaW9ucy5saW1pdC54OnRoaXMuZGltZW5zaW9ucy5saW1pdC55fWdldCBpc0hvcml6b250YWwoKXtyZXR1cm5cImhvcml6b250YWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbn1nZXQgYWN0dWFsU2Nyb2xsKCl7cmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsP3RoaXMucm9vdEVsZW1lbnQuc2Nyb2xsTGVmdDp0aGlzLnJvb3RFbGVtZW50LnNjcm9sbFRvcH1nZXQgc2Nyb2xsKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5pbmZpbml0ZT9mdW5jdGlvbih0LGUpe2xldCBpPXQlZTtyZXR1cm4oZT4wJiZpPDB8fGU8MCYmaT4wKSYmKGkrPWUpLGl9KHRoaXMuYW5pbWF0ZWRTY3JvbGwsdGhpcy5saW1pdCk6dGhpcy5hbmltYXRlZFNjcm9sbH1nZXQgcHJvZ3Jlc3MoKXtyZXR1cm4gMD09PXRoaXMubGltaXQ/MTp0aGlzLnNjcm9sbC90aGlzLmxpbWl0fWdldCBpc1Ntb290aCgpe3JldHVybiB0aGlzLl9faXNTbW9vdGh9c2V0IGlzU21vb3RoKHQpe3RoaXMuX19pc1Ntb290aCE9PXQmJih0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJsZW5pcy1zbW9vdGhcIix0KSx0aGlzLl9faXNTbW9vdGg9dCl9Z2V0IGlzU2Nyb2xsaW5nKCl7cmV0dXJuIHRoaXMuX19pc1Njcm9sbGluZ31zZXQgaXNTY3JvbGxpbmcodCl7dGhpcy5fX2lzU2Nyb2xsaW5nIT09dCYmKHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImxlbmlzLXNjcm9sbGluZ1wiLHQpLHRoaXMuX19pc1Njcm9sbGluZz10KX1nZXQgaXNTdG9wcGVkKCl7cmV0dXJuIHRoaXMuX19pc1N0b3BwZWR9c2V0IGlzU3RvcHBlZCh0KXt0aGlzLl9faXNTdG9wcGVkIT09dCYmKHRoaXMucm9vdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImxlbmlzLXN0b3BwZWRcIix0KSx0aGlzLl9faXNTdG9wcGVkPXQpfX1leHBvcnR7bCBhcyBkZWZhdWx0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlbmlzLm1vZGVybi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs\n");

/***/ }),

/***/ "(sc_client)/./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocomotiveScroll)\n/* harmony export */ });\n/* harmony import */ var _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @studio-freight/lenis */ \"(sc_client)/./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs\");\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\r\n * Intersection Observer\r\n *\r\n * Detecting visibility of an element in the viewport.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger inview/outOfView callbacks\r\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\r\n */\nclass IO {\n  constructor({\n    scrollElements,\n    rootMargin = '-1px -1px -1px -1px',\n    IORaf\n  }) {\n    this.scrollElements = void 0;\n    this.rootMargin = void 0;\n    this.IORaf = void 0;\n    this.observer = void 0;\n    // Parameters\n    this.scrollElements = scrollElements;\n    this.rootMargin = rootMargin;\n    this.IORaf = IORaf;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize Intersection Observer.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    // Options\n    const observerOptions = {\n      rootMargin: this.rootMargin\n    };\n    // Callback\n    const onIntersect = entries => {\n      entries.forEach(entry => {\n        const $targetItem = this.scrollElements.find(item => item.$el === entry.target);\n        if (entry.isIntersecting) {\n          $targetItem && ($targetItem.isAlreadyIntersected = true);\n          this._setInview(entry);\n        } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n          this._setOutOfView(entry);\n        }\n      });\n    };\n    // Instance\n    this.observer = new IntersectionObserver(onIntersect, observerOptions);\n    // Observe each default elements\n    for (const scrollElement of this.scrollElements) {\n      const $scrollElement = scrollElement.$el;\n      this.observe($scrollElement);\n    }\n  }\n  /**\r\n   * Lifecyle - Destroy Intersection Observer.\r\n   */\n  destroy() {\n    this.observer.disconnect();\n  }\n  /**\r\n   * Subscribe element to the Intersection Observer.\r\n   *\r\n   * @param {HTMLElement} $scrollElement - DOM Element to observe.\r\n   */\n  observe($scrollElement) {\n    if (!$scrollElement) {\n      return;\n    }\n    this.observer.observe($scrollElement);\n  }\n  /**\r\n   * Unsubscribe element to the Intersection Observer.\r\n   *\r\n   * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\r\n   */\n  unobserve($scrollElement) {\n    if (!$scrollElement) {\n      return;\n    }\n    this.observer.unobserve($scrollElement);\n  }\n  /**\r\n   * Find ScrollElementReference instance and trigger inview callbacks.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n   */\n  _setInview(entry) {\n    const scrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === entry.target);\n    this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInteractivityOn());\n    !this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInview());\n  }\n  /**\r\n   * Find ScrollElementReference instance and trigger out of view callbacks.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n   */\n  _setOutOfView(entry) {\n    const scrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === entry.target);\n    this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInteractivityOff());\n    !this.IORaf && (scrollElement == null ? void 0 : scrollElement.setOutOfView());\n    // Unobserve if element doesn't have repeat attribute\n    if (!(scrollElement != null && scrollElement.attributes.scrollRepeat) && !this.IORaf) {\n      this.unobserve(entry.target);\n    }\n  }\n}\n\n// https://greensock.com/docs/v3/GSAP/gsap.utils\n/**\r\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\r\n *\r\n * @param {number} min   - Minimum value expected.\r\n * @param {number} max   - Maximum value expected.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - Clamped value.\r\n */\nfunction clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n}\n/**\r\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\r\n *\r\n * @param {number} inMin  - Current minimum value.\r\n * @param {number} inMax  - Current maximum value.\r\n * @param {number} outMin - Maximum value expected.\r\n * @param {number} outMax - Maximum value expected.\r\n * @param {number} value  - Current value.\r\n *\r\n * @returns {number} - New value that should be between minimum value expected and maximum value.\r\n */\nfunction mapRange(inMin, inMax, outMin, outMax, value) {\n  const inRange = inMax - inMin;\n  const outRange = outMax - outMin;\n  return outMin + ((value - inMin) / inRange * outRange || 0);\n}\n/**\r\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\r\n *\r\n * @param {number} min   - Current minimum value.\r\n * @param {number} max   - Current maximum value.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - New value that should be between 0 and 1.\r\n */\nfunction normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n}\n/**\r\n * Get closest number from an array.\r\n *\r\n * @param {number[]} array  - Numbers array.\r\n * @param {number}   target - Reference value.\r\n *\r\n * @returns {number} - Closest number.\r\n */\nfunction closestNumber(array, target) {\n  return array.reduce((prev, curr) => {\n    return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n  });\n}\n\n/**\r\n * Scroll Element\r\n *\r\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\r\n *\r\n * Features functions to:\r\n *\r\n * - scrollClass - Add a custom class when the element is intersected by the offset\r\n * - scrollOffset - Determine offsets to intersect the element\r\n * - scrollPosition - Determine the element positions to consider an element as intersected.\r\n * - scrollModuleProgress - Send scroll progress to modular module that have a specific method (PROGRESS_MODULAR_METHOD)\r\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\r\n * - scrollEventProgress - Send scroll progress to custom event listeners.\r\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\r\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\r\n * - scrollCall - Call a custom event or a modular callback when the element is intersected\r\n */\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\nconst PROGRESS_MODULAR_METHOD = 'onScrollProgress';\nclass ScrollElement {\n  constructor({\n    $el,\n    id,\n    modularInstance,\n    subscribeElementUpdateFn,\n    unsubscribeElementUpdateFn,\n    needRaf,\n    scrollOrientation\n  }) {\n    var _this$$el$dataset$scr, _this$$el$dataset$scr2, _this$$el$dataset$scr3, _this$$el$dataset$scr4, _this$$el$dataset$scr5;\n    this.$el = void 0;\n    this.id = void 0;\n    this.needRaf = void 0;\n    this.attributes = void 0;\n    this.scrollOrientation = void 0;\n    this.isAlreadyIntersected = void 0;\n    this.intersection = void 0;\n    this.metrics = void 0;\n    this.currentScroll = void 0;\n    this.translateValue = void 0;\n    this.progress = void 0;\n    this.lastProgress = void 0;\n    this.modularInstance = void 0;\n    this.progressModularModules = void 0;\n    this.isInview = void 0;\n    this.isInteractive = void 0;\n    this.isInFold = void 0;\n    this.isFirstResize = void 0;\n    this.subscribeElementUpdateFn = void 0;\n    this.unsubscribeElementUpdateFn = void 0;\n    // Scroll DOM element\n    this.$el = $el;\n    // Unique ID\n    this.id = id;\n    // RAF option\n    this.needRaf = needRaf;\n    // Scroll Direction\n    this.scrollOrientation = scrollOrientation;\n    // Modular.js\n    this.modularInstance = modularInstance;\n    // Parent's callbacks\n    this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n    this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n    // Attributes\n    this.attributes = {\n      scrollClass: (_this$$el$dataset$scr = this.$el.dataset['scrollClass']) != null ? _this$$el$dataset$scr : INVIEW_CLASS,\n      scrollOffset: (_this$$el$dataset$scr2 = this.$el.dataset['scrollOffset']) != null ? _this$$el$dataset$scr2 : '0,0',\n      scrollPosition: (_this$$el$dataset$scr3 = this.$el.dataset['scrollPosition']) != null ? _this$$el$dataset$scr3 : 'start,end',\n      scrollModuleProgress: this.$el.dataset['scrollModuleProgress'] != null,\n      scrollCssProgress: this.$el.dataset['scrollCssProgress'] != null,\n      scrollEventProgress: (_this$$el$dataset$scr4 = this.$el.dataset['scrollEventProgress']) != null ? _this$$el$dataset$scr4 : null,\n      scrollSpeed: this.$el.dataset['scrollSpeed'] != null ? parseFloat(this.$el.dataset['scrollSpeed']) : null,\n      scrollRepeat: this.$el.dataset['scrollRepeat'] != null,\n      scrollCall: (_this$$el$dataset$scr5 = this.$el.dataset['scrollCall']) != null ? _this$$el$dataset$scr5 : null,\n      scrollCallSelf: this.$el.dataset['scrollCallSelf'] != null,\n      scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] != null,\n      scrollEnableTouchSpeed: this.$el.dataset['scrollEnableTouchSpeed'] != null\n    };\n    // Limits\n    this.intersection = {\n      start: 0,\n      end: 0\n    };\n    // Metrics\n    this.metrics = {\n      offsetStart: 0,\n      offsetEnd: 0,\n      bcr: {}\n    };\n    // Scroll Values\n    this.currentScroll = this.scrollOrientation === 'vertical' ? window.scrollY : window.scrollX;\n    // Parallax\n    this.translateValue = 0;\n    // Progress\n    this.progress = 0;\n    this.lastProgress = null;\n    this.progressModularModules = [];\n    // Inview\n    this.isInview = false;\n    this.isInteractive = false;\n    this.isAlreadyIntersected = false;\n    this.isInFold = false;\n    this.isFirstResize = true;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize progress tracking.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    if (!this.needRaf) {\n      return;\n    }\n    // Prepare modules progress\n    if (this.modularInstance && this.attributes.scrollModuleProgress) {\n      this._getProgressModularModules();\n    }\n    // First resize to compute all values\n    this._resize();\n  }\n  /**\r\n   * Callback - Resize callback\r\n   */\n  onResize({\n    currentScroll\n  }) {\n    this.currentScroll = currentScroll;\n    this._resize();\n  }\n  /**\r\n   * Callback - RAF callback\r\n   */\n  onRender({\n    currentScroll,\n    smooth\n  }) {\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    this.currentScroll = currentScroll;\n    this._computeProgress();\n    // Parallax\n    if (this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed)) {\n      // if touch detected or smooth disabled\n      if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n        if (this.translateValue) {\n          this.$el.style.transform = `translate3d(0, 0, 0)`;\n        }\n        this.translateValue = 0;\n        // if mousewheel or smooth enabled\n      } else {\n        // Check fold condition\n        if (this.isInFold) {\n          const progress = Math.max(0, this.progress);\n          this.translateValue = progress * wSize * this.attributes.scrollSpeed * -1;\n        } else {\n          const progress = mapRange(0, 1, -1, 1, this.progress);\n          this.translateValue = progress * wSize * this.attributes.scrollSpeed * -1;\n        }\n        this.$el.style.transform = this.scrollOrientation === 'vertical' ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`;\n      }\n    }\n  }\n  /**\r\n   * Inview callback\r\n   */\n  setInview() {\n    if (this.isInview) {\n      return;\n    }\n    this.isInview = true;\n    this.$el.classList.add(this.attributes.scrollClass);\n    const way = 'enter';\n    const from = this._getScrollCallFrom();\n    this.attributes.scrollCall && this._dispatchCall(way, from);\n  }\n  /**\r\n   * Out of view callback\r\n   */\n  setOutOfView() {\n    if (!(this.isInview && this.attributes.scrollRepeat)) {\n      return;\n    }\n    this.isInview = false;\n    this.$el.classList.remove(this.attributes.scrollClass);\n    const way = 'leave';\n    const from = this._getScrollCallFrom();\n    this.attributes.scrollCall && this._dispatchCall(way, from);\n  }\n  /**\r\n   * Switch interactivity on to subscribe the instance to the RAF\r\n   * and start calculations.\r\n   */\n  setInteractivityOn() {\n    if (this.isInteractive) {\n      return;\n    }\n    this.isInteractive = true;\n    this.subscribeElementUpdateFn(this);\n  }\n  /**\r\n   * Switch interactivity off to unsubscribe the instance to the RAF\r\n   * and stop calculations.\r\n   */\n  setInteractivityOff() {\n    if (!this.isInteractive) {\n      return;\n    }\n    this.isInteractive = false;\n    this.unsubscribeElementUpdateFn(this);\n    // Force progress to progress limit when the element is out\n    this.lastProgress != null && this._computeProgress(closestNumber([0, 1], this.lastProgress));\n  }\n  /**\r\n   * Resize method that compute the element's values.\r\n   *\r\n   * @private\r\n   */\n  _resize() {\n    this.metrics.bcr = this.$el.getBoundingClientRect();\n    this._computeMetrics();\n    this._computeIntersection();\n    // First resize logic\n    if (this.isFirstResize) {\n      this.isFirstResize = false;\n      // Dispatch default call if the element is in fold.\n      if (this.isInFold) {\n        this.setInview();\n      }\n    }\n  }\n  /**\r\n   * Compute element's offsets and determine if the element is in fold.\r\n   *\r\n   * @private\r\n   */\n  _computeMetrics() {\n    const {\n      top,\n      left,\n      height,\n      width\n    } = this.metrics.bcr;\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    const metricsStart = this.scrollOrientation === 'vertical' ? top : left;\n    const metricsSize = this.scrollOrientation === 'vertical' ? height : width;\n    this.metrics.offsetStart = this.currentScroll + metricsStart - this.translateValue;\n    this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n    if (this.metrics.offsetStart < wSize && !this.attributes.scrollIgnoreFold) {\n      this.isInFold = true;\n    } else {\n      this.isInFold = false;\n    }\n  }\n  /**\r\n   * Compute intersection values depending on the context.\r\n   *\r\n   * @private\r\n   */\n  _computeIntersection() {\n    // Window size\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    // Metrics size\n    const metricsSize = this.scrollOrientation === 'vertical' ? this.metrics.bcr.height : this.metrics.bcr.width;\n    // Offset\n    const offset = this.attributes.scrollOffset.split(',');\n    const offsetStart = offset[0] != undefined ? offset[0].trim() : '0';\n    const offsetEnd = offset[1] != undefined ? offset[1].trim() : '0';\n    // Positions\n    const scrollPosition = this.attributes.scrollPosition.split(',');\n    let scrollPositionStart = scrollPosition[0] != undefined ? scrollPosition[0].trim() : 'start';\n    const scrollPositionEnd = scrollPosition[1] != undefined ? scrollPosition[1].trim() : 'end';\n    // Viewport\n    const viewportStart = offsetStart.includes('%') ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01 : parseInt(offsetStart);\n    const viewportEnd = offsetEnd.includes('%') ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01 : parseInt(offsetEnd);\n    // Fold exception\n    if (this.isInFold) {\n      scrollPositionStart = 'fold';\n    }\n    // Define Intersection Start\n    switch (scrollPositionStart) {\n      case 'start':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart;\n        break;\n      case 'middle':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart + metricsSize * 0.5;\n        break;\n      case 'end':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart + metricsSize;\n        break;\n      case 'fold':\n        this.intersection.start = 0;\n        break;\n      default:\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart;\n        break;\n    }\n    // Define Intersection End\n    switch (scrollPositionEnd) {\n      case 'start':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd;\n        break;\n      case 'middle':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize * 0.5;\n        break;\n      case 'end':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize;\n        break;\n      default:\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize;\n        break;\n    }\n    // Avoid to have the end < the start intersection >\n    if (this.intersection.end <= this.intersection.start) {\n      switch (scrollPositionEnd) {\n        case 'start':\n          this.intersection.end = this.intersection.start + 1;\n          break;\n        case 'middle':\n          this.intersection.end = this.intersection.start + metricsSize * 0.5;\n          break;\n        case 'end':\n          this.intersection.end = this.intersection.start + metricsSize;\n          break;\n        default:\n          this.intersection.end = this.intersection.start + 1;\n          break;\n      }\n    }\n  }\n  /**\r\n   * Compute the scroll progress of the element depending\r\n   * on its intersection values.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [forcedProgress] - Value to force progress.\r\n   */\n  _computeProgress(forcedProgress) {\n    // Progress\n    const progress = forcedProgress != null ? forcedProgress : clamp(0, 1, normalize(this.intersection.start, this.intersection.end, this.currentScroll));\n    this.progress = progress;\n    if (progress != this.lastProgress) {\n      this.lastProgress = progress;\n      // Set the element's progress to the css variable\n      this.attributes.scrollCssProgress && this._setCssProgress(progress);\n      // Set the element's progress to the custom event listeners\n      this.attributes.scrollEventProgress && this._setCustomEventProgress(progress);\n      // Set the element's progress to inline modules\n      if (this.attributes.scrollModuleProgress) {\n        for (const modularModules of this.progressModularModules) {\n          this.modularInstance && this.modularInstance.call(PROGRESS_MODULAR_METHOD, progress, modularModules.moduleName, modularModules.moduleId);\n        }\n      }\n      // Logic to trigger the inview/out of view callbacks\n      progress > 0 && progress < 1 && this.setInview();\n      progress === 0 && this.setOutOfView();\n      progress === 1 && this.setOutOfView();\n    }\n  }\n  /**\r\n   * Set the element's progress to a specific css variable.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentProgress] - Progress value.\r\n   */\n  _setCssProgress(currentProgress = 0) {\n    this.$el.style.setProperty(PROGRESS_CSS_VAR, currentProgress.toString());\n  }\n  /**\r\n   * Set the element's progress to the custom event listeners.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentProgress] - Progress value.\r\n   */\n  _setCustomEventProgress(currentProgress = 0) {\n    const customEventName = this.attributes.scrollEventProgress;\n    if (!customEventName) return;\n    const customEvent = new CustomEvent(customEventName, {\n      detail: {\n        target: this.$el,\n        progress: currentProgress\n      }\n    });\n    window.dispatchEvent(customEvent);\n  }\n  /**\r\n   * Get modular modules that can listen the element's progress.\r\n   *\r\n   * @private\r\n   */\n  _getProgressModularModules() {\n    if (!this.modularInstance) {\n      return;\n    }\n    const modulesIdNames = Object.keys(this.$el.dataset).filter(key => key.includes('module'));\n    const modules = Object.entries(this.modularInstance.modules);\n    if (!modulesIdNames.length) {\n      return;\n    }\n    for (const modulesIdName of modulesIdNames) {\n      const moduleId = this.$el.dataset[modulesIdName];\n      if (!moduleId) {\n        return;\n      }\n      for (const module of modules) {\n        const [moduleName, moduleObj] = module;\n        if (moduleId in moduleObj) {\n          this.progressModularModules.push({\n            moduleName,\n            moduleId\n          });\n        }\n      }\n    }\n  }\n  /**\r\n   * Function to get scroll call from.\r\n   *\r\n   * @private\r\n   */\n  _getScrollCallFrom() {\n    const closestIntersectionValue = closestNumber([this.intersection.start, this.intersection.end], this.currentScroll);\n    return this.intersection.start === closestIntersectionValue ? 'start' : 'end';\n  }\n  /**\r\n   * Function to dispatch a custom event or call a modular callback.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {scrollCallWay} way - Enter or leave.\r\n   * @param {scrollCallFrom} from - Start or end.\r\n   */\n  _dispatchCall(way, from) {\n    var _this$attributes$scro, _this$attributes;\n    const callParameters = (_this$attributes$scro = this.attributes.scrollCall) == null ? void 0 : _this$attributes$scro.split(',');\n    const callSelf = (_this$attributes = this.attributes) == null ? void 0 : _this$attributes.scrollCallSelf;\n    if (callParameters && callParameters.length > 1) {\n      var _targetModuleId;\n      // Using Modular.js (https://github.com/modularorg/modularjs)\n      const [func, moduleName, moduleId] = callParameters;\n      let targetModuleId;\n      // If the module is set on the scroll element\n      if (callSelf) {\n        targetModuleId = this.$el.dataset[`module${moduleName.trim()}`];\n      } else {\n        targetModuleId = moduleId;\n      }\n      this.modularInstance && this.modularInstance.call(func.trim(), {\n        target: this.$el,\n        way,\n        from\n      }, moduleName.trim(), (_targetModuleId = targetModuleId) == null ? void 0 : _targetModuleId.trim());\n    } else if (callParameters) {\n      // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n      const [customEventName] = callParameters;\n      const customEvent = new CustomEvent(customEventName, {\n        detail: {\n          target: this.$el,\n          way,\n          from\n        }\n      });\n      window.dispatchEvent(customEvent);\n    }\n  }\n}\n\n/**\r\n * Integrates Lenis with Locomotive's built-in animation system\r\n */\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = ['scrollOffset', 'scrollPosition', 'scrollModuleProgress', 'scrollCssProgress', 'scrollEventProgress', 'scrollSpeed'];\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\nclass Core {\n  constructor({\n    $el,\n    modularInstance,\n    triggerRootMargin,\n    rafRootMargin,\n    scrollOrientation\n  }) {\n    this.$scrollContainer = void 0;\n    this.modularInstance = void 0;\n    this.triggerRootMargin = void 0;\n    this.rafRootMargin = void 0;\n    this.scrollElements = void 0;\n    this.triggeredScrollElements = void 0;\n    this.RAFScrollElements = void 0;\n    this.scrollElementsToUpdate = void 0;\n    this.IOTriggerInstance = void 0;\n    this.IORafInstance = void 0;\n    this.scrollOrientation = void 0;\n    if (!$el) {\n      console.error('Please provide a DOM Element as scrollContainer');\n      return;\n    }\n    // Scroll container\n    this.$scrollContainer = $el;\n    // Modular.js\n    this.modularInstance = modularInstance;\n    // Scroll Direction\n    this.scrollOrientation = scrollOrientation;\n    // IO Margins\n    this.triggerRootMargin = triggerRootMargin != null ? triggerRootMargin : TRIGGER_ROOT_MARGIN;\n    this.rafRootMargin = rafRootMargin != null ? rafRootMargin : RAF_ROOT_MARGIN;\n    // ScrollElements arrays\n    this.scrollElements = [];\n    this.triggeredScrollElements = [];\n    this.RAFScrollElements = [];\n    this.scrollElementsToUpdate = [];\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize the core.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    const $scrollElements = this.$scrollContainer.querySelectorAll('[data-scroll]');\n    const $scrollElementsArr = Array.from($scrollElements);\n    this._subscribeScrollElements($scrollElementsArr);\n    // Trigger IO\n    this.IOTriggerInstance = new IO({\n      scrollElements: [...this.triggeredScrollElements],\n      rootMargin: this.triggerRootMargin,\n      IORaf: false\n    });\n    // Raf IO\n    this.IORafInstance = new IO({\n      scrollElements: [...this.RAFScrollElements],\n      rootMargin: this.rafRootMargin,\n      IORaf: true\n    });\n  }\n  /**\r\n   * Lifecyle - Destroy core.\r\n   */\n  destroy() {\n    this.IOTriggerInstance.destroy();\n    this.IORafInstance.destroy();\n    this._unsubscribeAllScrollElements();\n  }\n  /**\r\n   * Callback - Resize callback.\r\n   */\n  onResize({\n    currentScroll\n  }) {\n    for (const scrollElement of this.RAFScrollElements) {\n      scrollElement.onResize({\n        currentScroll\n      });\n    }\n  }\n  /**\r\n   * Callback - RAF callback.\r\n   */\n  onRender({\n    currentScroll,\n    smooth\n  }) {\n    for (const scrollElement of this.scrollElementsToUpdate) {\n      scrollElement.onRender({\n        currentScroll,\n        smooth\n      });\n    }\n  }\n  /**\r\n   * Remove items from lists of scroll elements and compute all new values.\r\n   *\r\n   * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\r\n   */\n  removeScrollElements($oldContainer) {\n    const $scrollElementsToRemove = $oldContainer.querySelectorAll('[data-scroll]');\n    if (!$scrollElementsToRemove.length) return;\n    // 1. Remove from IO\n    for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n      const scrollElement = this.triggeredScrollElements[index];\n      const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove);\n      if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n        this.IOTriggerInstance.unobserve(scrollElement.$el);\n        this.triggeredScrollElements.splice(index, 1);\n      }\n    }\n    for (let index = 0; index < this.RAFScrollElements.length; index++) {\n      const scrollElement = this.RAFScrollElements[index];\n      const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove);\n      if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n        this.IORafInstance.unobserve(scrollElement.$el);\n        this.RAFScrollElements.splice(index, 1);\n      }\n    }\n    // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n    $scrollElementsToRemove.forEach($scrollElement => {\n      const targetScrollElementToUpdate = this.scrollElementsToUpdate.find(scrollElement => scrollElement.$el === $scrollElement);\n      const targetScrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === $scrollElement);\n      if (targetScrollElementToUpdate) {\n        this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n      }\n      if (targetScrollElement) {\n        this.scrollElements = this.scrollElements.filter(scrollElementItem => scrollElementItem.id != targetScrollElement.id);\n      }\n    });\n  }\n  /**\r\n   * Add items to lists of scroll elements and compute all new values.\r\n   *\r\n   * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\r\n   */\n  addScrollElements($newContainer) {\n    // 3. Rebuild ScrollElements\n    const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n    // 4. Get max scrollElement.id\n    const ids = [];\n    this.scrollElements.forEach(scrollElement => {\n      ids.push(scrollElement.id);\n    });\n    const maxID = Math.max(...ids);\n    const fromIndex = maxID + 1;\n    const $scrollElementsArr = Array.from($scrollElements);\n    this._subscribeScrollElements($scrollElementsArr, fromIndex, true);\n  }\n  /**\r\n   * Create a ScrollElement instance for each elements with\r\n   * `data-scroll` attribute.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {HTMLElement[]} $scrollElements - List of elements that need\r\n   *     to be regarded.\r\n   */\n  _subscribeScrollElements($scrollElements, fromIndex = 0, toObserve = false) {\n    // For each scroll element create a ScrollElement instance\n    for (let index = 0; index < $scrollElements.length; index++) {\n      const $scrollElement = $scrollElements[index];\n      const needRaf = this._checkRafNeeded($scrollElement);\n      const scrollElementInstance = new ScrollElement({\n        $el: $scrollElement,\n        id: fromIndex + index,\n        scrollOrientation: this.scrollOrientation,\n        modularInstance: this.modularInstance,\n        subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this),\n        unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this),\n        needRaf\n      });\n      // Push to common array\n      this.scrollElements.push(scrollElementInstance);\n      // Push to specific array\n      if (needRaf) {\n        this.RAFScrollElements.push(scrollElementInstance);\n        // Dynamic observe item\n        if (toObserve) {\n          this.IORafInstance.scrollElements.push(scrollElementInstance);\n          this.IORafInstance.observe(scrollElementInstance.$el);\n        }\n      } else {\n        this.triggeredScrollElements.push(scrollElementInstance);\n        // Dynamic observe item\n        if (toObserve) {\n          this.IOTriggerInstance.scrollElements.push(scrollElementInstance);\n          this.IOTriggerInstance.observe(scrollElementInstance.$el);\n        }\n      }\n    }\n  }\n  /**\r\n   * Clear all ScrollElement arrays.\r\n   *\r\n   * @private\r\n   */\n  _unsubscribeAllScrollElements() {\n    this.scrollElements = [];\n    this.RAFScrollElements = [];\n    this.triggeredScrollElements = [];\n    this.scrollElementsToUpdate = [];\n  }\n  /**\r\n   * Subscribe ScrollElement instance that needs to be updated.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {ScrollElement} scrollElement - ScrollElement instance inview\r\n   *     that needs to be updated.\r\n   */\n  _subscribeElementUpdate(scrollElement) {\n    this.scrollElementsToUpdate.push(scrollElement);\n  }\n  /**\r\n   * Unscribe ScrollElement instance that doesn't need to be updated.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {ScrollElement} scrollElement - The updated ScrollElement instance\r\n   *     out of view now.\r\n   */\n  _unsubscribeElementUpdate(scrollElement) {\n    this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(scrollElementToUpdate => scrollElementToUpdate.id != scrollElement.id);\n  }\n  /**\r\n   * Check if a DOM Element need a requestAnimationFrame to be used.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {HTMLElement} $scrollElement - The element that needs to be checked.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  _checkRafNeeded($scrollElement) {\n    let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n    // Remove utils\n    const removeAttribute = attributeToRemove => {\n      attributesThatNeedRaf = attributesThatNeedRaf.filter(attribute => attribute != attributeToRemove);\n    };\n    // 1. Check scroll offset values\n    if ($scrollElement.dataset.scrollOffset) {\n      const value = $scrollElement.dataset.scrollOffset.split(',').map(test => test.replace('%', '').trim()).join(',');\n      if (value != '0,0') {\n        return true;\n      } else {\n        removeAttribute('scrollOffset');\n      }\n    } else {\n      removeAttribute('scrollOffset');\n    }\n    // 2. Check scroll position values\n    if ($scrollElement.dataset.scrollPosition) {\n      const value = $scrollElement.dataset.scrollPosition.trim();\n      if (value != 'top,bottom') {\n        return true;\n      } else {\n        removeAttribute('scrollPosition');\n      }\n    } else {\n      removeAttribute('scrollPosition');\n    }\n    // 3. Check scroll speed values\n    if ($scrollElement.dataset.scrollSpeed && !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))) {\n      return true;\n    } else {\n      removeAttribute('scrollSpeed');\n    }\n    // 4. Check others attributes\n    for (const attribute of attributesThatNeedRaf) {\n      if (attribute in $scrollElement.dataset) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\r\n * Resize Observer\r\n *\r\n * The Resize Observer API provides a performant mechanism by which code can monitor an element for changes to its size,\r\n * with notifications being delivered to the observer each time the size changes.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger the resize callback if the specified element's size change.\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Resize_Observer_API}\r\n */\nclass RO {\n  constructor({\n    resizeElements,\n    resizeCallback = () => {}\n  }) {\n    this.$resizeElements = void 0;\n    this.isFirstObserve = void 0;\n    this.observer = void 0;\n    this.resizeCallback = void 0;\n    // Parameters\n    this.$resizeElements = resizeElements;\n    this.resizeCallback = resizeCallback;\n    // Flags\n    this.isFirstObserve = true;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize Resize Observer.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    // Callback\n    const onResize = entries => {\n      var _this$resizeCallback;\n      !this.isFirstObserve && ((_this$resizeCallback = this.resizeCallback) == null ? void 0 : _this$resizeCallback.call(this));\n      this.isFirstObserve = false;\n    };\n    // Instance\n    this.observer = new ResizeObserver(onResize);\n    // Observe each default elements\n    for (const $resizeElement of this.$resizeElements) {\n      this.observer.observe($resizeElement);\n    }\n  }\n  /**\r\n   * Lifecyle - Destroy Resize Observer.\r\n   */\n  destroy() {\n    this.observer.disconnect();\n  }\n}\n\n/**\r\n * @type {ILenisOptions}\r\n */\nconst defaultLenisOptions = {\n  wrapper: window,\n  content: document.documentElement,\n  lerp: 0.1,\n  duration: 1.2,\n  orientation: 'vertical',\n  gestureOrientation: 'vertical',\n  smoothWheel: true,\n  smoothTouch: false,\n  wheelMultiplier: 1,\n  touchMultiplier: 2,\n  normalizeWheel: true,\n  easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)) // https://www.desmos.com/calculator/brs54l4xou\n};\n/**\r\n * Locomotive Scroll\r\n *\r\n * Detection of elements in viewport & smooth scrolling with parallax.\r\n *\r\n * Inspired by\r\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\r\n * and built around\r\n * {@link https://github.com/studio-freight/lenis lenis.js}.\r\n */\nclass LocomotiveScroll {\n  constructor({\n    lenisOptions = {},\n    modularInstance,\n    triggerRootMargin,\n    rafRootMargin,\n    autoResize = true,\n    autoStart = true,\n    scrollCallback = () => {},\n    initCustomTicker,\n    destroyCustomTicker\n  } = {}) {\n    this.rafPlaying = void 0;\n    this.lenisInstance = void 0;\n    this.coreInstance = void 0;\n    this.lenisOptions = void 0;\n    this.modularInstance = void 0;\n    this.triggerRootMargin = void 0;\n    this.rafRootMargin = void 0;\n    this.rafInstance = void 0;\n    this.autoResize = void 0;\n    this.autoStart = void 0;\n    this.ROInstance = void 0;\n    this.initCustomTicker = void 0;\n    this.destroyCustomTicker = void 0;\n    this._onRenderBind = void 0;\n    this._onResizeBind = void 0;\n    this._onScrollToBind = void 0;\n    // Arguments\n    this.lenisOptions = _extends({}, defaultLenisOptions, lenisOptions);\n    Object.assign(this, {\n      lenisOptions,\n      modularInstance,\n      triggerRootMargin,\n      rafRootMargin,\n      autoResize,\n      autoStart,\n      scrollCallback,\n      initCustomTicker,\n      destroyCustomTicker\n    });\n    // Binding\n    this._onRenderBind = this._onRender.bind(this);\n    this._onScrollToBind = this._onScrollTo.bind(this);\n    this._onResizeBind = this._onResize.bind(this);\n    // Data\n    this.rafPlaying = false;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize instance.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    var _this$lenisInstance;\n    // Create Lenis instance\n    this.lenisInstance = new _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      wrapper: this.lenisOptions.wrapper,\n      content: this.lenisOptions.content,\n      lerp: this.lenisOptions.lerp,\n      duration: this.lenisOptions.duration,\n      orientation: this.lenisOptions.orientation,\n      gestureOrientation: this.lenisOptions.gestureOrientation,\n      smoothWheel: this.lenisOptions.smoothWheel,\n      smoothTouch: this.lenisOptions.smoothTouch,\n      wheelMultiplier: this.lenisOptions.wheelMultiplier,\n      touchMultiplier: this.lenisOptions.touchMultiplier,\n      normalizeWheel: this.lenisOptions.normalizeWheel,\n      easing: this.lenisOptions.easing\n    });\n    (_this$lenisInstance = this.lenisInstance) == null ? void 0 : _this$lenisInstance.on('scroll', this.scrollCallback);\n    // Add scroll direction attribute on body\n    document.documentElement.setAttribute('data-scroll-orientation', this.lenisInstance.options.orientation);\n    requestAnimationFrame(() => {\n      // Create Core Instance\n      this.coreInstance = new Core({\n        $el: this.lenisInstance.rootElement,\n        modularInstance: this.modularInstance,\n        triggerRootMargin: this.triggerRootMargin,\n        rafRootMargin: this.rafRootMargin,\n        scrollOrientation: this.lenisInstance.options.orientation\n      });\n      // Bind Events\n      this._bindEvents();\n      // RAF warning\n      if (this.initCustomTicker && !this.destroyCustomTicker) {\n        console.warn('initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.');\n      } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n        console.warn('destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.');\n      }\n      // Start RAF\n      this.autoStart && this.start();\n    });\n  }\n  /**\r\n   * Lifecyle - Destroy instance.\r\n   */\n  destroy() {\n    // Stop raf\n    this.stop();\n    // Unbind Events\n    this._unbindEvents();\n    // Destroy Lenis\n    this.lenisInstance.destroy();\n    // Destroy Core\n    this.coreInstance.destroy();\n  }\n  /**\r\n   * Events - Subscribe events to listen.\r\n   */\n  _bindEvents() {\n    this._bindScrollToEvents();\n    if (this.autoResize) {\n      if ('ResizeObserver' in window) {\n        this.ROInstance = new RO({\n          resizeElements: [document.body],\n          resizeCallback: this._onResizeBind\n        });\n      } else {\n        window.addEventListener('resize', this._onResizeBind);\n      }\n    }\n  }\n  /**\r\n   * Events - Unsubscribe listened events.\r\n   */\n  _unbindEvents() {\n    this._unbindScrollToEvents();\n    if (this.autoResize) {\n      if ('ResizeObserver' in window) {\n        this.ROInstance && this.ROInstance.destroy();\n      } else {\n        window.removeEventListener('resize', this._onResizeBind);\n      }\n    }\n  }\n  /**\r\n   * Events - Subscribe scrollTo events to listen.\r\n   */\n  _bindScrollToEvents($container) {\n    const $rootContainer = $container ? $container : this.lenisInstance.rootElement;\n    const $scrollToElements = $rootContainer == null ? void 0 : $rootContainer.querySelectorAll('[data-scroll-to]');\n    ($scrollToElements == null ? void 0 : $scrollToElements.length) && $scrollToElements.forEach($el => {\n      $el.addEventListener('click', this._onScrollToBind, false);\n    });\n  }\n  /**\r\n   * Events - Unsubscribe scrollTo listened events.\r\n   */\n  _unbindScrollToEvents($container) {\n    const $rootContainer = $container ? $container : this.lenisInstance.rootElement;\n    const $scrollToElements = $rootContainer == null ? void 0 : $rootContainer.querySelectorAll('[data-scroll-to]');\n    ($scrollToElements == null ? void 0 : $scrollToElements.length) && $scrollToElements.forEach($el => {\n      $el.removeEventListener('click', this._onScrollToBind, false);\n    });\n  }\n  /**\r\n   * Callback - Resize callback.\r\n   */\n  _onResize() {\n    // Waiting the next frame to get the new current scroll value return by Lenis\n    requestAnimationFrame(() => {\n      var _this$coreInstance;\n      (_this$coreInstance = this.coreInstance) == null ? void 0 : _this$coreInstance.onResize({\n        currentScroll: this.lenisInstance.scroll\n      });\n    });\n  }\n  /**\r\n   * Callback - Render callback.\r\n   */\n  _onRender() {\n    var _this$lenisInstance2, _this$coreInstance2;\n    (_this$lenisInstance2 = this.lenisInstance) == null ? void 0 : _this$lenisInstance2.raf(Date.now());\n    (_this$coreInstance2 = this.coreInstance) == null ? void 0 : _this$coreInstance2.onRender({\n      currentScroll: this.lenisInstance.scroll,\n      smooth: this.lenisInstance.isSmooth\n    });\n  }\n  /**\r\n   * Callback - Scroll To callback.\r\n   */\n  _onScrollTo(event) {\n    var _event$currentTarget;\n    event.preventDefault();\n    const $target = (_event$currentTarget = event.currentTarget) != null ? _event$currentTarget : null;\n    if (!$target) return;\n    const target = $target.getAttribute('data-scroll-to-href') || $target.getAttribute('href');\n    const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n    const duration = $target.getAttribute('data-scroll-to-duration') || this.lenisOptions.duration || defaultLenisOptions.duration;\n    target && this.scrollTo(target, {\n      offset: typeof offset === 'string' ? parseInt(offset) : offset,\n      duration: typeof duration === 'string' ? parseInt(duration) : duration\n    });\n  }\n  /**\r\n   * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   */\n  start() {\n    if (this.rafPlaying) {\n      return;\n    }\n    this.rafPlaying = true;\n    this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf();\n  }\n  /**\r\n   * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   */\n  stop() {\n    if (!this.rafPlaying) {\n      return;\n    }\n    this.rafPlaying = false;\n    this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n  }\n  /**\r\n   * Remove old scroll elements items and rebuild ScrollElements instances.\r\n   */\n  removeScrollElements($oldContainer) {\n    var _this$coreInstance3;\n    if (!$oldContainer) {\n      console.error('Please provide a DOM Element as $oldContainer');\n      return;\n    }\n    this._unbindScrollToEvents($oldContainer);\n    (_this$coreInstance3 = this.coreInstance) == null ? void 0 : _this$coreInstance3.removeScrollElements($oldContainer);\n  }\n  /**\r\n   * Add new scroll elements items and rebuild ScrollElements instances.\r\n   */\n  addScrollElements($newContainer) {\n    var _this$coreInstance4;\n    if (!$newContainer) {\n      console.error('Please provide a DOM Element as $newContainer');\n      return;\n    }\n    (_this$coreInstance4 = this.coreInstance) == null ? void 0 : _this$coreInstance4.addScrollElements($newContainer);\n    requestAnimationFrame(() => {\n      this._bindScrollToEvents($newContainer);\n    });\n  }\n  /**\r\n   * Trigger resize callback.\r\n   */\n  resize() {\n    this._onResizeBind();\n  }\n  /**\r\n   * Trigger scroll to callback.\r\n   */\n  scrollTo(target, options) {\n    var _this$lenisInstance3;\n    (_this$lenisInstance3 = this.lenisInstance) == null ? void 0 : _this$lenisInstance3.scrollTo(target, {\n      offset: options == null ? void 0 : options.offset,\n      lerp: options == null ? void 0 : options.lerp,\n      duration: options == null ? void 0 : options.duration,\n      immediate: options == null ? void 0 : options.immediate,\n      lock: options == null ? void 0 : options.lock,\n      force: options == null ? void 0 : options.force,\n      easing: options == null ? void 0 : options.easing,\n      onComplete: options == null ? void 0 : options.onComplete\n    });\n  }\n  /**\r\n   * RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   *\r\n   * @private\r\n   *\r\n   */\n  _raf() {\n    this._onRenderBind();\n    this.rafInstance = requestAnimationFrame(() => this._raf());\n  }\n}\n\n\n//# sourceMappingURL=locomotive-scroll.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbG9jb21vdGl2ZS1zY3JvbGwvZGlzdC9sb2NvbW90aXZlLXNjcm9sbC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDOztBQUUxQztBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLG9CQUFvQix5QkFBeUIsb0JBQW9CO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBNkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUksdURBQXVEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21vb3RoLXNjcm9sbC12Mi8uL25vZGVfbW9kdWxlcy9sb2NvbW90aXZlLXNjcm9sbC9kaXN0L2xvY29tb3RpdmUtc2Nyb2xsLm1vZGVybi5tanM/MDliMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGVuaXMgZnJvbSAnQHN0dWRpby1mcmVpZ2h0L2xlbmlzJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxyXG4gKiBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXJcclxuICpcclxuICogRGV0ZWN0aW5nIHZpc2liaWxpdHkgb2YgYW4gZWxlbWVudCBpbiB0aGUgdmlld3BvcnQuXHJcbiAqXHJcbiAqIEZlYXR1cmVzIGZ1bmN0aW9ucyB0bzpcclxuICpcclxuICogLSBUcmlnZ2VyIGludmlldy9vdXRPZlZpZXcgY2FsbGJhY2tzXHJcbiAqIC0gSWYgdGhlIGVsZW1lbnQgaGFzIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGRlcGVuZGVuY3ksIHNldCBpbnRlcmFjdGl2eSBzdGF0dXMgZm9yIHRoZSBTY3JvbGxFbGVtZW50IENsYXNzXHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqXHJcbiAqIC0ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbnRlcnNlY3Rpb25fT2JzZXJ2ZXJfQVBJfVxyXG4gKi9cbmNsYXNzIElPIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHNjcm9sbEVsZW1lbnRzLFxuICAgIHJvb3RNYXJnaW4gPSAnLTFweCAtMXB4IC0xcHggLTFweCcsXG4gICAgSU9SYWZcbiAgfSkge1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5yb290TWFyZ2luID0gdm9pZCAwO1xuICAgIHRoaXMuSU9SYWYgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICAvLyBQYXJhbWV0ZXJzXG4gICAgdGhpcy5zY3JvbGxFbGVtZW50cyA9IHNjcm9sbEVsZW1lbnRzO1xuICAgIHRoaXMucm9vdE1hcmdpbiA9IHJvb3RNYXJnaW47XG4gICAgdGhpcy5JT1JhZiA9IElPUmFmO1xuICAgIC8vIEluaXRcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBJbml0aWFsaXplIEludGVyc2VjdGlvbiBPYnNlcnZlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9pbml0KCkge1xuICAgIC8vIE9wdGlvbnNcbiAgICBjb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luOiB0aGlzLnJvb3RNYXJnaW5cbiAgICB9O1xuICAgIC8vIENhbGxiYWNrXG4gICAgY29uc3Qgb25JbnRlcnNlY3QgPSBlbnRyaWVzID0+IHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0ICR0YXJnZXRJdGVtID0gdGhpcy5zY3JvbGxFbGVtZW50cy5maW5kKGl0ZW0gPT4gaXRlbS4kZWwgPT09IGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICR0YXJnZXRJdGVtICYmICgkdGFyZ2V0SXRlbS5pc0FscmVhZHlJbnRlcnNlY3RlZCA9IHRydWUpO1xuICAgICAgICAgIHRoaXMuX3NldEludmlldyhlbnRyeSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJHRhcmdldEl0ZW0gJiYgJHRhcmdldEl0ZW0uaXNBbHJlYWR5SW50ZXJzZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZXRPdXRPZlZpZXcoZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEluc3RhbmNlXG4gICAgdGhpcy5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihvbkludGVyc2VjdCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAvLyBPYnNlcnZlIGVhY2ggZGVmYXVsdCBlbGVtZW50c1xuICAgIGZvciAoY29uc3Qgc2Nyb2xsRWxlbWVudCBvZiB0aGlzLnNjcm9sbEVsZW1lbnRzKSB7XG4gICAgICBjb25zdCAkc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQuJGVsO1xuICAgICAgdGhpcy5vYnNlcnZlKCRzY3JvbGxFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBEZXN0cm95IEludGVyc2VjdGlvbiBPYnNlcnZlci5cclxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICAvKipcclxuICAgKiBTdWJzY3JpYmUgZWxlbWVudCB0byB0aGUgSW50ZXJzZWN0aW9uIE9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJHNjcm9sbEVsZW1lbnQgLSBET00gRWxlbWVudCB0byBvYnNlcnZlLlxyXG4gICAqL1xuICBvYnNlcnZlKCRzY3JvbGxFbGVtZW50KSB7XG4gICAgaWYgKCEkc2Nyb2xsRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUoJHNjcm9sbEVsZW1lbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVuc3Vic2NyaWJlIGVsZW1lbnQgdG8gdGhlIEludGVyc2VjdGlvbiBPYnNlcnZlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRzY3JvbGxFbGVtZW50IC0gRE9NIEVsZW1lbnQgdG8gdW5vYnNlcnZlLlxyXG4gICAqL1xuICB1bm9ic2VydmUoJHNjcm9sbEVsZW1lbnQpIHtcbiAgICBpZiAoISRzY3JvbGxFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKCRzY3JvbGxFbGVtZW50KTtcbiAgfVxuICAvKipcclxuICAgKiBGaW5kIFNjcm9sbEVsZW1lbnRSZWZlcmVuY2UgaW5zdGFuY2UgYW5kIHRyaWdnZXIgaW52aWV3IGNhbGxiYWNrcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnl9IGVudHJ5IC0gRE9NIEVsZW1lbnQgdG8gb2JzZXJ2ZS5cclxuICAgKi9cbiAgX3NldEludmlldyhlbnRyeSkge1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSB0aGlzLnNjcm9sbEVsZW1lbnRzLmZpbmQoc2Nyb2xsRWxlbWVudCA9PiBzY3JvbGxFbGVtZW50LiRlbCA9PT0gZW50cnkudGFyZ2V0KTtcbiAgICB0aGlzLklPUmFmICYmIChzY3JvbGxFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxFbGVtZW50LnNldEludGVyYWN0aXZpdHlPbigpKTtcbiAgICAhdGhpcy5JT1JhZiAmJiAoc2Nyb2xsRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsRWxlbWVudC5zZXRJbnZpZXcoKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRmluZCBTY3JvbGxFbGVtZW50UmVmZXJlbmNlIGluc3RhbmNlIGFuZCB0cmlnZ2VyIG91dCBvZiB2aWV3IGNhbGxiYWNrcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnl9IGVudHJ5IC0gRE9NIEVsZW1lbnQgdG8gb2JzZXJ2ZS5cclxuICAgKi9cbiAgX3NldE91dE9mVmlldyhlbnRyeSkge1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSB0aGlzLnNjcm9sbEVsZW1lbnRzLmZpbmQoc2Nyb2xsRWxlbWVudCA9PiBzY3JvbGxFbGVtZW50LiRlbCA9PT0gZW50cnkudGFyZ2V0KTtcbiAgICB0aGlzLklPUmFmICYmIChzY3JvbGxFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxFbGVtZW50LnNldEludGVyYWN0aXZpdHlPZmYoKSk7XG4gICAgIXRoaXMuSU9SYWYgJiYgKHNjcm9sbEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbEVsZW1lbnQuc2V0T3V0T2ZWaWV3KCkpO1xuICAgIC8vIFVub2JzZXJ2ZSBpZiBlbGVtZW50IGRvZXNuJ3QgaGF2ZSByZXBlYXQgYXR0cmlidXRlXG4gICAgaWYgKCEoc2Nyb2xsRWxlbWVudCAhPSBudWxsICYmIHNjcm9sbEVsZW1lbnQuYXR0cmlidXRlcy5zY3JvbGxSZXBlYXQpICYmICF0aGlzLklPUmFmKSB7XG4gICAgICB0aGlzLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL2dyZWVuc29jay5jb20vZG9jcy92My9HU0FQL2dzYXAudXRpbHNcbi8qKlxyXG4gKiBDbGFtcCBhIHZhbHVlIHRvIGZpdCB3aXRoaW4gYSBzcGVjaWZpYyByYW5nZSAoZXg6IGNsYW1wKDAsIDEwMCwgLTEyKSAtLT4gMCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gICAtIE1pbmltdW0gdmFsdWUgZXhwZWN0ZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggICAtIE1heGltdW0gdmFsdWUgZXhwZWN0ZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIEN1cnJlbnQgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gQ2xhbXBlZCB2YWx1ZS5cclxuICovXG5mdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbn1cbi8qKlxyXG4gKiBNYXAgb25lIHJhbmdlIHRvIGFub3RoZXIgKGV4OiBtYXBSYW5nZSgtMTAsIDEwLCAwLCAxMDAsIDUpIC0tPiA3NSkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbk1pbiAgLSBDdXJyZW50IG1pbmltdW0gdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbk1heCAgLSBDdXJyZW50IG1heGltdW0gdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRNaW4gLSBNYXhpbXVtIHZhbHVlIGV4cGVjdGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0TWF4IC0gTWF4aW11bSB2YWx1ZSBleHBlY3RlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlICAtIEN1cnJlbnQgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gTmV3IHZhbHVlIHRoYXQgc2hvdWxkIGJlIGJldHdlZW4gbWluaW11bSB2YWx1ZSBleHBlY3RlZCBhbmQgbWF4aW11bSB2YWx1ZS5cclxuICovXG5mdW5jdGlvbiBtYXBSYW5nZShpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4LCB2YWx1ZSkge1xuICBjb25zdCBpblJhbmdlID0gaW5NYXggLSBpbk1pbjtcbiAgY29uc3Qgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XG4gIHJldHVybiBvdXRNaW4gKyAoKHZhbHVlIC0gaW5NaW4pIC8gaW5SYW5nZSAqIG91dFJhbmdlIHx8IDApO1xufVxuLyoqXHJcbiAqIE1hcCBhIG51bWJlciB3aXRoaW4gYSByYW5nZSB0byBhIHByb2dyZXNzIGJldHdlZW4gMCB0byAxIChleDogbm9ybWFsaXplKDEwMCwgMjAwLCAxNTApIC0tPiAwLjUpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWluICAgLSBDdXJyZW50IG1pbmltdW0gdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggICAtIEN1cnJlbnQgbWF4aW11bSB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gQ3VycmVudCB2YWx1ZS5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gLSBOZXcgdmFsdWUgdGhhdCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAxLlxyXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIG1hcFJhbmdlKG1pbiwgbWF4LCAwLCAxLCB2YWx1ZSk7XG59XG4vKipcclxuICogR2V0IGNsb3Nlc3QgbnVtYmVyIGZyb20gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5ICAtIE51bWJlcnMgYXJyYXkuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSAgIHRhcmdldCAtIFJlZmVyZW5jZSB2YWx1ZS5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gLSBDbG9zZXN0IG51bWJlci5cclxuICovXG5mdW5jdGlvbiBjbG9zZXN0TnVtYmVyKGFycmF5LCB0YXJnZXQpIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgIHJldHVybiBNYXRoLmFicyhjdXJyIC0gdGFyZ2V0KSA8IE1hdGguYWJzKHByZXYgLSB0YXJnZXQpID8gY3VyciA6IHByZXY7XG4gIH0pO1xufVxuXG4vKipcclxuICogU2Nyb2xsIEVsZW1lbnRcclxuICpcclxuICogR2l2ZSB0b29scyB0byBjb21wdXRlIGVsZW1lbnQgcHJvZ3Jlc3MgaW4gdGhlIHZpZXdwb3J0IGFuZCB0cmlnZ2VycyBjYWxsYmFja3MgdG8gYW5pbWF0ZSBpdC5cclxuICpcclxuICogRmVhdHVyZXMgZnVuY3Rpb25zIHRvOlxyXG4gKlxyXG4gKiAtIHNjcm9sbENsYXNzIC0gQWRkIGEgY3VzdG9tIGNsYXNzIHdoZW4gdGhlIGVsZW1lbnQgaXMgaW50ZXJzZWN0ZWQgYnkgdGhlIG9mZnNldFxyXG4gKiAtIHNjcm9sbE9mZnNldCAtIERldGVybWluZSBvZmZzZXRzIHRvIGludGVyc2VjdCB0aGUgZWxlbWVudFxyXG4gKiAtIHNjcm9sbFBvc2l0aW9uIC0gRGV0ZXJtaW5lIHRoZSBlbGVtZW50IHBvc2l0aW9ucyB0byBjb25zaWRlciBhbiBlbGVtZW50IGFzIGludGVyc2VjdGVkLlxyXG4gKiAtIHNjcm9sbE1vZHVsZVByb2dyZXNzIC0gU2VuZCBzY3JvbGwgcHJvZ3Jlc3MgdG8gbW9kdWxhciBtb2R1bGUgdGhhdCBoYXZlIGEgc3BlY2lmaWMgbWV0aG9kIChQUk9HUkVTU19NT0RVTEFSX01FVEhPRClcclxuICogLSBzY3JvbGxDc3NQcm9ncmVzcyAtIEFkZCBhIHNwZWNpZmljIGNzcyB2YXJpYWJsZSAoUFJPR1JFU1NfQ1NTX1ZBUikgdGhhdCBzdG9yZSB0aGUgc2Nyb2xsIHByb2dyZXNzXHJcbiAqIC0gc2Nyb2xsRXZlbnRQcm9ncmVzcyAtIFNlbmQgc2Nyb2xsIHByb2dyZXNzIHRvIGN1c3RvbSBldmVudCBsaXN0ZW5lcnMuXHJcbiAqIC0gc2Nyb2xsU3BlZWQgLSBBZGQgYSBzY3JvbGwgbXVsdGlwbGljYXRvciB0byBjcmVhdGUgYSBwYXJhbGxheCBlZmZlY3RcclxuICogLSBzY3JvbGxSZXBlYXQgLSBSZXBlYXQgdGhlIG9wdGlvbiB0byB0cmlnZ2VyIGFuaW1hdGlvbiBlYWNoIHRpbWUgdGhlIGVsZW1lbnQgaXMgaW50ZXJzZWN0ZWRcclxuICogLSBzY3JvbGxDYWxsIC0gQ2FsbCBhIGN1c3RvbSBldmVudCBvciBhIG1vZHVsYXIgY2FsbGJhY2sgd2hlbiB0aGUgZWxlbWVudCBpcyBpbnRlcnNlY3RlZFxyXG4gKi9cbi8qKiBDb25zdGFudHMgKi9cbmNvbnN0IElOVklFV19DTEFTUyA9ICdpcy1pbnZpZXcnO1xuY29uc3QgUFJPR1JFU1NfQ1NTX1ZBUiA9ICctLXByb2dyZXNzJztcbmNvbnN0IFBST0dSRVNTX01PRFVMQVJfTUVUSE9EID0gJ29uU2Nyb2xsUHJvZ3Jlc3MnO1xuY2xhc3MgU2Nyb2xsRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICAkZWwsXG4gICAgaWQsXG4gICAgbW9kdWxhckluc3RhbmNlLFxuICAgIHN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbixcbiAgICB1bnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbixcbiAgICBuZWVkUmFmLFxuICAgIHNjcm9sbE9yaWVudGF0aW9uXG4gIH0pIHtcbiAgICB2YXIgX3RoaXMkJGVsJGRhdGFzZXQkc2NyLCBfdGhpcyQkZWwkZGF0YXNldCRzY3IyLCBfdGhpcyQkZWwkZGF0YXNldCRzY3IzLCBfdGhpcyQkZWwkZGF0YXNldCRzY3I0LCBfdGhpcyQkZWwkZGF0YXNldCRzY3I1O1xuICAgIHRoaXMuJGVsID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5uZWVkUmFmID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuaXNBbHJlYWR5SW50ZXJzZWN0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5tZXRyaWNzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudFNjcm9sbCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbGF0ZVZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0UHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5tb2R1bGFySW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9ncmVzc01vZHVsYXJNb2R1bGVzID0gdm9pZCAwO1xuICAgIHRoaXMuaXNJbnZpZXcgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNJbkZvbGQgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0ZpcnN0UmVzaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuID0gdm9pZCAwO1xuICAgIHRoaXMudW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4gPSB2b2lkIDA7XG4gICAgLy8gU2Nyb2xsIERPTSBlbGVtZW50XG4gICAgdGhpcy4kZWwgPSAkZWw7XG4gICAgLy8gVW5pcXVlIElEXG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIC8vIFJBRiBvcHRpb25cbiAgICB0aGlzLm5lZWRSYWYgPSBuZWVkUmFmO1xuICAgIC8vIFNjcm9sbCBEaXJlY3Rpb25cbiAgICB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID0gc2Nyb2xsT3JpZW50YXRpb247XG4gICAgLy8gTW9kdWxhci5qc1xuICAgIHRoaXMubW9kdWxhckluc3RhbmNlID0gbW9kdWxhckluc3RhbmNlO1xuICAgIC8vIFBhcmVudCdzIGNhbGxiYWNrc1xuICAgIHRoaXMuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuID0gc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuO1xuICAgIHRoaXMudW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4gPSB1bnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbjtcbiAgICAvLyBBdHRyaWJ1dGVzXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgc2Nyb2xsQ2xhc3M6IChfdGhpcyQkZWwkZGF0YXNldCRzY3IgPSB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxDbGFzcyddKSAhPSBudWxsID8gX3RoaXMkJGVsJGRhdGFzZXQkc2NyIDogSU5WSUVXX0NMQVNTLFxuICAgICAgc2Nyb2xsT2Zmc2V0OiAoX3RoaXMkJGVsJGRhdGFzZXQkc2NyMiA9IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbE9mZnNldCddKSAhPSBudWxsID8gX3RoaXMkJGVsJGRhdGFzZXQkc2NyMiA6ICcwLDAnLFxuICAgICAgc2Nyb2xsUG9zaXRpb246IChfdGhpcyQkZWwkZGF0YXNldCRzY3IzID0gdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsUG9zaXRpb24nXSkgIT0gbnVsbCA/IF90aGlzJCRlbCRkYXRhc2V0JHNjcjMgOiAnc3RhcnQsZW5kJyxcbiAgICAgIHNjcm9sbE1vZHVsZVByb2dyZXNzOiB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxNb2R1bGVQcm9ncmVzcyddICE9IG51bGwsXG4gICAgICBzY3JvbGxDc3NQcm9ncmVzczogdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsQ3NzUHJvZ3Jlc3MnXSAhPSBudWxsLFxuICAgICAgc2Nyb2xsRXZlbnRQcm9ncmVzczogKF90aGlzJCRlbCRkYXRhc2V0JHNjcjQgPSB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxFdmVudFByb2dyZXNzJ10pICE9IG51bGwgPyBfdGhpcyQkZWwkZGF0YXNldCRzY3I0IDogbnVsbCxcbiAgICAgIHNjcm9sbFNwZWVkOiB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxTcGVlZCddICE9IG51bGwgPyBwYXJzZUZsb2F0KHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbFNwZWVkJ10pIDogbnVsbCxcbiAgICAgIHNjcm9sbFJlcGVhdDogdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsUmVwZWF0J10gIT0gbnVsbCxcbiAgICAgIHNjcm9sbENhbGw6IChfdGhpcyQkZWwkZGF0YXNldCRzY3I1ID0gdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsQ2FsbCddKSAhPSBudWxsID8gX3RoaXMkJGVsJGRhdGFzZXQkc2NyNSA6IG51bGwsXG4gICAgICBzY3JvbGxDYWxsU2VsZjogdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsQ2FsbFNlbGYnXSAhPSBudWxsLFxuICAgICAgc2Nyb2xsSWdub3JlRm9sZDogdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsSWdub3JlRm9sZCddICE9IG51bGwsXG4gICAgICBzY3JvbGxFbmFibGVUb3VjaFNwZWVkOiB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxFbmFibGVUb3VjaFNwZWVkJ10gIT0gbnVsbFxuICAgIH07XG4gICAgLy8gTGltaXRzXG4gICAgdGhpcy5pbnRlcnNlY3Rpb24gPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMFxuICAgIH07XG4gICAgLy8gTWV0cmljc1xuICAgIHRoaXMubWV0cmljcyA9IHtcbiAgICAgIG9mZnNldFN0YXJ0OiAwLFxuICAgICAgb2Zmc2V0RW5kOiAwLFxuICAgICAgYmNyOiB7fVxuICAgIH07XG4gICAgLy8gU2Nyb2xsIFZhbHVlc1xuICAgIHRoaXMuY3VycmVudFNjcm9sbCA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB3aW5kb3cuc2Nyb2xsWSA6IHdpbmRvdy5zY3JvbGxYO1xuICAgIC8vIFBhcmFsbGF4XG4gICAgdGhpcy50cmFuc2xhdGVWYWx1ZSA9IDA7XG4gICAgLy8gUHJvZ3Jlc3NcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmVzc01vZHVsYXJNb2R1bGVzID0gW107XG4gICAgLy8gSW52aWV3XG4gICAgdGhpcy5pc0ludmlldyA9IGZhbHNlO1xuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNBbHJlYWR5SW50ZXJzZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzSW5Gb2xkID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZpcnN0UmVzaXplID0gdHJ1ZTtcbiAgICAvLyBJbml0XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gSW5pdGlhbGl6ZSBwcm9ncmVzcyB0cmFja2luZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9pbml0KCkge1xuICAgIGlmICghdGhpcy5uZWVkUmFmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFByZXBhcmUgbW9kdWxlcyBwcm9ncmVzc1xuICAgIGlmICh0aGlzLm1vZHVsYXJJbnN0YW5jZSAmJiB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsTW9kdWxlUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuX2dldFByb2dyZXNzTW9kdWxhck1vZHVsZXMoKTtcbiAgICB9XG4gICAgLy8gRmlyc3QgcmVzaXplIHRvIGNvbXB1dGUgYWxsIHZhbHVlc1xuICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIC0gUmVzaXplIGNhbGxiYWNrXHJcbiAgICovXG4gIG9uUmVzaXplKHtcbiAgICBjdXJyZW50U2Nyb2xsXG4gIH0pIHtcbiAgICB0aGlzLmN1cnJlbnRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsO1xuICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIC0gUkFGIGNhbGxiYWNrXHJcbiAgICovXG4gIG9uUmVuZGVyKHtcbiAgICBjdXJyZW50U2Nyb2xsLFxuICAgIHNtb290aFxuICB9KSB7XG4gICAgY29uc3Qgd1NpemUgPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsID0gY3VycmVudFNjcm9sbDtcbiAgICB0aGlzLl9jb21wdXRlUHJvZ3Jlc3MoKTtcbiAgICAvLyBQYXJhbGxheFxuICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsU3BlZWQgJiYgIWlzTmFOKHRoaXMuYXR0cmlidXRlcy5zY3JvbGxTcGVlZCkpIHtcbiAgICAgIC8vIGlmIHRvdWNoIGRldGVjdGVkIG9yIHNtb290aCBkaXNhYmxlZFxuICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsRW5hYmxlVG91Y2hTcGVlZCAmJiAhc21vb3RoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsIDAsIDApYDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVZhbHVlID0gMDtcbiAgICAgICAgLy8gaWYgbW91c2V3aGVlbCBvciBzbW9vdGggZW5hYmxlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9sZCBjb25kaXRpb25cbiAgICAgICAgaWYgKHRoaXMuaXNJbkZvbGQpIHtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWF4KDAsIHRoaXMucHJvZ3Jlc3MpO1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRlVmFsdWUgPSBwcm9ncmVzcyAqIHdTaXplICogdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbFNwZWVkICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBtYXBSYW5nZSgwLCAxLCAtMSwgMSwgdGhpcy5wcm9ncmVzcyk7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdGVWYWx1ZSA9IHByb2dyZXNzICogd1NpemUgKiB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsU3BlZWQgKiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbC5zdHlsZS50cmFuc2Zvcm0gPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy50cmFuc2xhdGVWYWx1ZX1weCwgMClgIDogYHRyYW5zbGF0ZTNkKCR7dGhpcy50cmFuc2xhdGVWYWx1ZX1weCwgMCwgMClgO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBJbnZpZXcgY2FsbGJhY2tcclxuICAgKi9cbiAgc2V0SW52aWV3KCkge1xuICAgIGlmICh0aGlzLmlzSW52aWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNJbnZpZXcgPSB0cnVlO1xuICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQodGhpcy5hdHRyaWJ1dGVzLnNjcm9sbENsYXNzKTtcbiAgICBjb25zdCB3YXkgPSAnZW50ZXInO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9nZXRTY3JvbGxDYWxsRnJvbSgpO1xuICAgIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxDYWxsICYmIHRoaXMuX2Rpc3BhdGNoQ2FsbCh3YXksIGZyb20pO1xuICB9XG4gIC8qKlxyXG4gICAqIE91dCBvZiB2aWV3IGNhbGxiYWNrXHJcbiAgICovXG4gIHNldE91dE9mVmlldygpIHtcbiAgICBpZiAoISh0aGlzLmlzSW52aWV3ICYmIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxSZXBlYXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNJbnZpZXcgPSBmYWxzZTtcbiAgICB0aGlzLiRlbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuYXR0cmlidXRlcy5zY3JvbGxDbGFzcyk7XG4gICAgY29uc3Qgd2F5ID0gJ2xlYXZlJztcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZ2V0U2Nyb2xsQ2FsbEZyb20oKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsQ2FsbCAmJiB0aGlzLl9kaXNwYXRjaENhbGwod2F5LCBmcm9tKTtcbiAgfVxuICAvKipcclxuICAgKiBTd2l0Y2ggaW50ZXJhY3Rpdml0eSBvbiB0byBzdWJzY3JpYmUgdGhlIGluc3RhbmNlIHRvIHRoZSBSQUZcclxuICAgKiBhbmQgc3RhcnQgY2FsY3VsYXRpb25zLlxyXG4gICAqL1xuICBzZXRJbnRlcmFjdGl2aXR5T24oKSB7XG4gICAgaWYgKHRoaXMuaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuKHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN3aXRjaCBpbnRlcmFjdGl2aXR5IG9mZiB0byB1bnN1YnNjcmliZSB0aGUgaW5zdGFuY2UgdG8gdGhlIFJBRlxyXG4gICAqIGFuZCBzdG9wIGNhbGN1bGF0aW9ucy5cclxuICAgKi9cbiAgc2V0SW50ZXJhY3Rpdml0eU9mZigpIHtcbiAgICBpZiAoIXRoaXMuaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuKHRoaXMpO1xuICAgIC8vIEZvcmNlIHByb2dyZXNzIHRvIHByb2dyZXNzIGxpbWl0IHdoZW4gdGhlIGVsZW1lbnQgaXMgb3V0XG4gICAgdGhpcy5sYXN0UHJvZ3Jlc3MgIT0gbnVsbCAmJiB0aGlzLl9jb21wdXRlUHJvZ3Jlc3MoY2xvc2VzdE51bWJlcihbMCwgMV0sIHRoaXMubGFzdFByb2dyZXNzKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXplIG1ldGhvZCB0aGF0IGNvbXB1dGUgdGhlIGVsZW1lbnQncyB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfcmVzaXplKCkge1xuICAgIHRoaXMubWV0cmljcy5iY3IgPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLl9jb21wdXRlTWV0cmljcygpO1xuICAgIHRoaXMuX2NvbXB1dGVJbnRlcnNlY3Rpb24oKTtcbiAgICAvLyBGaXJzdCByZXNpemUgbG9naWNcbiAgICBpZiAodGhpcy5pc0ZpcnN0UmVzaXplKSB7XG4gICAgICB0aGlzLmlzRmlyc3RSZXNpemUgPSBmYWxzZTtcbiAgICAgIC8vIERpc3BhdGNoIGRlZmF1bHQgY2FsbCBpZiB0aGUgZWxlbWVudCBpcyBpbiBmb2xkLlxuICAgICAgaWYgKHRoaXMuaXNJbkZvbGQpIHtcbiAgICAgICAgdGhpcy5zZXRJbnZpZXcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBlbGVtZW50J3Mgb2Zmc2V0cyBhbmQgZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIGluIGZvbGQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfY29tcHV0ZU1ldHJpY3MoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IHRoaXMubWV0cmljcy5iY3I7XG4gICAgY29uc3Qgd1NpemUgPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgY29uc3QgbWV0cmljc1N0YXJ0ID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHRvcCA6IGxlZnQ7XG4gICAgY29uc3QgbWV0cmljc1NpemUgPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gaGVpZ2h0IDogd2lkdGg7XG4gICAgdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0ID0gdGhpcy5jdXJyZW50U2Nyb2xsICsgbWV0cmljc1N0YXJ0IC0gdGhpcy50cmFuc2xhdGVWYWx1ZTtcbiAgICB0aGlzLm1ldHJpY3Mub2Zmc2V0RW5kID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0ICsgbWV0cmljc1NpemU7XG4gICAgaWYgKHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCA8IHdTaXplICYmICF0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsSWdub3JlRm9sZCkge1xuICAgICAgdGhpcy5pc0luRm9sZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbkZvbGQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBpbnRlcnNlY3Rpb24gdmFsdWVzIGRlcGVuZGluZyBvbiB0aGUgY29udGV4dC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9jb21wdXRlSW50ZXJzZWN0aW9uKCkge1xuICAgIC8vIFdpbmRvdyBzaXplXG4gICAgY29uc3Qgd1NpemUgPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgLy8gTWV0cmljcyBzaXplXG4gICAgY29uc3QgbWV0cmljc1NpemUgPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gdGhpcy5tZXRyaWNzLmJjci5oZWlnaHQgOiB0aGlzLm1ldHJpY3MuYmNyLndpZHRoO1xuICAgIC8vIE9mZnNldFxuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYXR0cmlidXRlcy5zY3JvbGxPZmZzZXQuc3BsaXQoJywnKTtcbiAgICBjb25zdCBvZmZzZXRTdGFydCA9IG9mZnNldFswXSAhPSB1bmRlZmluZWQgPyBvZmZzZXRbMF0udHJpbSgpIDogJzAnO1xuICAgIGNvbnN0IG9mZnNldEVuZCA9IG9mZnNldFsxXSAhPSB1bmRlZmluZWQgPyBvZmZzZXRbMV0udHJpbSgpIDogJzAnO1xuICAgIC8vIFBvc2l0aW9uc1xuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbFBvc2l0aW9uLnNwbGl0KCcsJyk7XG4gICAgbGV0IHNjcm9sbFBvc2l0aW9uU3RhcnQgPSBzY3JvbGxQb3NpdGlvblswXSAhPSB1bmRlZmluZWQgPyBzY3JvbGxQb3NpdGlvblswXS50cmltKCkgOiAnc3RhcnQnO1xuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uRW5kID0gc2Nyb2xsUG9zaXRpb25bMV0gIT0gdW5kZWZpbmVkID8gc2Nyb2xsUG9zaXRpb25bMV0udHJpbSgpIDogJ2VuZCc7XG4gICAgLy8gVmlld3BvcnRcbiAgICBjb25zdCB2aWV3cG9ydFN0YXJ0ID0gb2Zmc2V0U3RhcnQuaW5jbHVkZXMoJyUnKSA/IHdTaXplICogcGFyc2VJbnQob2Zmc2V0U3RhcnQucmVwbGFjZSgnJScsICcnKS50cmltKCkpICogMC4wMSA6IHBhcnNlSW50KG9mZnNldFN0YXJ0KTtcbiAgICBjb25zdCB2aWV3cG9ydEVuZCA9IG9mZnNldEVuZC5pbmNsdWRlcygnJScpID8gd1NpemUgKiBwYXJzZUludChvZmZzZXRFbmQucmVwbGFjZSgnJScsICcnKS50cmltKCkpICogMC4wMSA6IHBhcnNlSW50KG9mZnNldEVuZCk7XG4gICAgLy8gRm9sZCBleGNlcHRpb25cbiAgICBpZiAodGhpcy5pc0luRm9sZCkge1xuICAgICAgc2Nyb2xsUG9zaXRpb25TdGFydCA9ICdmb2xkJztcbiAgICB9XG4gICAgLy8gRGVmaW5lIEludGVyc2VjdGlvbiBTdGFydFxuICAgIHN3aXRjaCAoc2Nyb2xsUG9zaXRpb25TdGFydCkge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5zdGFydCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHdTaXplICsgdmlld3BvcnRTdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5zdGFydCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHdTaXplICsgdmlld3BvcnRTdGFydCArIG1ldHJpY3NTaXplICogMC41O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gd1NpemUgKyB2aWV3cG9ydFN0YXJ0ICsgbWV0cmljc1NpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZm9sZCc6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5zdGFydCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHdTaXplICsgdmlld3BvcnRTdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIERlZmluZSBJbnRlcnNlY3Rpb24gRW5kXG4gICAgc3dpdGNoIChzY3JvbGxQb3NpdGlvbkVuZCkge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB2aWV3cG9ydEVuZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB2aWV3cG9ydEVuZCArIG1ldHJpY3NTaXplICogMC41O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHZpZXdwb3J0RW5kICsgbWV0cmljc1NpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gdmlld3BvcnRFbmQgKyBtZXRyaWNzU2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIEF2b2lkIHRvIGhhdmUgdGhlIGVuZCA8IHRoZSBzdGFydCBpbnRlcnNlY3Rpb24gPlxuICAgIGlmICh0aGlzLmludGVyc2VjdGlvbi5lbmQgPD0gdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQpIHtcbiAgICAgIHN3aXRjaCAoc2Nyb2xsUG9zaXRpb25FbmQpIHtcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLmludGVyc2VjdGlvbi5zdGFydCArIG1ldHJpY3NTaXplICogMC41O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ICsgbWV0cmljc1NpemU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlIHRoZSBzY3JvbGwgcHJvZ3Jlc3Mgb2YgdGhlIGVsZW1lbnQgZGVwZW5kaW5nXHJcbiAgICogb24gaXRzIGludGVyc2VjdGlvbiB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmb3JjZWRQcm9ncmVzc10gLSBWYWx1ZSB0byBmb3JjZSBwcm9ncmVzcy5cclxuICAgKi9cbiAgX2NvbXB1dGVQcm9ncmVzcyhmb3JjZWRQcm9ncmVzcykge1xuICAgIC8vIFByb2dyZXNzXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBmb3JjZWRQcm9ncmVzcyAhPSBudWxsID8gZm9yY2VkUHJvZ3Jlc3MgOiBjbGFtcCgwLCAxLCBub3JtYWxpemUodGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQsIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCwgdGhpcy5jdXJyZW50U2Nyb2xsKSk7XG4gICAgdGhpcy5wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIGlmIChwcm9ncmVzcyAhPSB0aGlzLmxhc3RQcm9ncmVzcykge1xuICAgICAgdGhpcy5sYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIC8vIFNldCB0aGUgZWxlbWVudCdzIHByb2dyZXNzIHRvIHRoZSBjc3MgdmFyaWFibGVcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxDc3NQcm9ncmVzcyAmJiB0aGlzLl9zZXRDc3NQcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICAvLyBTZXQgdGhlIGVsZW1lbnQncyBwcm9ncmVzcyB0byB0aGUgY3VzdG9tIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbEV2ZW50UHJvZ3Jlc3MgJiYgdGhpcy5fc2V0Q3VzdG9tRXZlbnRQcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICAvLyBTZXQgdGhlIGVsZW1lbnQncyBwcm9ncmVzcyB0byBpbmxpbmUgbW9kdWxlc1xuICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy5zY3JvbGxNb2R1bGVQcm9ncmVzcykge1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsYXJNb2R1bGVzIG9mIHRoaXMucHJvZ3Jlc3NNb2R1bGFyTW9kdWxlcykge1xuICAgICAgICAgIHRoaXMubW9kdWxhckluc3RhbmNlICYmIHRoaXMubW9kdWxhckluc3RhbmNlLmNhbGwoUFJPR1JFU1NfTU9EVUxBUl9NRVRIT0QsIHByb2dyZXNzLCBtb2R1bGFyTW9kdWxlcy5tb2R1bGVOYW1lLCBtb2R1bGFyTW9kdWxlcy5tb2R1bGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExvZ2ljIHRvIHRyaWdnZXIgdGhlIGludmlldy9vdXQgb2YgdmlldyBjYWxsYmFja3NcbiAgICAgIHByb2dyZXNzID4gMCAmJiBwcm9ncmVzcyA8IDEgJiYgdGhpcy5zZXRJbnZpZXcoKTtcbiAgICAgIHByb2dyZXNzID09PSAwICYmIHRoaXMuc2V0T3V0T2ZWaWV3KCk7XG4gICAgICBwcm9ncmVzcyA9PT0gMSAmJiB0aGlzLnNldE91dE9mVmlldygpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIGVsZW1lbnQncyBwcm9ncmVzcyB0byBhIHNwZWNpZmljIGNzcyB2YXJpYWJsZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2N1cnJlbnRQcm9ncmVzc10gLSBQcm9ncmVzcyB2YWx1ZS5cclxuICAgKi9cbiAgX3NldENzc1Byb2dyZXNzKGN1cnJlbnRQcm9ncmVzcyA9IDApIHtcbiAgICB0aGlzLiRlbC5zdHlsZS5zZXRQcm9wZXJ0eShQUk9HUkVTU19DU1NfVkFSLCBjdXJyZW50UHJvZ3Jlc3MudG9TdHJpbmcoKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBlbGVtZW50J3MgcHJvZ3Jlc3MgdG8gdGhlIGN1c3RvbSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50UHJvZ3Jlc3NdIC0gUHJvZ3Jlc3MgdmFsdWUuXHJcbiAgICovXG4gIF9zZXRDdXN0b21FdmVudFByb2dyZXNzKGN1cnJlbnRQcm9ncmVzcyA9IDApIHtcbiAgICBjb25zdCBjdXN0b21FdmVudE5hbWUgPSB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsRXZlbnRQcm9ncmVzcztcbiAgICBpZiAoIWN1c3RvbUV2ZW50TmFtZSkgcmV0dXJuO1xuICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50TmFtZSwge1xuICAgICAgZGV0YWlsOiB7XG4gICAgICAgIHRhcmdldDogdGhpcy4kZWwsXG4gICAgICAgIHByb2dyZXNzOiBjdXJyZW50UHJvZ3Jlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IG1vZHVsYXIgbW9kdWxlcyB0aGF0IGNhbiBsaXN0ZW4gdGhlIGVsZW1lbnQncyBwcm9ncmVzcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9nZXRQcm9ncmVzc01vZHVsYXJNb2R1bGVzKCkge1xuICAgIGlmICghdGhpcy5tb2R1bGFySW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlc0lkTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLiRlbC5kYXRhc2V0KS5maWx0ZXIoa2V5ID0+IGtleS5pbmNsdWRlcygnbW9kdWxlJykpO1xuICAgIGNvbnN0IG1vZHVsZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLm1vZHVsYXJJbnN0YW5jZS5tb2R1bGVzKTtcbiAgICBpZiAoIW1vZHVsZXNJZE5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZHVsZXNJZE5hbWUgb2YgbW9kdWxlc0lkTmFtZXMpIHtcbiAgICAgIGNvbnN0IG1vZHVsZUlkID0gdGhpcy4kZWwuZGF0YXNldFttb2R1bGVzSWROYW1lXTtcbiAgICAgIGlmICghbW9kdWxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgICBjb25zdCBbbW9kdWxlTmFtZSwgbW9kdWxlT2JqXSA9IG1vZHVsZTtcbiAgICAgICAgaWYgKG1vZHVsZUlkIGluIG1vZHVsZU9iaikge1xuICAgICAgICAgIHRoaXMucHJvZ3Jlc3NNb2R1bGFyTW9kdWxlcy5wdXNoKHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWUsXG4gICAgICAgICAgICBtb2R1bGVJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHRvIGdldCBzY3JvbGwgY2FsbCBmcm9tLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2dldFNjcm9sbENhbGxGcm9tKCkge1xuICAgIGNvbnN0IGNsb3Nlc3RJbnRlcnNlY3Rpb25WYWx1ZSA9IGNsb3Nlc3ROdW1iZXIoW3RoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0LCB0aGlzLmludGVyc2VjdGlvbi5lbmRdLCB0aGlzLmN1cnJlbnRTY3JvbGwpO1xuICAgIHJldHVybiB0aGlzLmludGVyc2VjdGlvbi5zdGFydCA9PT0gY2xvc2VzdEludGVyc2VjdGlvblZhbHVlID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICB9XG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uIHRvIGRpc3BhdGNoIGEgY3VzdG9tIGV2ZW50IG9yIGNhbGwgYSBtb2R1bGFyIGNhbGxiYWNrLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c2Nyb2xsQ2FsbFdheX0gd2F5IC0gRW50ZXIgb3IgbGVhdmUuXHJcbiAgICogQHBhcmFtIHtzY3JvbGxDYWxsRnJvbX0gZnJvbSAtIFN0YXJ0IG9yIGVuZC5cclxuICAgKi9cbiAgX2Rpc3BhdGNoQ2FsbCh3YXksIGZyb20pIHtcbiAgICB2YXIgX3RoaXMkYXR0cmlidXRlcyRzY3JvLCBfdGhpcyRhdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGNhbGxQYXJhbWV0ZXJzID0gKF90aGlzJGF0dHJpYnV0ZXMkc2NybyA9IHRoaXMuYXR0cmlidXRlcy5zY3JvbGxDYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXR0cmlidXRlcyRzY3JvLnNwbGl0KCcsJyk7XG4gICAgY29uc3QgY2FsbFNlbGYgPSAoX3RoaXMkYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGF0dHJpYnV0ZXMuc2Nyb2xsQ2FsbFNlbGY7XG4gICAgaWYgKGNhbGxQYXJhbWV0ZXJzICYmIGNhbGxQYXJhbWV0ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBfdGFyZ2V0TW9kdWxlSWQ7XG4gICAgICAvLyBVc2luZyBNb2R1bGFyLmpzIChodHRwczovL2dpdGh1Yi5jb20vbW9kdWxhcm9yZy9tb2R1bGFyanMpXG4gICAgICBjb25zdCBbZnVuYywgbW9kdWxlTmFtZSwgbW9kdWxlSWRdID0gY2FsbFBhcmFtZXRlcnM7XG4gICAgICBsZXQgdGFyZ2V0TW9kdWxlSWQ7XG4gICAgICAvLyBJZiB0aGUgbW9kdWxlIGlzIHNldCBvbiB0aGUgc2Nyb2xsIGVsZW1lbnRcbiAgICAgIGlmIChjYWxsU2VsZikge1xuICAgICAgICB0YXJnZXRNb2R1bGVJZCA9IHRoaXMuJGVsLmRhdGFzZXRbYG1vZHVsZSR7bW9kdWxlTmFtZS50cmltKCl9YF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRNb2R1bGVJZCA9IG1vZHVsZUlkO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2R1bGFySW5zdGFuY2UgJiYgdGhpcy5tb2R1bGFySW5zdGFuY2UuY2FsbChmdW5jLnRyaW0oKSwge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGVsLFxuICAgICAgICB3YXksXG4gICAgICAgIGZyb21cbiAgICAgIH0sIG1vZHVsZU5hbWUudHJpbSgpLCAoX3RhcmdldE1vZHVsZUlkID0gdGFyZ2V0TW9kdWxlSWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0TW9kdWxlSWQudHJpbSgpKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxQYXJhbWV0ZXJzKSB7XG4gICAgICAvLyBVc2luZyBDdXN0b21FdmVudCBBUEkgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudClcbiAgICAgIGNvbnN0IFtjdXN0b21FdmVudE5hbWVdID0gY2FsbFBhcmFtZXRlcnM7XG4gICAgICBjb25zdCBjdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChjdXN0b21FdmVudE5hbWUsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLiRlbCxcbiAgICAgICAgICB3YXksXG4gICAgICAgICAgZnJvbVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXHJcbiAqIEludGVncmF0ZXMgTGVuaXMgd2l0aCBMb2NvbW90aXZlJ3MgYnVpbHQtaW4gYW5pbWF0aW9uIHN5c3RlbVxyXG4gKi9cbi8qKiBEZWZpbmVkIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXG5jb25zdCBBVFRSSUJVVEVTX1RIQVRfTkVFRF9SQUYgPSBbJ3Njcm9sbE9mZnNldCcsICdzY3JvbGxQb3NpdGlvbicsICdzY3JvbGxNb2R1bGVQcm9ncmVzcycsICdzY3JvbGxDc3NQcm9ncmVzcycsICdzY3JvbGxFdmVudFByb2dyZXNzJywgJ3Njcm9sbFNwZWVkJ107XG4vKiogRGVmYXVsdCByb290IG1hcmdpbnMgKi9cbmNvbnN0IFRSSUdHRVJfUk9PVF9NQVJHSU4gPSAnLTFweCAtMXB4IC0xcHggLTFweCc7XG5jb25zdCBSQUZfUk9PVF9NQVJHSU4gPSAnMTAwJSAxMDAlIDEwMCUgMTAwJSc7IC8vIEFkZCAxMDB2aCB0b3AvYm90dG9tICYmIDEwMHZ3IGxlZnQvcmlnaHQgdG8gdXNlIGEgYmlnZ2VzdCB2YWx1ZSB3aXRoIGRhdGEtc2Nyb2xsLXNwZWVkXG5jbGFzcyBDb3JlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgICRlbCxcbiAgICBtb2R1bGFySW5zdGFuY2UsXG4gICAgdHJpZ2dlclJvb3RNYXJnaW4sXG4gICAgcmFmUm9vdE1hcmdpbixcbiAgICBzY3JvbGxPcmllbnRhdGlvblxuICB9KSB7XG4gICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHRoaXMubW9kdWxhckluc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMudHJpZ2dlclJvb3RNYXJnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5yYWZSb290TWFyZ2luID0gdm9pZCAwO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLklPVHJpZ2dlckluc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuSU9SYWZJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID0gdm9pZCAwO1xuICAgIGlmICghJGVsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIERPTSBFbGVtZW50IGFzIHNjcm9sbENvbnRhaW5lcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTY3JvbGwgY29udGFpbmVyXG4gICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyID0gJGVsO1xuICAgIC8vIE1vZHVsYXIuanNcbiAgICB0aGlzLm1vZHVsYXJJbnN0YW5jZSA9IG1vZHVsYXJJbnN0YW5jZTtcbiAgICAvLyBTY3JvbGwgRGlyZWN0aW9uXG4gICAgdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9IHNjcm9sbE9yaWVudGF0aW9uO1xuICAgIC8vIElPIE1hcmdpbnNcbiAgICB0aGlzLnRyaWdnZXJSb290TWFyZ2luID0gdHJpZ2dlclJvb3RNYXJnaW4gIT0gbnVsbCA/IHRyaWdnZXJSb290TWFyZ2luIDogVFJJR0dFUl9ST09UX01BUkdJTjtcbiAgICB0aGlzLnJhZlJvb3RNYXJnaW4gPSByYWZSb290TWFyZ2luICE9IG51bGwgPyByYWZSb290TWFyZ2luIDogUkFGX1JPT1RfTUFSR0lOO1xuICAgIC8vIFNjcm9sbEVsZW1lbnRzIGFycmF5c1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5SQUZTY3JvbGxFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZSA9IFtdO1xuICAgIC8vIEluaXRcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBJbml0aWFsaXplIHRoZSBjb3JlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgJHNjcm9sbEVsZW1lbnRzID0gdGhpcy4kc2Nyb2xsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNjcm9sbF0nKTtcbiAgICBjb25zdCAkc2Nyb2xsRWxlbWVudHNBcnIgPSBBcnJheS5mcm9tKCRzY3JvbGxFbGVtZW50cyk7XG4gICAgdGhpcy5fc3Vic2NyaWJlU2Nyb2xsRWxlbWVudHMoJHNjcm9sbEVsZW1lbnRzQXJyKTtcbiAgICAvLyBUcmlnZ2VyIElPXG4gICAgdGhpcy5JT1RyaWdnZXJJbnN0YW5jZSA9IG5ldyBJTyh7XG4gICAgICBzY3JvbGxFbGVtZW50czogWy4uLnRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHNdLFxuICAgICAgcm9vdE1hcmdpbjogdGhpcy50cmlnZ2VyUm9vdE1hcmdpbixcbiAgICAgIElPUmFmOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIFJhZiBJT1xuICAgIHRoaXMuSU9SYWZJbnN0YW5jZSA9IG5ldyBJTyh7XG4gICAgICBzY3JvbGxFbGVtZW50czogWy4uLnRoaXMuUkFGU2Nyb2xsRWxlbWVudHNdLFxuICAgICAgcm9vdE1hcmdpbjogdGhpcy5yYWZSb290TWFyZ2luLFxuICAgICAgSU9SYWY6IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIERlc3Ryb3kgY29yZS5cclxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLklPVHJpZ2dlckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB0aGlzLklPUmFmSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIHRoaXMuX3Vuc3Vic2NyaWJlQWxsU2Nyb2xsRWxlbWVudHMoKTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayAtIFJlc2l6ZSBjYWxsYmFjay5cclxuICAgKi9cbiAgb25SZXNpemUoe1xuICAgIGN1cnJlbnRTY3JvbGxcbiAgfSkge1xuICAgIGZvciAoY29uc3Qgc2Nyb2xsRWxlbWVudCBvZiB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzKSB7XG4gICAgICBzY3JvbGxFbGVtZW50Lm9uUmVzaXplKHtcbiAgICAgICAgY3VycmVudFNjcm9sbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIC0gUkFGIGNhbGxiYWNrLlxyXG4gICAqL1xuICBvblJlbmRlcih7XG4gICAgY3VycmVudFNjcm9sbCxcbiAgICBzbW9vdGhcbiAgfSkge1xuICAgIGZvciAoY29uc3Qgc2Nyb2xsRWxlbWVudCBvZiB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUpIHtcbiAgICAgIHNjcm9sbEVsZW1lbnQub25SZW5kZXIoe1xuICAgICAgICBjdXJyZW50U2Nyb2xsLFxuICAgICAgICBzbW9vdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmUgaXRlbXMgZnJvbSBsaXN0cyBvZiBzY3JvbGwgZWxlbWVudHMgYW5kIGNvbXB1dGUgYWxsIG5ldyB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkb2xkQ29udGFpbmVyIC0gSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyBkYXRhLXNjcm9sbCBlbGVtZW50cyB0byB1bnN1YnNjcmliZVxyXG4gICAqL1xuICByZW1vdmVTY3JvbGxFbGVtZW50cygkb2xkQ29udGFpbmVyKSB7XG4gICAgY29uc3QgJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmUgPSAkb2xkQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNjcm9sbF0nKTtcbiAgICBpZiAoISRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlLmxlbmd0aCkgcmV0dXJuO1xuICAgIC8vIDEuIFJlbW92ZSBmcm9tIElPXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gdGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50c1tpbmRleF07XG4gICAgICBjb25zdCAkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZUFyciA9IEFycmF5LmZyb20oJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmUpO1xuICAgICAgaWYgKCRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlQXJyLmluZGV4T2Yoc2Nyb2xsRWxlbWVudC4kZWwpID4gLTEpIHtcbiAgICAgICAgdGhpcy5JT1RyaWdnZXJJbnN0YW5jZS51bm9ic2VydmUoc2Nyb2xsRWxlbWVudC4kZWwpO1xuICAgICAgICB0aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMuUkFGU2Nyb2xsRWxlbWVudHNbaW5kZXhdO1xuICAgICAgY29uc3QgJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmVBcnIgPSBBcnJheS5mcm9tKCRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlKTtcbiAgICAgIGlmICgkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZUFyci5pbmRleE9mKHNjcm9sbEVsZW1lbnQuJGVsKSA+IC0xKSB7XG4gICAgICAgIHRoaXMuSU9SYWZJbnN0YW5jZS51bm9ic2VydmUoc2Nyb2xsRWxlbWVudC4kZWwpO1xuICAgICAgICB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIDIuIFJlbW92ZSBmcm9tIHNjcm9sbEVsZW1lbnRzVG9VcGRhdGVbXSBhbmQgc2Nyb2xsRWxlbWVudHNbXVxuICAgICRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlLmZvckVhY2goJHNjcm9sbEVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0U2Nyb2xsRWxlbWVudFRvVXBkYXRlID0gdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlLmZpbmQoc2Nyb2xsRWxlbWVudCA9PiBzY3JvbGxFbGVtZW50LiRlbCA9PT0gJHNjcm9sbEVsZW1lbnQpO1xuICAgICAgY29uc3QgdGFyZ2V0U2Nyb2xsRWxlbWVudCA9IHRoaXMuc2Nyb2xsRWxlbWVudHMuZmluZChzY3JvbGxFbGVtZW50ID0+IHNjcm9sbEVsZW1lbnQuJGVsID09PSAkc2Nyb2xsRWxlbWVudCk7XG4gICAgICBpZiAodGFyZ2V0U2Nyb2xsRWxlbWVudFRvVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZSh0YXJnZXRTY3JvbGxFbGVtZW50VG9VcGRhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldFNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50cyA9IHRoaXMuc2Nyb2xsRWxlbWVudHMuZmlsdGVyKHNjcm9sbEVsZW1lbnRJdGVtID0+IHNjcm9sbEVsZW1lbnRJdGVtLmlkICE9IHRhcmdldFNjcm9sbEVsZW1lbnQuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZCBpdGVtcyB0byBsaXN0cyBvZiBzY3JvbGwgZWxlbWVudHMgYW5kIGNvbXB1dGUgYWxsIG5ldyB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkbmV3Q29udGFpbmVyIC0gSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyBkYXRhLXNjcm9sbCBlbGVtZW50cyB0byBzdWJzY3JpYmVcclxuICAgKi9cbiAgYWRkU2Nyb2xsRWxlbWVudHMoJG5ld0NvbnRhaW5lcikge1xuICAgIC8vIDMuIFJlYnVpbGQgU2Nyb2xsRWxlbWVudHNcbiAgICBjb25zdCAkc2Nyb2xsRWxlbWVudHMgPSAkbmV3Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNjcm9sbF0nKTtcbiAgICAvLyA0LiBHZXQgbWF4IHNjcm9sbEVsZW1lbnQuaWRcbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzLmZvckVhY2goc2Nyb2xsRWxlbWVudCA9PiB7XG4gICAgICBpZHMucHVzaChzY3JvbGxFbGVtZW50LmlkKTtcbiAgICB9KTtcbiAgICBjb25zdCBtYXhJRCA9IE1hdGgubWF4KC4uLmlkcyk7XG4gICAgY29uc3QgZnJvbUluZGV4ID0gbWF4SUQgKyAxO1xuICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50c0FyciA9IEFycmF5LmZyb20oJHNjcm9sbEVsZW1lbnRzKTtcbiAgICB0aGlzLl9zdWJzY3JpYmVTY3JvbGxFbGVtZW50cygkc2Nyb2xsRWxlbWVudHNBcnIsIGZyb21JbmRleCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgU2Nyb2xsRWxlbWVudCBpbnN0YW5jZSBmb3IgZWFjaCBlbGVtZW50cyB3aXRoXHJcbiAgICogYGRhdGEtc2Nyb2xsYCBhdHRyaWJ1dGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSAkc2Nyb2xsRWxlbWVudHMgLSBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgbmVlZFxyXG4gICAqICAgICB0byBiZSByZWdhcmRlZC5cclxuICAgKi9cbiAgX3N1YnNjcmliZVNjcm9sbEVsZW1lbnRzKCRzY3JvbGxFbGVtZW50cywgZnJvbUluZGV4ID0gMCwgdG9PYnNlcnZlID0gZmFsc2UpIHtcbiAgICAvLyBGb3IgZWFjaCBzY3JvbGwgZWxlbWVudCBjcmVhdGUgYSBTY3JvbGxFbGVtZW50IGluc3RhbmNlXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8ICRzY3JvbGxFbGVtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50ID0gJHNjcm9sbEVsZW1lbnRzW2luZGV4XTtcbiAgICAgIGNvbnN0IG5lZWRSYWYgPSB0aGlzLl9jaGVja1JhZk5lZWRlZCgkc2Nyb2xsRWxlbWVudCk7XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50SW5zdGFuY2UgPSBuZXcgU2Nyb2xsRWxlbWVudCh7XG4gICAgICAgICRlbDogJHNjcm9sbEVsZW1lbnQsXG4gICAgICAgIGlkOiBmcm9tSW5kZXggKyBpbmRleCxcbiAgICAgICAgc2Nyb2xsT3JpZW50YXRpb246IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24sXG4gICAgICAgIG1vZHVsYXJJbnN0YW5jZTogdGhpcy5tb2R1bGFySW5zdGFuY2UsXG4gICAgICAgIHN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbjogdGhpcy5fc3Vic2NyaWJlRWxlbWVudFVwZGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgICB1bnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbjogdGhpcy5fdW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlLmJpbmQodGhpcyksXG4gICAgICAgIG5lZWRSYWZcbiAgICAgIH0pO1xuICAgICAgLy8gUHVzaCB0byBjb21tb24gYXJyYXlcbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMucHVzaChzY3JvbGxFbGVtZW50SW5zdGFuY2UpO1xuICAgICAgLy8gUHVzaCB0byBzcGVjaWZpYyBhcnJheVxuICAgICAgaWYgKG5lZWRSYWYpIHtcbiAgICAgICAgdGhpcy5SQUZTY3JvbGxFbGVtZW50cy5wdXNoKHNjcm9sbEVsZW1lbnRJbnN0YW5jZSk7XG4gICAgICAgIC8vIER5bmFtaWMgb2JzZXJ2ZSBpdGVtXG4gICAgICAgIGlmICh0b09ic2VydmUpIHtcbiAgICAgICAgICB0aGlzLklPUmFmSW5zdGFuY2Uuc2Nyb2xsRWxlbWVudHMucHVzaChzY3JvbGxFbGVtZW50SW5zdGFuY2UpO1xuICAgICAgICAgIHRoaXMuSU9SYWZJbnN0YW5jZS5vYnNlcnZlKHNjcm9sbEVsZW1lbnRJbnN0YW5jZS4kZWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzLnB1c2goc2Nyb2xsRWxlbWVudEluc3RhbmNlKTtcbiAgICAgICAgLy8gRHluYW1pYyBvYnNlcnZlIGl0ZW1cbiAgICAgICAgaWYgKHRvT2JzZXJ2ZSkge1xuICAgICAgICAgIHRoaXMuSU9UcmlnZ2VySW5zdGFuY2Uuc2Nyb2xsRWxlbWVudHMucHVzaChzY3JvbGxFbGVtZW50SW5zdGFuY2UpO1xuICAgICAgICAgIHRoaXMuSU9UcmlnZ2VySW5zdGFuY2Uub2JzZXJ2ZShzY3JvbGxFbGVtZW50SW5zdGFuY2UuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDbGVhciBhbGwgU2Nyb2xsRWxlbWVudCBhcnJheXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfdW5zdWJzY3JpYmVBbGxTY3JvbGxFbGVtZW50cygpIHtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5SQUZTY3JvbGxFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUgPSBbXTtcbiAgfVxuICAvKipcclxuICAgKiBTdWJzY3JpYmUgU2Nyb2xsRWxlbWVudCBpbnN0YW5jZSB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTY3JvbGxFbGVtZW50fSBzY3JvbGxFbGVtZW50IC0gU2Nyb2xsRWxlbWVudCBpbnN0YW5jZSBpbnZpZXdcclxuICAgKiAgICAgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkLlxyXG4gICAqL1xuICBfc3Vic2NyaWJlRWxlbWVudFVwZGF0ZShzY3JvbGxFbGVtZW50KSB7XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlLnB1c2goc2Nyb2xsRWxlbWVudCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVW5zY3JpYmUgU2Nyb2xsRWxlbWVudCBpbnN0YW5jZSB0aGF0IGRvZXNuJ3QgbmVlZCB0byBiZSB1cGRhdGVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2Nyb2xsRWxlbWVudH0gc2Nyb2xsRWxlbWVudCAtIFRoZSB1cGRhdGVkIFNjcm9sbEVsZW1lbnQgaW5zdGFuY2VcclxuICAgKiAgICAgb3V0IG9mIHZpZXcgbm93LlxyXG4gICAqL1xuICBfdW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlKHNjcm9sbEVsZW1lbnQpIHtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUgPSB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUuZmlsdGVyKHNjcm9sbEVsZW1lbnRUb1VwZGF0ZSA9PiBzY3JvbGxFbGVtZW50VG9VcGRhdGUuaWQgIT0gc2Nyb2xsRWxlbWVudC5pZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBET00gRWxlbWVudCBuZWVkIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGJlIHVzZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJHNjcm9sbEVsZW1lbnQgLSBUaGUgZWxlbWVudCB0aGF0IG5lZWRzIHRvIGJlIGNoZWNrZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cbiAgX2NoZWNrUmFmTmVlZGVkKCRzY3JvbGxFbGVtZW50KSB7XG4gICAgbGV0IGF0dHJpYnV0ZXNUaGF0TmVlZFJhZiA9IFsuLi5BVFRSSUJVVEVTX1RIQVRfTkVFRF9SQUZdO1xuICAgIC8vIFJlbW92ZSB1dGlsc1xuICAgIGNvbnN0IHJlbW92ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZVRvUmVtb3ZlID0+IHtcbiAgICAgIGF0dHJpYnV0ZXNUaGF0TmVlZFJhZiA9IGF0dHJpYnV0ZXNUaGF0TmVlZFJhZi5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZSAhPSBhdHRyaWJ1dGVUb1JlbW92ZSk7XG4gICAgfTtcbiAgICAvLyAxLiBDaGVjayBzY3JvbGwgb2Zmc2V0IHZhbHVlc1xuICAgIGlmICgkc2Nyb2xsRWxlbWVudC5kYXRhc2V0LnNjcm9sbE9mZnNldCkge1xuICAgICAgY29uc3QgdmFsdWUgPSAkc2Nyb2xsRWxlbWVudC5kYXRhc2V0LnNjcm9sbE9mZnNldC5zcGxpdCgnLCcpLm1hcCh0ZXN0ID0+IHRlc3QucmVwbGFjZSgnJScsICcnKS50cmltKCkpLmpvaW4oJywnKTtcbiAgICAgIGlmICh2YWx1ZSAhPSAnMCwwJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZSgnc2Nyb2xsT2Zmc2V0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZSgnc2Nyb2xsT2Zmc2V0Jyk7XG4gICAgfVxuICAgIC8vIDIuIENoZWNrIHNjcm9sbCBwb3NpdGlvbiB2YWx1ZXNcbiAgICBpZiAoJHNjcm9sbEVsZW1lbnQuZGF0YXNldC5zY3JvbGxQb3NpdGlvbikge1xuICAgICAgY29uc3QgdmFsdWUgPSAkc2Nyb2xsRWxlbWVudC5kYXRhc2V0LnNjcm9sbFBvc2l0aW9uLnRyaW0oKTtcbiAgICAgIGlmICh2YWx1ZSAhPSAndG9wLGJvdHRvbScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVBdHRyaWJ1dGUoJ3Njcm9sbFBvc2l0aW9uJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZSgnc2Nyb2xsUG9zaXRpb24nKTtcbiAgICB9XG4gICAgLy8gMy4gQ2hlY2sgc2Nyb2xsIHNwZWVkIHZhbHVlc1xuICAgIGlmICgkc2Nyb2xsRWxlbWVudC5kYXRhc2V0LnNjcm9sbFNwZWVkICYmICFpc05hTihwYXJzZUZsb2F0KCRzY3JvbGxFbGVtZW50LmRhdGFzZXQuc2Nyb2xsU3BlZWQpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZSgnc2Nyb2xsU3BlZWQnKTtcbiAgICB9XG4gICAgLy8gNC4gQ2hlY2sgb3RoZXJzIGF0dHJpYnV0ZXNcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzVGhhdE5lZWRSYWYpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUgaW4gJHNjcm9sbEVsZW1lbnQuZGF0YXNldCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxyXG4gKiBSZXNpemUgT2JzZXJ2ZXJcclxuICpcclxuICogVGhlIFJlc2l6ZSBPYnNlcnZlciBBUEkgcHJvdmlkZXMgYSBwZXJmb3JtYW50IG1lY2hhbmlzbSBieSB3aGljaCBjb2RlIGNhbiBtb25pdG9yIGFuIGVsZW1lbnQgZm9yIGNoYW5nZXMgdG8gaXRzIHNpemUsXHJcbiAqIHdpdGggbm90aWZpY2F0aW9ucyBiZWluZyBkZWxpdmVyZWQgdG8gdGhlIG9ic2VydmVyIGVhY2ggdGltZSB0aGUgc2l6ZSBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBGZWF0dXJlcyBmdW5jdGlvbnMgdG86XHJcbiAqXHJcbiAqIC0gVHJpZ2dlciB0aGUgcmVzaXplIGNhbGxiYWNrIGlmIHRoZSBzcGVjaWZpZWQgZWxlbWVudCdzIHNpemUgY2hhbmdlLlxyXG4gKlxyXG4gKiBSZWZlcmVuY2VzOlxyXG4gKlxyXG4gKiAtIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzaXplX09ic2VydmVyX0FQSX1cclxuICovXG5jbGFzcyBSTyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZXNpemVFbGVtZW50cyxcbiAgICByZXNpemVDYWxsYmFjayA9ICgpID0+IHt9XG4gIH0pIHtcbiAgICB0aGlzLiRyZXNpemVFbGVtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzRmlyc3RPYnNlcnZlID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXNpemVDYWxsYmFjayA9IHZvaWQgMDtcbiAgICAvLyBQYXJhbWV0ZXJzXG4gICAgdGhpcy4kcmVzaXplRWxlbWVudHMgPSByZXNpemVFbGVtZW50cztcbiAgICB0aGlzLnJlc2l6ZUNhbGxiYWNrID0gcmVzaXplQ2FsbGJhY2s7XG4gICAgLy8gRmxhZ3NcbiAgICB0aGlzLmlzRmlyc3RPYnNlcnZlID0gdHJ1ZTtcbiAgICAvLyBJbml0XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gSW5pdGlhbGl6ZSBSZXNpemUgT2JzZXJ2ZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICAvLyBDYWxsYmFja1xuICAgIGNvbnN0IG9uUmVzaXplID0gZW50cmllcyA9PiB7XG4gICAgICB2YXIgX3RoaXMkcmVzaXplQ2FsbGJhY2s7XG4gICAgICAhdGhpcy5pc0ZpcnN0T2JzZXJ2ZSAmJiAoKF90aGlzJHJlc2l6ZUNhbGxiYWNrID0gdGhpcy5yZXNpemVDYWxsYmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHJlc2l6ZUNhbGxiYWNrLmNhbGwodGhpcykpO1xuICAgICAgdGhpcy5pc0ZpcnN0T2JzZXJ2ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgLy8gSW5zdGFuY2VcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG9uUmVzaXplKTtcbiAgICAvLyBPYnNlcnZlIGVhY2ggZGVmYXVsdCBlbGVtZW50c1xuICAgIGZvciAoY29uc3QgJHJlc2l6ZUVsZW1lbnQgb2YgdGhpcy4kcmVzaXplRWxlbWVudHMpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSgkcmVzaXplRWxlbWVudCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gRGVzdHJveSBSZXNpemUgT2JzZXJ2ZXIuXHJcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEB0eXBlIHtJTGVuaXNPcHRpb25zfVxyXG4gKi9cbmNvbnN0IGRlZmF1bHRMZW5pc09wdGlvbnMgPSB7XG4gIHdyYXBwZXI6IHdpbmRvdyxcbiAgY29udGVudDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICBsZXJwOiAwLjEsXG4gIGR1cmF0aW9uOiAxLjIsXG4gIG9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICBnZXN0dXJlT3JpZW50YXRpb246ICd2ZXJ0aWNhbCcsXG4gIHNtb290aFdoZWVsOiB0cnVlLFxuICBzbW9vdGhUb3VjaDogZmFsc2UsXG4gIHdoZWVsTXVsdGlwbGllcjogMSxcbiAgdG91Y2hNdWx0aXBsaWVyOiAyLFxuICBub3JtYWxpemVXaGVlbDogdHJ1ZSxcbiAgZWFzaW5nOiB0ID0+IE1hdGgubWluKDEsIDEuMDAxIC0gTWF0aC5wb3coMiwgLTEwICogdCkpIC8vIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci9icnM1NGw0eG91XG59O1xuLyoqXHJcbiAqIExvY29tb3RpdmUgU2Nyb2xsXHJcbiAqXHJcbiAqIERldGVjdGlvbiBvZiBlbGVtZW50cyBpbiB2aWV3cG9ydCAmIHNtb290aCBzY3JvbGxpbmcgd2l0aCBwYXJhbGxheC5cclxuICpcclxuICogSW5zcGlyZWQgYnlcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2NvbW90aXZlbXRsL2xvY29tb3RpdmUtc2Nyb2xsIGxvY29tb3RpdmUtc2Nyb2xsLmpzfVxyXG4gKiBhbmQgYnVpbHQgYXJvdW5kXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3R1ZGlvLWZyZWlnaHQvbGVuaXMgbGVuaXMuanN9LlxyXG4gKi9cbmNsYXNzIExvY29tb3RpdmVTY3JvbGwge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbGVuaXNPcHRpb25zID0ge30sXG4gICAgbW9kdWxhckluc3RhbmNlLFxuICAgIHRyaWdnZXJSb290TWFyZ2luLFxuICAgIHJhZlJvb3RNYXJnaW4sXG4gICAgYXV0b1Jlc2l6ZSA9IHRydWUsXG4gICAgYXV0b1N0YXJ0ID0gdHJ1ZSxcbiAgICBzY3JvbGxDYWxsYmFjayA9ICgpID0+IHt9LFxuICAgIGluaXRDdXN0b21UaWNrZXIsXG4gICAgZGVzdHJveUN1c3RvbVRpY2tlclxuICB9ID0ge30pIHtcbiAgICB0aGlzLnJhZlBsYXlpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5sZW5pc0luc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuY29yZUluc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMubGVuaXNPcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMubW9kdWxhckluc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMudHJpZ2dlclJvb3RNYXJnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5yYWZSb290TWFyZ2luID0gdm9pZCAwO1xuICAgIHRoaXMucmFmSW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRvUmVzaXplID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0b1N0YXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuUk9JbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRDdXN0b21UaWNrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXN0cm95Q3VzdG9tVGlja2VyID0gdm9pZCAwO1xuICAgIHRoaXMuX29uUmVuZGVyQmluZCA9IHZvaWQgMDtcbiAgICB0aGlzLl9vblJlc2l6ZUJpbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5fb25TY3JvbGxUb0JpbmQgPSB2b2lkIDA7XG4gICAgLy8gQXJndW1lbnRzXG4gICAgdGhpcy5sZW5pc09wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdExlbmlzT3B0aW9ucywgbGVuaXNPcHRpb25zKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIGxlbmlzT3B0aW9ucyxcbiAgICAgIG1vZHVsYXJJbnN0YW5jZSxcbiAgICAgIHRyaWdnZXJSb290TWFyZ2luLFxuICAgICAgcmFmUm9vdE1hcmdpbixcbiAgICAgIGF1dG9SZXNpemUsXG4gICAgICBhdXRvU3RhcnQsXG4gICAgICBzY3JvbGxDYWxsYmFjayxcbiAgICAgIGluaXRDdXN0b21UaWNrZXIsXG4gICAgICBkZXN0cm95Q3VzdG9tVGlja2VyXG4gICAgfSk7XG4gICAgLy8gQmluZGluZ1xuICAgIHRoaXMuX29uUmVuZGVyQmluZCA9IHRoaXMuX29uUmVuZGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TY3JvbGxUb0JpbmQgPSB0aGlzLl9vblNjcm9sbFRvLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25SZXNpemVCaW5kID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAvLyBEYXRhXG4gICAgdGhpcy5yYWZQbGF5aW5nID0gZmFsc2U7XG4gICAgLy8gSW5pdFxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIEluaXRpYWxpemUgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgX3RoaXMkbGVuaXNJbnN0YW5jZTtcbiAgICAvLyBDcmVhdGUgTGVuaXMgaW5zdGFuY2VcbiAgICB0aGlzLmxlbmlzSW5zdGFuY2UgPSBuZXcgTGVuaXMoe1xuICAgICAgd3JhcHBlcjogdGhpcy5sZW5pc09wdGlvbnMud3JhcHBlcixcbiAgICAgIGNvbnRlbnQ6IHRoaXMubGVuaXNPcHRpb25zLmNvbnRlbnQsXG4gICAgICBsZXJwOiB0aGlzLmxlbmlzT3B0aW9ucy5sZXJwLFxuICAgICAgZHVyYXRpb246IHRoaXMubGVuaXNPcHRpb25zLmR1cmF0aW9uLFxuICAgICAgb3JpZW50YXRpb246IHRoaXMubGVuaXNPcHRpb25zLm9yaWVudGF0aW9uLFxuICAgICAgZ2VzdHVyZU9yaWVudGF0aW9uOiB0aGlzLmxlbmlzT3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24sXG4gICAgICBzbW9vdGhXaGVlbDogdGhpcy5sZW5pc09wdGlvbnMuc21vb3RoV2hlZWwsXG4gICAgICBzbW9vdGhUb3VjaDogdGhpcy5sZW5pc09wdGlvbnMuc21vb3RoVG91Y2gsXG4gICAgICB3aGVlbE11bHRpcGxpZXI6IHRoaXMubGVuaXNPcHRpb25zLndoZWVsTXVsdGlwbGllcixcbiAgICAgIHRvdWNoTXVsdGlwbGllcjogdGhpcy5sZW5pc09wdGlvbnMudG91Y2hNdWx0aXBsaWVyLFxuICAgICAgbm9ybWFsaXplV2hlZWw6IHRoaXMubGVuaXNPcHRpb25zLm5vcm1hbGl6ZVdoZWVsLFxuICAgICAgZWFzaW5nOiB0aGlzLmxlbmlzT3B0aW9ucy5lYXNpbmdcbiAgICB9KTtcbiAgICAoX3RoaXMkbGVuaXNJbnN0YW5jZSA9IHRoaXMubGVuaXNJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxlbmlzSW5zdGFuY2Uub24oJ3Njcm9sbCcsIHRoaXMuc2Nyb2xsQ2FsbGJhY2spO1xuICAgIC8vIEFkZCBzY3JvbGwgZGlyZWN0aW9uIGF0dHJpYnV0ZSBvbiBib2R5XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtb3JpZW50YXRpb24nLCB0aGlzLmxlbmlzSW5zdGFuY2Uub3B0aW9ucy5vcmllbnRhdGlvbik7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBDb3JlIEluc3RhbmNlXG4gICAgICB0aGlzLmNvcmVJbnN0YW5jZSA9IG5ldyBDb3JlKHtcbiAgICAgICAgJGVsOiB0aGlzLmxlbmlzSW5zdGFuY2Uucm9vdEVsZW1lbnQsXG4gICAgICAgIG1vZHVsYXJJbnN0YW5jZTogdGhpcy5tb2R1bGFySW5zdGFuY2UsXG4gICAgICAgIHRyaWdnZXJSb290TWFyZ2luOiB0aGlzLnRyaWdnZXJSb290TWFyZ2luLFxuICAgICAgICByYWZSb290TWFyZ2luOiB0aGlzLnJhZlJvb3RNYXJnaW4sXG4gICAgICAgIHNjcm9sbE9yaWVudGF0aW9uOiB0aGlzLmxlbmlzSW5zdGFuY2Uub3B0aW9ucy5vcmllbnRhdGlvblxuICAgICAgfSk7XG4gICAgICAvLyBCaW5kIEV2ZW50c1xuICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgICAgLy8gUkFGIHdhcm5pbmdcbiAgICAgIGlmICh0aGlzLmluaXRDdXN0b21UaWNrZXIgJiYgIXRoaXMuZGVzdHJveUN1c3RvbVRpY2tlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2luaXRDdXN0b21UaWNrZXIgY2FsbGJhY2sgaXMgZGVjbGFyZWQsIGJ1dCBkZXN0cm95Q3VzdG9tVGlja2VyIGlzIG5vdC4gUGxlYXNlIHBheSBhdHRlbnRpb24uIEl0IGNvdWxkIGNhdXNlIHRyb3VibGUuJyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmluaXRDdXN0b21UaWNrZXIgJiYgdGhpcy5kZXN0cm95Q3VzdG9tVGlja2VyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZGVzdHJveUN1c3RvbVRpY2tlciBjYWxsYmFjayBpcyBkZWNsYXJlZCwgYnV0IGluaXRDdXN0b21UaWNrZXIgaXMgbm90LiBQbGVhc2UgcGF5IGF0dGVudGlvbi4gSXQgY291bGQgY2F1c2UgdHJvdWJsZS4nKTtcbiAgICAgIH1cbiAgICAgIC8vIFN0YXJ0IFJBRlxuICAgICAgdGhpcy5hdXRvU3RhcnQgJiYgdGhpcy5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gRGVzdHJveSBpbnN0YW5jZS5cclxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdG9wIHJhZlxuICAgIHRoaXMuc3RvcCgpO1xuICAgIC8vIFVuYmluZCBFdmVudHNcbiAgICB0aGlzLl91bmJpbmRFdmVudHMoKTtcbiAgICAvLyBEZXN0cm95IExlbmlzXG4gICAgdGhpcy5sZW5pc0luc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAvLyBEZXN0cm95IENvcmVcbiAgICB0aGlzLmNvcmVJbnN0YW5jZS5kZXN0cm95KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogRXZlbnRzIC0gU3Vic2NyaWJlIGV2ZW50cyB0byBsaXN0ZW4uXHJcbiAgICovXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuX2JpbmRTY3JvbGxUb0V2ZW50cygpO1xuICAgIGlmICh0aGlzLmF1dG9SZXNpemUpIHtcbiAgICAgIGlmICgnUmVzaXplT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgICAgICB0aGlzLlJPSW5zdGFuY2UgPSBuZXcgUk8oe1xuICAgICAgICAgIHJlc2l6ZUVsZW1lbnRzOiBbZG9jdW1lbnQuYm9keV0sXG4gICAgICAgICAgcmVzaXplQ2FsbGJhY2s6IHRoaXMuX29uUmVzaXplQmluZFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZUJpbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBFdmVudHMgLSBVbnN1YnNjcmliZSBsaXN0ZW5lZCBldmVudHMuXHJcbiAgICovXG4gIF91bmJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5fdW5iaW5kU2Nyb2xsVG9FdmVudHMoKTtcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICBpZiAoJ1Jlc2l6ZU9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgdGhpcy5ST0luc3RhbmNlICYmIHRoaXMuUk9JbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCaW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogRXZlbnRzIC0gU3Vic2NyaWJlIHNjcm9sbFRvIGV2ZW50cyB0byBsaXN0ZW4uXHJcbiAgICovXG4gIF9iaW5kU2Nyb2xsVG9FdmVudHMoJGNvbnRhaW5lcikge1xuICAgIGNvbnN0ICRyb290Q29udGFpbmVyID0gJGNvbnRhaW5lciA/ICRjb250YWluZXIgOiB0aGlzLmxlbmlzSW5zdGFuY2Uucm9vdEVsZW1lbnQ7XG4gICAgY29uc3QgJHNjcm9sbFRvRWxlbWVudHMgPSAkcm9vdENvbnRhaW5lciA9PSBudWxsID8gdm9pZCAwIDogJHJvb3RDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2Nyb2xsLXRvXScpO1xuICAgICgkc2Nyb2xsVG9FbGVtZW50cyA9PSBudWxsID8gdm9pZCAwIDogJHNjcm9sbFRvRWxlbWVudHMubGVuZ3RoKSAmJiAkc2Nyb2xsVG9FbGVtZW50cy5mb3JFYWNoKCRlbCA9PiB7XG4gICAgICAkZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vblNjcm9sbFRvQmluZCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEV2ZW50cyAtIFVuc3Vic2NyaWJlIHNjcm9sbFRvIGxpc3RlbmVkIGV2ZW50cy5cclxuICAgKi9cbiAgX3VuYmluZFNjcm9sbFRvRXZlbnRzKCRjb250YWluZXIpIHtcbiAgICBjb25zdCAkcm9vdENvbnRhaW5lciA9ICRjb250YWluZXIgPyAkY29udGFpbmVyIDogdGhpcy5sZW5pc0luc3RhbmNlLnJvb3RFbGVtZW50O1xuICAgIGNvbnN0ICRzY3JvbGxUb0VsZW1lbnRzID0gJHJvb3RDb250YWluZXIgPT0gbnVsbCA/IHZvaWQgMCA6ICRyb290Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNjcm9sbC10b10nKTtcbiAgICAoJHNjcm9sbFRvRWxlbWVudHMgPT0gbnVsbCA/IHZvaWQgMCA6ICRzY3JvbGxUb0VsZW1lbnRzLmxlbmd0aCkgJiYgJHNjcm9sbFRvRWxlbWVudHMuZm9yRWFjaCgkZWwgPT4ge1xuICAgICAgJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25TY3JvbGxUb0JpbmQsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayAtIFJlc2l6ZSBjYWxsYmFjay5cclxuICAgKi9cbiAgX29uUmVzaXplKCkge1xuICAgIC8vIFdhaXRpbmcgdGhlIG5leHQgZnJhbWUgdG8gZ2V0IHRoZSBuZXcgY3VycmVudCBzY3JvbGwgdmFsdWUgcmV0dXJuIGJ5IExlbmlzXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHZhciBfdGhpcyRjb3JlSW5zdGFuY2U7XG4gICAgICAoX3RoaXMkY29yZUluc3RhbmNlID0gdGhpcy5jb3JlSW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb3JlSW5zdGFuY2Uub25SZXNpemUoe1xuICAgICAgICBjdXJyZW50U2Nyb2xsOiB0aGlzLmxlbmlzSW5zdGFuY2Uuc2Nyb2xsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayAtIFJlbmRlciBjYWxsYmFjay5cclxuICAgKi9cbiAgX29uUmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRsZW5pc0luc3RhbmNlMiwgX3RoaXMkY29yZUluc3RhbmNlMjtcbiAgICAoX3RoaXMkbGVuaXNJbnN0YW5jZTIgPSB0aGlzLmxlbmlzSW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZW5pc0luc3RhbmNlMi5yYWYoRGF0ZS5ub3coKSk7XG4gICAgKF90aGlzJGNvcmVJbnN0YW5jZTIgPSB0aGlzLmNvcmVJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvcmVJbnN0YW5jZTIub25SZW5kZXIoe1xuICAgICAgY3VycmVudFNjcm9sbDogdGhpcy5sZW5pc0luc3RhbmNlLnNjcm9sbCxcbiAgICAgIHNtb290aDogdGhpcy5sZW5pc0luc3RhbmNlLmlzU21vb3RoXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgLSBTY3JvbGwgVG8gY2FsbGJhY2suXHJcbiAgICovXG4gIF9vblNjcm9sbFRvKGV2ZW50KSB7XG4gICAgdmFyIF9ldmVudCRjdXJyZW50VGFyZ2V0O1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgJHRhcmdldCA9IChfZXZlbnQkY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQpICE9IG51bGwgPyBfZXZlbnQkY3VycmVudFRhcmdldCA6IG51bGw7XG4gICAgaWYgKCEkdGFyZ2V0KSByZXR1cm47XG4gICAgY29uc3QgdGFyZ2V0ID0gJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLXRvLWhyZWYnKSB8fCAkdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIGNvbnN0IG9mZnNldCA9ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC10by1vZmZzZXQnKSB8fCAwO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLXRvLWR1cmF0aW9uJykgfHwgdGhpcy5sZW5pc09wdGlvbnMuZHVyYXRpb24gfHwgZGVmYXVsdExlbmlzT3B0aW9ucy5kdXJhdGlvbjtcbiAgICB0YXJnZXQgJiYgdGhpcy5zY3JvbGxUbyh0YXJnZXQsIHtcbiAgICAgIG9mZnNldDogdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycgPyBwYXJzZUludChvZmZzZXQpIDogb2Zmc2V0LFxuICAgICAgZHVyYXRpb246IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ3N0cmluZycgPyBwYXJzZUludChkdXJhdGlvbikgOiBkdXJhdGlvblxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0YXJ0IFJlcXVlc3RBbmltYXRpb25GcmFtZSB0aGF0IGFjdGl2ZSBMZW5pcyBzbW9vdGggYW5kIHNjcm9sbCBwcm9ncmVzcy5cclxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMucmFmUGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJhZlBsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5pdEN1c3RvbVRpY2tlciA/IHRoaXMuaW5pdEN1c3RvbVRpY2tlcih0aGlzLl9vblJlbmRlckJpbmQpIDogdGhpcy5fcmFmKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RvcCBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGhhdCBhY3RpdmUgTGVuaXMgc21vb3RoIGFuZCBzY3JvbGwgcHJvZ3Jlc3MuXHJcbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKCF0aGlzLnJhZlBsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yYWZQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q3VzdG9tVGlja2VyID8gdGhpcy5kZXN0cm95Q3VzdG9tVGlja2VyKHRoaXMuX29uUmVuZGVyQmluZCkgOiB0aGlzLnJhZkluc3RhbmNlICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSW5zdGFuY2UpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZSBvbGQgc2Nyb2xsIGVsZW1lbnRzIGl0ZW1zIGFuZCByZWJ1aWxkIFNjcm9sbEVsZW1lbnRzIGluc3RhbmNlcy5cclxuICAgKi9cbiAgcmVtb3ZlU2Nyb2xsRWxlbWVudHMoJG9sZENvbnRhaW5lcikge1xuICAgIHZhciBfdGhpcyRjb3JlSW5zdGFuY2UzO1xuICAgIGlmICghJG9sZENvbnRhaW5lcikge1xuICAgICAgY29uc29sZS5lcnJvcignUGxlYXNlIHByb3ZpZGUgYSBET00gRWxlbWVudCBhcyAkb2xkQ29udGFpbmVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VuYmluZFNjcm9sbFRvRXZlbnRzKCRvbGRDb250YWluZXIpO1xuICAgIChfdGhpcyRjb3JlSW5zdGFuY2UzID0gdGhpcy5jb3JlSW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb3JlSW5zdGFuY2UzLnJlbW92ZVNjcm9sbEVsZW1lbnRzKCRvbGRDb250YWluZXIpO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZCBuZXcgc2Nyb2xsIGVsZW1lbnRzIGl0ZW1zIGFuZCByZWJ1aWxkIFNjcm9sbEVsZW1lbnRzIGluc3RhbmNlcy5cclxuICAgKi9cbiAgYWRkU2Nyb2xsRWxlbWVudHMoJG5ld0NvbnRhaW5lcikge1xuICAgIHZhciBfdGhpcyRjb3JlSW5zdGFuY2U0O1xuICAgIGlmICghJG5ld0NvbnRhaW5lcikge1xuICAgICAgY29uc29sZS5lcnJvcignUGxlYXNlIHByb3ZpZGUgYSBET00gRWxlbWVudCBhcyAkbmV3Q29udGFpbmVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIChfdGhpcyRjb3JlSW5zdGFuY2U0ID0gdGhpcy5jb3JlSW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb3JlSW5zdGFuY2U0LmFkZFNjcm9sbEVsZW1lbnRzKCRuZXdDb250YWluZXIpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLl9iaW5kU2Nyb2xsVG9FdmVudHMoJG5ld0NvbnRhaW5lcik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogVHJpZ2dlciByZXNpemUgY2FsbGJhY2suXHJcbiAgICovXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLl9vblJlc2l6ZUJpbmQoKTtcbiAgfVxuICAvKipcclxuICAgKiBUcmlnZ2VyIHNjcm9sbCB0byBjYWxsYmFjay5cclxuICAgKi9cbiAgc2Nyb2xsVG8odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJGxlbmlzSW5zdGFuY2UzO1xuICAgIChfdGhpcyRsZW5pc0luc3RhbmNlMyA9IHRoaXMubGVuaXNJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxlbmlzSW5zdGFuY2UzLnNjcm9sbFRvKHRhcmdldCwge1xuICAgICAgb2Zmc2V0OiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCxcbiAgICAgIGxlcnA6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubGVycCxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgaW1tZWRpYXRlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmltbWVkaWF0ZSxcbiAgICAgIGxvY2s6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jayxcbiAgICAgIGZvcmNlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlLFxuICAgICAgZWFzaW5nOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmVhc2luZyxcbiAgICAgIG9uQ29tcGxldGU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25Db21wbGV0ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlcXVlc3RBbmltYXRpb25GcmFtZSB0aGF0IGFjdGl2ZSBMZW5pcyBzbW9vdGggYW5kIHNjcm9sbCBwcm9ncmVzcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKi9cbiAgX3JhZigpIHtcbiAgICB0aGlzLl9vblJlbmRlckJpbmQoKTtcbiAgICB0aGlzLnJhZkluc3RhbmNlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX3JhZigpKTtcbiAgfVxufVxuXG5leHBvcnQgeyBMb2NvbW90aXZlU2Nyb2xsIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY29tb3RpdmUtc2Nyb2xsLm1vZGVybi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs\n");

/***/ })

};
;